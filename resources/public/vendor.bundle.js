webpackJsonp([2],[
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n__webpack_require__(3);\n__webpack_require__(22);\n__webpack_require__(24);\n__webpack_require__(39);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/vendor.ts\n ** module id = 0\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./src/vendor.ts?");

/***/ },
/* 1 */,
/* 2 */,
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(global) {/**\n * @license Angular v2.0.1\n * (c) 2010-2016 Google, Inc. https://angular.io/\n * License: MIT\n */\n(function (global, factory) {\n     true ? factory(exports, __webpack_require__(4), __webpack_require__(5)) :\n    typeof define === 'function' && define.amd ? define(['exports', 'rxjs/Subject', 'rxjs/Observable'], factory) :\n    (factory((global.ng = global.ng || {}, global.ng.core = global.ng.core || {}),global.Rx,global.Rx));\n}(this, function (exports,rxjs_Subject,rxjs_Observable) { 'use strict';\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var globalScope;\n    if (typeof window === 'undefined') {\n        if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {\n            // TODO: Replace any with WorkerGlobalScope from lib.webworker.d.ts #3492\n            globalScope = self;\n        }\n        else {\n            globalScope = global;\n        }\n    }\n    else {\n        globalScope = window;\n    }\n    function scheduleMicroTask(fn) {\n        Zone.current.scheduleMicroTask('scheduleMicrotask', fn);\n    }\n    // Need to declare a new variable for global here since TypeScript\n    // exports the original value of the symbol.\n    var global$1 = globalScope;\n    function getTypeNameForDebugging(type) {\n        if (type['name']) {\n            return type['name'];\n        }\n        return typeof type;\n    }\n    var Math = global$1.Math;\n    // TODO: remove calls to assert in production environment\n    // Note: Can't just export this and import in in other files\n    // as `assert` is a reserved keyword in Dart\n    global$1.assert = function assert(condition) {\n        // TODO: to be fixed properly via #2830, noop for now\n    };\n    function isPresent(obj) {\n        return obj !== undefined && obj !== null;\n    }\n    function isBlank(obj) {\n        return obj === undefined || obj === null;\n    }\n    function isString(obj) {\n        return typeof obj === 'string';\n    }\n    function isFunction(obj) {\n        return typeof obj === 'function';\n    }\n    function isArray(obj) {\n        return Array.isArray(obj);\n    }\n    function stringify(token) {\n        if (typeof token === 'string') {\n            return token;\n        }\n        if (token === undefined || token === null) {\n            return '' + token;\n        }\n        if (token.overriddenName) {\n            return token.overriddenName;\n        }\n        if (token.name) {\n            return token.name;\n        }\n        var res = token.toString();\n        var newLineIndex = res.indexOf('\\n');\n        return (newLineIndex === -1) ? res : res.substring(0, newLineIndex);\n    }\n    var StringWrapper = (function () {\n        function StringWrapper() {\n        }\n        StringWrapper.fromCharCode = function (code) { return String.fromCharCode(code); };\n        StringWrapper.charCodeAt = function (s, index) { return s.charCodeAt(index); };\n        StringWrapper.split = function (s, regExp) { return s.split(regExp); };\n        StringWrapper.equals = function (s, s2) { return s === s2; };\n        StringWrapper.stripLeft = function (s, charVal) {\n            if (s && s.length) {\n                var pos = 0;\n                for (var i = 0; i < s.length; i++) {\n                    if (s[i] != charVal)\n                        break;\n                    pos++;\n                }\n                s = s.substring(pos);\n            }\n            return s;\n        };\n        StringWrapper.stripRight = function (s, charVal) {\n            if (s && s.length) {\n                var pos = s.length;\n                for (var i = s.length - 1; i >= 0; i--) {\n                    if (s[i] != charVal)\n                        break;\n                    pos--;\n                }\n                s = s.substring(0, pos);\n            }\n            return s;\n        };\n        StringWrapper.replace = function (s, from, replace) {\n            return s.replace(from, replace);\n        };\n        StringWrapper.replaceAll = function (s, from, replace) {\n            return s.replace(from, replace);\n        };\n        StringWrapper.slice = function (s, from, to) {\n            if (from === void 0) { from = 0; }\n            if (to === void 0) { to = null; }\n            return s.slice(from, to === null ? undefined : to);\n        };\n        StringWrapper.replaceAllMapped = function (s, from, cb) {\n            return s.replace(from, function () {\n                var matches = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    matches[_i - 0] = arguments[_i];\n                }\n                // Remove offset & string from the result array\n                matches.splice(-2, 2);\n                // The callback receives match, p1, ..., pn\n                return cb(matches);\n            });\n        };\n        StringWrapper.contains = function (s, substr) { return s.indexOf(substr) != -1; };\n        StringWrapper.compare = function (a, b) {\n            if (a < b) {\n                return -1;\n            }\n            else if (a > b) {\n                return 1;\n            }\n            else {\n                return 0;\n            }\n        };\n        return StringWrapper;\n    }());\n    var NumberWrapper = (function () {\n        function NumberWrapper() {\n        }\n        NumberWrapper.toFixed = function (n, fractionDigits) { return n.toFixed(fractionDigits); };\n        NumberWrapper.equal = function (a, b) { return a === b; };\n        NumberWrapper.parseIntAutoRadix = function (text) {\n            var result = parseInt(text);\n            if (isNaN(result)) {\n                throw new Error('Invalid integer literal when parsing ' + text);\n            }\n            return result;\n        };\n        NumberWrapper.parseInt = function (text, radix) {\n            if (radix == 10) {\n                if (/^(\\-|\\+)?[0-9]+$/.test(text)) {\n                    return parseInt(text, radix);\n                }\n            }\n            else if (radix == 16) {\n                if (/^(\\-|\\+)?[0-9ABCDEFabcdef]+$/.test(text)) {\n                    return parseInt(text, radix);\n                }\n            }\n            else {\n                var result = parseInt(text, radix);\n                if (!isNaN(result)) {\n                    return result;\n                }\n            }\n            throw new Error('Invalid integer literal when parsing ' + text + ' in base ' + radix);\n        };\n        Object.defineProperty(NumberWrapper, \"NaN\", {\n            get: function () { return NaN; },\n            enumerable: true,\n            configurable: true\n        });\n        NumberWrapper.isNumeric = function (value) { return !isNaN(value - parseFloat(value)); };\n        NumberWrapper.isNaN = function (value) { return isNaN(value); };\n        NumberWrapper.isInteger = function (value) { return Number.isInteger(value); };\n        return NumberWrapper;\n    }());\n    // JS has NaN !== NaN\n    function looseIdentical(a, b) {\n        return a === b || typeof a === 'number' && typeof b === 'number' && isNaN(a) && isNaN(b);\n    }\n    // JS considers NaN is the same as NaN for map Key (while NaN !== NaN otherwise)\n    // see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map\n    function getMapKey(value) {\n        return value;\n    }\n    function isJsObject(o) {\n        return o !== null && (typeof o === 'function' || typeof o === 'object');\n    }\n    function print(obj) {\n        console.log(obj);\n    }\n    function warn(obj) {\n        console.warn(obj);\n    }\n    var _symbolIterator = null;\n    function getSymbolIterator() {\n        if (isBlank(_symbolIterator)) {\n            if (isPresent(globalScope.Symbol) && isPresent(Symbol.iterator)) {\n                _symbolIterator = Symbol.iterator;\n            }\n            else {\n                // es6-shim specific logic\n                var keys = Object.getOwnPropertyNames(Map.prototype);\n                for (var i = 0; i < keys.length; ++i) {\n                    var key = keys[i];\n                    if (key !== 'entries' && key !== 'size' &&\n                        Map.prototype[key] === Map.prototype['entries']) {\n                        _symbolIterator = key;\n                    }\n                }\n            }\n        }\n        return _symbolIterator;\n    }\n    function isPrimitive(obj) {\n        return !isJsObject(obj);\n    }\n\n    var _nextClassId = 0;\n    function extractAnnotation(annotation) {\n        if (isFunction(annotation) && annotation.hasOwnProperty('annotation')) {\n            // it is a decorator, extract annotation\n            annotation = annotation.annotation;\n        }\n        return annotation;\n    }\n    function applyParams(fnOrArray, key) {\n        if (fnOrArray === Object || fnOrArray === String || fnOrArray === Function ||\n            fnOrArray === Number || fnOrArray === Array) {\n            throw new Error(\"Can not use native \" + stringify(fnOrArray) + \" as constructor\");\n        }\n        if (isFunction(fnOrArray)) {\n            return fnOrArray;\n        }\n        else if (fnOrArray instanceof Array) {\n            var annotations = fnOrArray;\n            var annoLength = annotations.length - 1;\n            var fn = fnOrArray[annoLength];\n            if (!isFunction(fn)) {\n                throw new Error(\"Last position of Class method array must be Function in key \" + key + \" was '\" + stringify(fn) + \"'\");\n            }\n            if (annoLength != fn.length) {\n                throw new Error(\"Number of annotations (\" + annoLength + \") does not match number of arguments (\" + fn.length + \") in the function: \" + stringify(fn));\n            }\n            var paramsAnnotations = [];\n            for (var i = 0, ii = annotations.length - 1; i < ii; i++) {\n                var paramAnnotations = [];\n                paramsAnnotations.push(paramAnnotations);\n                var annotation = annotations[i];\n                if (annotation instanceof Array) {\n                    for (var j = 0; j < annotation.length; j++) {\n                        paramAnnotations.push(extractAnnotation(annotation[j]));\n                    }\n                }\n                else if (isFunction(annotation)) {\n                    paramAnnotations.push(extractAnnotation(annotation));\n                }\n                else {\n                    paramAnnotations.push(annotation);\n                }\n            }\n            Reflect.defineMetadata('parameters', paramsAnnotations, fn);\n            return fn;\n        }\n        else {\n            throw new Error(\"Only Function or Array is supported in Class definition for key '\" + key + \"' is '\" + stringify(fnOrArray) + \"'\");\n        }\n    }\n    /**\n     * Provides a way for expressing ES6 classes with parameter annotations in ES5.\n     *\n     * ## Basic Example\n     *\n     * ```\n     * var Greeter = ng.Class({\n     *   constructor: function(name) {\n     *     this.name = name;\n     *   },\n     *\n     *   greet: function() {\n     *     alert('Hello ' + this.name + '!');\n     *   }\n     * });\n     * ```\n     *\n     * is equivalent to ES6:\n     *\n     * ```\n     * class Greeter {\n     *   constructor(name) {\n     *     this.name = name;\n     *   }\n     *\n     *   greet() {\n     *     alert('Hello ' + this.name + '!');\n     *   }\n     * }\n     * ```\n     *\n     * or equivalent to ES5:\n     *\n     * ```\n     * var Greeter = function (name) {\n     *   this.name = name;\n     * }\n     *\n     * Greeter.prototype.greet = function () {\n     *   alert('Hello ' + this.name + '!');\n     * }\n     * ```\n     *\n     * ### Example with parameter annotations\n     *\n     * ```\n     * var MyService = ng.Class({\n     *   constructor: [String, [new Query(), QueryList], function(name, queryList) {\n     *     ...\n     *   }]\n     * });\n     * ```\n     *\n     * is equivalent to ES6:\n     *\n     * ```\n     * class MyService {\n     *   constructor(name: string, @Query() queryList: QueryList) {\n     *     ...\n     *   }\n     * }\n     * ```\n     *\n     * ### Example with inheritance\n     *\n     * ```\n     * var Shape = ng.Class({\n     *   constructor: (color) {\n     *     this.color = color;\n     *   }\n     * });\n     *\n     * var Square = ng.Class({\n     *   extends: Shape,\n     *   constructor: function(color, size) {\n     *     Shape.call(this, color);\n     *     this.size = size;\n     *   }\n     * });\n     * ```\n     * @stable\n     */\n    function Class(clsDef) {\n        var constructor = applyParams(clsDef.hasOwnProperty('constructor') ? clsDef.constructor : undefined, 'constructor');\n        var proto = constructor.prototype;\n        if (clsDef.hasOwnProperty('extends')) {\n            if (isFunction(clsDef.extends)) {\n                constructor.prototype = proto =\n                    Object.create(clsDef.extends.prototype);\n            }\n            else {\n                throw new Error(\"Class definition 'extends' property must be a constructor function was: \" + stringify(clsDef.extends));\n            }\n        }\n        for (var key in clsDef) {\n            if (key != 'extends' && key != 'prototype' && clsDef.hasOwnProperty(key)) {\n                proto[key] = applyParams(clsDef[key], key);\n            }\n        }\n        if (this && this.annotations instanceof Array) {\n            Reflect.defineMetadata('annotations', this.annotations, constructor);\n        }\n        var constructorName = constructor['name'];\n        if (!constructorName || constructorName === 'constructor') {\n            constructor['overriddenName'] = \"class\" + _nextClassId++;\n        }\n        return constructor;\n    }\n    var Reflect = global$1.Reflect;\n    function makeDecorator(name, props, parentClass, chainFn) {\n        if (chainFn === void 0) { chainFn = null; }\n        var metaCtor = makeMetadataCtor([props]);\n        function DecoratorFactory(objOrType) {\n            if (!(Reflect && Reflect.getMetadata)) {\n                throw 'reflect-metadata shim is required when using class decorators';\n            }\n            if (this instanceof DecoratorFactory) {\n                metaCtor.call(this, objOrType);\n                return this;\n            }\n            else {\n                var annotationInstance_1 = new DecoratorFactory(objOrType);\n                var chainAnnotation = isFunction(this) && this.annotations instanceof Array ? this.annotations : [];\n                chainAnnotation.push(annotationInstance_1);\n                var TypeDecorator = function TypeDecorator(cls) {\n                    var annotations = Reflect.getOwnMetadata('annotations', cls) || [];\n                    annotations.push(annotationInstance_1);\n                    Reflect.defineMetadata('annotations', annotations, cls);\n                    return cls;\n                };\n                TypeDecorator.annotations = chainAnnotation;\n                TypeDecorator.Class = Class;\n                if (chainFn)\n                    chainFn(TypeDecorator);\n                return TypeDecorator;\n            }\n        }\n        if (parentClass) {\n            DecoratorFactory.prototype = Object.create(parentClass.prototype);\n        }\n        DecoratorFactory.prototype.toString = function () { return (\"@\" + name); };\n        DecoratorFactory.annotationCls = DecoratorFactory;\n        return DecoratorFactory;\n    }\n    function makeMetadataCtor(props) {\n        function ctor() {\n            var _this = this;\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i - 0] = arguments[_i];\n            }\n            props.forEach(function (prop, i) {\n                var argVal = args[i];\n                if (Array.isArray(prop)) {\n                    // plain parameter\n                    var val = !argVal || argVal === undefined ? prop[1] : argVal;\n                    _this[prop[0]] = val;\n                }\n                else {\n                    for (var propName in prop) {\n                        var val = !argVal || argVal[propName] === undefined ? prop[propName] : argVal[propName];\n                        _this[propName] = val;\n                    }\n                }\n            });\n        }\n        return ctor;\n    }\n    function makeParamDecorator(name, props, parentClass) {\n        var metaCtor = makeMetadataCtor(props);\n        function ParamDecoratorFactory() {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i - 0] = arguments[_i];\n            }\n            if (this instanceof ParamDecoratorFactory) {\n                metaCtor.apply(this, args);\n                return this;\n            }\n            var annotationInstance = new ((_a = ParamDecoratorFactory).bind.apply(_a, [void 0].concat(args)))();\n            ParamDecorator.annotation = annotationInstance;\n            return ParamDecorator;\n            function ParamDecorator(cls, unusedKey, index) {\n                var parameters = Reflect.getMetadata('parameters', cls) || [];\n                // there might be gaps if some in between parameters do not have annotations.\n                // we pad with nulls.\n                while (parameters.length <= index) {\n                    parameters.push(null);\n                }\n                parameters[index] = parameters[index] || [];\n                var annotationsForParam = parameters[index];\n                annotationsForParam.push(annotationInstance);\n                Reflect.defineMetadata('parameters', parameters, cls);\n                return cls;\n            }\n            var _a;\n        }\n        if (parentClass) {\n            ParamDecoratorFactory.prototype = Object.create(parentClass.prototype);\n        }\n        ParamDecoratorFactory.prototype.toString = function () { return (\"@\" + name); };\n        ParamDecoratorFactory.annotationCls = ParamDecoratorFactory;\n        return ParamDecoratorFactory;\n    }\n    function makePropDecorator(name, props, parentClass) {\n        var metaCtor = makeMetadataCtor(props);\n        function PropDecoratorFactory() {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i - 0] = arguments[_i];\n            }\n            if (this instanceof PropDecoratorFactory) {\n                metaCtor.apply(this, args);\n                return this;\n            }\n            else {\n                var decoratorInstance = new ((_a = PropDecoratorFactory).bind.apply(_a, [void 0].concat(args)))();\n                return function PropDecorator(target, name) {\n                    var meta = Reflect.getOwnMetadata('propMetadata', target.constructor) || {};\n                    meta[name] = meta[name] || [];\n                    meta[name].unshift(decoratorInstance);\n                    Reflect.defineMetadata('propMetadata', meta, target.constructor);\n                };\n            }\n            var _a;\n        }\n        if (parentClass) {\n            PropDecoratorFactory.prototype = Object.create(parentClass.prototype);\n        }\n        PropDecoratorFactory.prototype.toString = function () { return (\"@\" + name); };\n        PropDecoratorFactory.annotationCls = PropDecoratorFactory;\n        return PropDecoratorFactory;\n    }\n\n    /**\n     * Inject decorator and metadata.\n     *\n     * @stable\n     * @Annotation\n     */\n    var Inject = makeParamDecorator('Inject', [['token', undefined]]);\n    /**\n     * Optional decorator and metadata.\n     *\n     * @stable\n     * @Annotation\n     */\n    var Optional = makeParamDecorator('Optional', []);\n    /**\n     * Injectable decorator and metadata.\n     *\n     * @stable\n     * @Annotation\n     */\n    var Injectable = makeParamDecorator('Injectable', []);\n    /**\n     * Self decorator and metadata.\n     *\n     * @stable\n     * @Annotation\n     */\n    var Self = makeParamDecorator('Self', []);\n    /**\n     * SkipSelf decorator and metadata.\n     *\n     * @stable\n     * @Annotation\n     */\n    var SkipSelf = makeParamDecorator('SkipSelf', []);\n    /**\n     * Host decorator and metadata.\n     *\n     * @stable\n     * @Annotation\n     */\n    var Host = makeParamDecorator('Host', []);\n\n    /**\n     * Creates a token that can be used in a DI Provider.\n     *\n     * ### Example ([live demo](http://plnkr.co/edit/Ys9ezXpj2Mnoy3Uc8KBp?p=preview))\n     *\n     * ```typescript\n     * var t = new OpaqueToken(\"value\");\n     *\n     * var injector = Injector.resolveAndCreate([\n     *   {provide: t, useValue: \"bindingValue\"}\n     * ]);\n     *\n     * expect(injector.get(t)).toEqual(\"bindingValue\");\n     * ```\n     *\n     * Using an `OpaqueToken` is preferable to using strings as tokens because of possible collisions\n     * caused by multiple providers using the same string as two different tokens.\n     *\n     * Using an `OpaqueToken` is preferable to using an `Object` as tokens because it provides better\n     * error messages.\n     * @stable\n     */\n    // so that metadata is gathered for this class\n    var OpaqueToken = (function () {\n        function OpaqueToken(_desc) {\n            this._desc = _desc;\n        }\n        OpaqueToken.prototype.toString = function () { return \"Token \" + this._desc; };\n        OpaqueToken.decorators = [\n            { type: Injectable },\n        ];\n        /** @nocollapse */\n        OpaqueToken.ctorParameters = [\n            null,\n        ];\n        return OpaqueToken;\n    }());\n\n    /**\n     * This token can be used to create a virtual provider that will populate the\n     * `entryComponents` fields of components and ng modules based on its `useValue`.\n     * All components that are referenced in the `useValue` value (either directly\n     * or in a nested array or map) will be added to the `entryComponents` property.\n     *\n     * ### Example\n     * The following example shows how the router can populate the `entryComponents`\n     * field of an NgModule based on the router configuration which refers\n     * to components.\n     *\n     * ```typescript\n     * // helper function inside the router\n     * function provideRoutes(routes) {\n     *   return [\n     *     {provide: ROUTES, useValue: routes},\n     *     {provide: ANALYZE_FOR_ENTRY_COMPONENTS, useValue: routes, multi: true}\n     *   ];\n     * }\n     *\n     * // user code\n     * let routes = [\n     *   {path: '/root', component: RootComp},\n     *   {path: '/teams', component: TeamsComp}\n     * ];\n     *\n     * @NgModule({\n     *   providers: [provideRoutes(routes)]\n     * })\n     * class ModuleWithRoutes {}\n     * ```\n     *\n     * @experimental\n     */\n    var ANALYZE_FOR_ENTRY_COMPONENTS = new OpaqueToken('AnalyzeForEntryComponents');\n    /**\n     * Attribute decorator and metadata.\n     *\n     * @stable\n     * @Annotation\n     */\n    var Attribute = makeParamDecorator('Attribute', [['attributeName', undefined]]);\n    /**\n     * Base class for query metadata.\n     *\n     * See {@link ContentChildren}, {@link ContentChild}, {@link ViewChildren}, {@link ViewChild} for\n     * more information.\n     *\n     * @stable\n     */\n    var Query = (function () {\n        function Query() {\n        }\n        return Query;\n    }());\n    /**\n     * ContentChildren decorator and metadata.\n     *\n     *  @stable\n     *  @Annotation\n     */\n    var ContentChildren = makePropDecorator('ContentChildren', [\n        ['selector', undefined], {\n            first: false,\n            isViewQuery: false,\n            descendants: false,\n            read: undefined,\n        }\n    ], Query);\n    /**\n     * @whatItDoes Configures a content query.\n     *\n     * @howToUse\n     *\n     * {@example core/di/ts/contentChild/content_child_howto.ts region='HowTo'}\n     *\n     * @description\n     *\n     * You can use ContentChild to get the first element or the directive matching the selector from the\n     * content DOM. If the content DOM changes, and a new child matches the selector,\n     * the property will be updated.\n     *\n     * Content queries are set before the `ngAfterContentInit` callback is called.\n     *\n     * **Metadata Properties**:\n     *\n     * * **selector** - the directive type or the name used for querying.\n     * * **read** - read a different token from the queried element.\n     *\n     * Let's look at an example:\n     *\n     * {@example core/di/ts/contentChild/content_child_example.ts region='Component'}\n     *\n     * **npm package**: `@angular/core`\n     *\n     * @stable\n     * @Annotation\n     */\n    var ContentChild = makePropDecorator('ContentChild', [\n        ['selector', undefined], {\n            first: true,\n            isViewQuery: false,\n            descendants: true,\n            read: undefined,\n        }\n    ], Query);\n    /**\n     * @whatItDoes Configures a view query.\n     *\n     * @howToUse\n     *\n     * {@example core/di/ts/viewChildren/view_children_howto.ts region='HowTo'}\n     *\n     * @description\n     *\n     * You can use ViewChildren to get the {@link QueryList} of elements or directives from the\n     * view DOM. Any time a child element is added, removed, or moved, the query list will be updated,\n     * and the changes observable of the query list will emit a new value.\n     *\n     * View queries are set before the `ngAfterViewInit` callback is called.\n     *\n     * **Metadata Properties**:\n     *\n     * * **selector** - the directive type or the name used for querying.\n     * * **read** - read a different token from the queried elements.\n     *\n     * Let's look at an example:\n     *\n     * {@example core/di/ts/viewChildren/view_children_example.ts region='Component'}\n     *\n     * **npm package**: `@angular/core`\n     *\n     * @stable\n     * @Annotation\n     */\n    var ViewChildren = makePropDecorator('ViewChildren', [\n        ['selector', undefined], {\n            first: false,\n            isViewQuery: true,\n            descendants: true,\n            read: undefined,\n        }\n    ], Query);\n    /**\n     * ViewChild decorator and metadata.\n     *\n     * @stable\n     * @Annotation\n     */\n    var ViewChild = makePropDecorator('ViewChild', [\n        ['selector', undefined], {\n            first: true,\n            isViewQuery: true,\n            descendants: true,\n            read: undefined,\n        }\n    ], Query);\n\n    /**\n     * Describes within the change detector which strategy will be used the next time change\n     * detection is triggered.\n     * @stable\n     */\n    exports.ChangeDetectionStrategy;\n    (function (ChangeDetectionStrategy) {\n        /**\n         * `OnPush` means that the change detector's mode will be set to `CheckOnce` during hydration.\n         */\n        ChangeDetectionStrategy[ChangeDetectionStrategy[\"OnPush\"] = 0] = \"OnPush\";\n        /**\n         * `Default` means that the change detector's mode will be set to `CheckAlways` during hydration.\n         */\n        ChangeDetectionStrategy[ChangeDetectionStrategy[\"Default\"] = 1] = \"Default\";\n    })(exports.ChangeDetectionStrategy || (exports.ChangeDetectionStrategy = {}));\n    /**\n     * Describes the status of the detector.\n     */\n    var ChangeDetectorStatus;\n    (function (ChangeDetectorStatus) {\n        /**\n         * `CheckedOnce` means that after calling detectChanges the mode of the change detector\n         * will become `Checked`.\n         */\n        ChangeDetectorStatus[ChangeDetectorStatus[\"CheckOnce\"] = 0] = \"CheckOnce\";\n        /**\n         * `Checked` means that the change detector should be skipped until its mode changes to\n         * `CheckOnce`.\n         */\n        ChangeDetectorStatus[ChangeDetectorStatus[\"Checked\"] = 1] = \"Checked\";\n        /**\n         * `CheckAlways` means that after calling detectChanges the mode of the change detector\n         * will remain `CheckAlways`.\n         */\n        ChangeDetectorStatus[ChangeDetectorStatus[\"CheckAlways\"] = 2] = \"CheckAlways\";\n        /**\n         * `Detached` means that the change detector sub tree is not a part of the main tree and\n         * should be skipped.\n         */\n        ChangeDetectorStatus[ChangeDetectorStatus[\"Detached\"] = 3] = \"Detached\";\n        /**\n         * `Errored` means that the change detector encountered an error checking a binding\n         * or calling a directive lifecycle method and is now in an inconsistent state. Change\n         * detectors in this state will no longer detect changes.\n         */\n        ChangeDetectorStatus[ChangeDetectorStatus[\"Errored\"] = 4] = \"Errored\";\n        /**\n         * `Destroyed` means that the change detector is destroyed.\n         */\n        ChangeDetectorStatus[ChangeDetectorStatus[\"Destroyed\"] = 5] = \"Destroyed\";\n    })(ChangeDetectorStatus || (ChangeDetectorStatus = {}));\n    /**\n     * List of possible {@link ChangeDetectionStrategy} values.\n     */\n    var CHANGE_DETECTION_STRATEGY_VALUES = [\n        exports.ChangeDetectionStrategy.OnPush,\n        exports.ChangeDetectionStrategy.Default,\n    ];\n    function isDefaultChangeDetectionStrategy(changeDetectionStrategy) {\n        return isBlank(changeDetectionStrategy) ||\n            changeDetectionStrategy === exports.ChangeDetectionStrategy.Default;\n    }\n\n    /**\n     * Directive decorator and metadata.\n     *\n     * @stable\n     * @Annotation\n     */\n    var Directive = makeDecorator('Directive', {\n        selector: undefined,\n        inputs: undefined,\n        outputs: undefined,\n        host: undefined,\n        providers: undefined,\n        exportAs: undefined,\n        queries: undefined\n    });\n    /**\n     * Component decorator and metadata.\n     *\n     * @stable\n     * @Annotation\n     */\n    var Component = makeDecorator('Component', {\n        selector: undefined,\n        inputs: undefined,\n        outputs: undefined,\n        host: undefined,\n        exportAs: undefined,\n        moduleId: undefined,\n        providers: undefined,\n        viewProviders: undefined,\n        changeDetection: exports.ChangeDetectionStrategy.Default,\n        queries: undefined,\n        templateUrl: undefined,\n        template: undefined,\n        styleUrls: undefined,\n        styles: undefined,\n        animations: undefined,\n        encapsulation: undefined,\n        interpolation: undefined,\n        entryComponents: undefined\n    }, Directive);\n    /**\n     * Pipe decorator and metadata.\n     *\n     * @stable\n     * @Annotation\n     */\n    var Pipe = makeDecorator('Pipe', {\n        name: undefined,\n        pure: true,\n    });\n    /**\n     * Input decorator and metadata.\n     *\n     * @stable\n     * @Annotation\n     */\n    var Input = makePropDecorator('Input', [['bindingPropertyName', undefined]]);\n    /**\n     * Output decorator and metadata.\n     *\n     * @stable\n     * @Annotation\n     */\n    var Output = makePropDecorator('Output', [['bindingPropertyName', undefined]]);\n    /**\n     * HostBinding decorator and metadata.\n     *\n     * @stable\n     * @Annotation\n     */\n    var HostBinding = makePropDecorator('HostBinding', [['hostPropertyName', undefined]]);\n    /**\n     * HostBinding decorator and metadata.\n     *\n     * @stable\n     * @Annotation\n     */\n    var HostListener = makePropDecorator('HostListener', [['eventName', undefined], ['args', []]]);\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * @stable\n     */\n    var LifecycleHooks;\n    (function (LifecycleHooks) {\n        LifecycleHooks[LifecycleHooks[\"OnInit\"] = 0] = \"OnInit\";\n        LifecycleHooks[LifecycleHooks[\"OnDestroy\"] = 1] = \"OnDestroy\";\n        LifecycleHooks[LifecycleHooks[\"DoCheck\"] = 2] = \"DoCheck\";\n        LifecycleHooks[LifecycleHooks[\"OnChanges\"] = 3] = \"OnChanges\";\n        LifecycleHooks[LifecycleHooks[\"AfterContentInit\"] = 4] = \"AfterContentInit\";\n        LifecycleHooks[LifecycleHooks[\"AfterContentChecked\"] = 5] = \"AfterContentChecked\";\n        LifecycleHooks[LifecycleHooks[\"AfterViewInit\"] = 6] = \"AfterViewInit\";\n        LifecycleHooks[LifecycleHooks[\"AfterViewChecked\"] = 7] = \"AfterViewChecked\";\n    })(LifecycleHooks || (LifecycleHooks = {}));\n    var LIFECYCLE_HOOKS_VALUES = [\n        LifecycleHooks.OnInit, LifecycleHooks.OnDestroy, LifecycleHooks.DoCheck, LifecycleHooks.OnChanges,\n        LifecycleHooks.AfterContentInit, LifecycleHooks.AfterContentChecked, LifecycleHooks.AfterViewInit,\n        LifecycleHooks.AfterViewChecked\n    ];\n    /**\n     * @whatItDoes Lifecycle hook that is called when any data-bound property of a directive changes.\n     * @howToUse\n     * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='OnChanges'}\n     *\n     * @description\n     * `ngOnChanges` is called right after the data-bound properties have been checked and before view\n     * and content children are checked if at least one of them has changed.\n     * The `changes` parameter contains the changed properties.\n     *\n     * See {@linkDocs guide/lifecycle-hooks#onchanges \"Lifecycle Hooks Guide\"}.\n     *\n     * @stable\n     */\n    var OnChanges = (function () {\n        function OnChanges() {\n        }\n        return OnChanges;\n    }());\n    /**\n     * @whatItDoes Lifecycle hook that is called after data-bound properties of a directive are\n     * initialized.\n     * @howToUse\n     * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='OnInit'}\n     *\n     * @description\n     * `ngOnInit` is called right after the directive's data-bound properties have been checked for the\n     * first time, and before any of its children have been checked. It is invoked only once when the\n     * directive is instantiated.\n     *\n     * See {@linkDocs guide/lifecycle-hooks \"Lifecycle Hooks Guide\"}.\n     *\n     * @stable\n     */\n    var OnInit = (function () {\n        function OnInit() {\n        }\n        return OnInit;\n    }());\n    /**\n     * @whatItDoes Lifecycle hook that is called when Angular dirty checks a directive.\n     * @howToUse\n     * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='DoCheck'}\n     *\n     * @description\n     * `ngDoCheck` gets called to check the changes in the directives in addition to the default\n     * algorithm. The default change detection algorithm looks for differences by comparing\n     * bound-property values by reference across change detection runs.\n     *\n     * Note that a directive typically should not use both `DoCheck` and {@link OnChanges} to respond to\n     * changes on the same input, as `ngOnChanges` will continue to be called when the default change\n     * detector detects changes.\n     *\n     * See {@link KeyValueDiffers} and {@link IterableDiffers} for implementing custom dirty checking\n     * for collections.\n     *\n     * See {@linkDocs guide/lifecycle-hooks#docheck \"Lifecycle Hooks Guide\"}.\n     *\n     * @stable\n     */\n    var DoCheck = (function () {\n        function DoCheck() {\n        }\n        return DoCheck;\n    }());\n    /**\n     * @whatItDoes Lifecycle hook that is called when a directive or pipe is destroyed.\n     * @howToUse\n     * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='OnDestroy'}\n     *\n     * @description\n     * `ngOnDestroy` callback is typically used for any custom cleanup that needs to occur when the\n     * instance is destroyed.\n     *\n     * See {@linkDocs guide/lifecycle-hooks \"Lifecycle Hooks Guide\"}.\n     *\n     * @stable\n     */\n    var OnDestroy = (function () {\n        function OnDestroy() {\n        }\n        return OnDestroy;\n    }());\n    /**\n     *\n     * @whatItDoes Lifecycle hook that is called after a directive's content has been fully\n     * initialized.\n     * @howToUse\n     * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='AfterContentInit'}\n     *\n     * @description\n     * See {@linkDocs guide/lifecycle-hooks#aftercontent \"Lifecycle Hooks Guide\"}.\n     *\n     * @stable\n     */\n    var AfterContentInit = (function () {\n        function AfterContentInit() {\n        }\n        return AfterContentInit;\n    }());\n    /**\n     * @whatItDoes Lifecycle hook that is called after every check of a directive's content.\n     * @howToUse\n     * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='AfterContentChecked'}\n     *\n     * @description\n     * See {@linkDocs guide/lifecycle-hooks#aftercontent \"Lifecycle Hooks Guide\"}.\n     *\n     * @stable\n     */\n    var AfterContentChecked = (function () {\n        function AfterContentChecked() {\n        }\n        return AfterContentChecked;\n    }());\n    /**\n     * @whatItDoes Lifecycle hook that is called after a component's view has been fully\n     * initialized.\n     * @howToUse\n     * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='AfterViewInit'}\n     *\n     * @description\n     * See {@linkDocs guide/lifecycle-hooks#afterview \"Lifecycle Hooks Guide\"}.\n     *\n     * @stable\n     */\n    var AfterViewInit = (function () {\n        function AfterViewInit() {\n        }\n        return AfterViewInit;\n    }());\n    /**\n     * @whatItDoes Lifecycle hook that is called after every check of a component's view.\n     * @howToUse\n     * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='AfterViewChecked'}\n     *\n     * @description\n     * See {@linkDocs guide/lifecycle-hooks#afterview \"Lifecycle Hooks Guide\"}.\n     *\n     * @stable\n     */\n    var AfterViewChecked = (function () {\n        function AfterViewChecked() {\n        }\n        return AfterViewChecked;\n    }());\n\n    /**\n     * Defines a schema that will allow:\n     * - any non-angular elements with a `-` in their name,\n     * - any properties on elements with a `-` in their name which is the common rule for custom\n     * elements.\n     *\n     * @stable\n     */\n    var CUSTOM_ELEMENTS_SCHEMA = {\n        name: 'custom-elements'\n    };\n    /**\n     * Defines a schema that will allow any property on any element.\n     *\n     * @experimental\n     */\n    var NO_ERRORS_SCHEMA = {\n        name: 'no-errors-schema'\n    };\n    /**\n     * NgModule decorator and metadata\n     *\n     * @stable\n     * @Annotation\n     */\n    var NgModule = makeDecorator('NgModule', {\n        providers: undefined,\n        declarations: undefined,\n        imports: undefined,\n        exports: undefined,\n        entryComponents: undefined,\n        bootstrap: undefined,\n        schemas: undefined,\n        id: undefined,\n    });\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * Defines template and style encapsulation options available for Component's {@link Component}.\n     *\n     * See {@link ViewMetadata#encapsulation}.\n     * @stable\n     */\n    exports.ViewEncapsulation;\n    (function (ViewEncapsulation) {\n        /**\n         * Emulate `Native` scoping of styles by adding an attribute containing surrogate id to the Host\n         * Element and pre-processing the style rules provided via\n         * {@link ViewMetadata#styles} or {@link ViewMetadata#stylesUrls}, and adding the new Host Element\n         * attribute to all selectors.\n         *\n         * This is the default option.\n         */\n        ViewEncapsulation[ViewEncapsulation[\"Emulated\"] = 0] = \"Emulated\";\n        /**\n         * Use the native encapsulation mechanism of the renderer.\n         *\n         * For the DOM this means using [Shadow DOM](https://w3c.github.io/webcomponents/spec/shadow/) and\n         * creating a ShadowRoot for Component's Host Element.\n         */\n        ViewEncapsulation[ViewEncapsulation[\"Native\"] = 1] = \"Native\";\n        /**\n         * Don't provide any template or style encapsulation.\n         */\n        ViewEncapsulation[ViewEncapsulation[\"None\"] = 2] = \"None\";\n    })(exports.ViewEncapsulation || (exports.ViewEncapsulation = {}));\n    var VIEW_ENCAPSULATION_VALUES = [exports.ViewEncapsulation.Emulated, exports.ViewEncapsulation.Native, exports.ViewEncapsulation.None];\n    /**\n     * Metadata properties available for configuring Views.\n     *\n     * For details on the `@Component` annotation, see {@link Component}.\n     *\n     * ### Example\n     *\n     * ```\n     * @Component({\n     *   selector: 'greet',\n     *   template: 'Hello {{name}}!',\n     * })\n     * class Greet {\n     *   name: string;\n     *\n     *   constructor() {\n     *     this.name = 'World';\n     *   }\n     * }\n     * ```\n     *\n     * @deprecated Use Component instead.\n     *\n     * {@link Component}\n     */\n    var ViewMetadata = (function () {\n        function ViewMetadata(_a) {\n            var _b = _a === void 0 ? {} : _a, templateUrl = _b.templateUrl, template = _b.template, encapsulation = _b.encapsulation, styles = _b.styles, styleUrls = _b.styleUrls, animations = _b.animations, interpolation = _b.interpolation;\n            this.templateUrl = templateUrl;\n            this.template = template;\n            this.styleUrls = styleUrls;\n            this.styles = styles;\n            this.encapsulation = encapsulation;\n            this.animations = animations;\n            this.interpolation = interpolation;\n        }\n        return ViewMetadata;\n    }());\n\n    /**\n     * Allows to refer to references which are not yet defined.\n     *\n     * For instance, `forwardRef` is used when the `token` which we need to refer to for the purposes of\n     * DI is declared,\n     * but not yet defined. It is also used when the `token` which we use when creating a query is not\n     * yet defined.\n     *\n     * ### Example\n     * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='forward_ref'}\n     * @experimental\n     */\n    function forwardRef(forwardRefFn) {\n        forwardRefFn.__forward_ref__ = forwardRef;\n        forwardRefFn.toString = function () { return stringify(this()); };\n        return forwardRefFn;\n    }\n    /**\n     * Lazily retrieves the reference value from a forwardRef.\n     *\n     * Acts as the identity function when given a non-forward-ref value.\n     *\n     * ### Example ([live demo](http://plnkr.co/edit/GU72mJrk1fiodChcmiDR?p=preview))\n     *\n     * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='resolve_forward_ref'}\n     *\n     * See: {@link forwardRef}\n     * @experimental\n     */\n    function resolveForwardRef(type) {\n        if (isFunction(type) && type.hasOwnProperty('__forward_ref__') &&\n            type.__forward_ref__ === forwardRef) {\n            return type();\n        }\n        else {\n            return type;\n        }\n    }\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    function unimplemented() {\n        throw new Error('unimplemented');\n    }\n    /**\n     * @stable\n     */\n    var BaseError = (function (_super) {\n        __extends(BaseError, _super);\n        function BaseError(message) {\n            // Errors don't use current this, instead they create a new instance.\n            // We have to do forward all of our api to the nativeInstance.\n            var nativeError = _super.call(this, message);\n            this._nativeError = nativeError;\n        }\n        Object.defineProperty(BaseError.prototype, \"message\", {\n            get: function () { return this._nativeError.message; },\n            set: function (message) { this._nativeError.message = message; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(BaseError.prototype, \"name\", {\n            get: function () { return this._nativeError.name; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(BaseError.prototype, \"stack\", {\n            get: function () { return this._nativeError.stack; },\n            set: function (value) { this._nativeError.stack = value; },\n            enumerable: true,\n            configurable: true\n        });\n        BaseError.prototype.toString = function () { return this._nativeError.toString(); };\n        return BaseError;\n    }(Error));\n    /**\n     * @stable\n     */\n    var WrappedError = (function (_super) {\n        __extends(WrappedError, _super);\n        function WrappedError(message, error) {\n            _super.call(this, message + \" caused by: \" + (error instanceof Error ? error.message : error));\n            this.originalError = error;\n        }\n        Object.defineProperty(WrappedError.prototype, \"stack\", {\n            get: function () {\n                return (this.originalError instanceof Error ? this.originalError : this._nativeError)\n                    .stack;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        return WrappedError;\n    }(BaseError));\n\n    var _THROW_IF_NOT_FOUND = new Object();\n    var THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;\n    var _NullInjector = (function () {\n        function _NullInjector() {\n        }\n        _NullInjector.prototype.get = function (token, notFoundValue) {\n            if (notFoundValue === void 0) { notFoundValue = _THROW_IF_NOT_FOUND; }\n            if (notFoundValue === _THROW_IF_NOT_FOUND) {\n                throw new Error(\"No provider for \" + stringify(token) + \"!\");\n            }\n            return notFoundValue;\n        };\n        return _NullInjector;\n    }());\n    /**\n     * @whatItDoes Injector interface\n     * @howToUse\n     * ```\n     * const injector: Injector = ...;\n     * injector.get(...);\n     * ```\n     *\n     * @description\n     * For more details, see the {@linkDocs guide/dependency-injection \"Dependency Injection Guide\"}.\n     *\n     * ### Example\n     *\n     * {@example core/di/ts/injector_spec.ts region='Injector'}\n     *\n     * `Injector` returns itself when given `Injector` as a token:\n     * {@example core/di/ts/injector_spec.ts region='injectInjector'}\n     *\n     * @stable\n     */\n    var Injector = (function () {\n        function Injector() {\n        }\n        /**\n         * Retrieves an instance from the injector based on the provided token.\n         * If not found:\n         * - Throws {@link NoProviderError} if no `notFoundValue` that is not equal to\n         * Injector.THROW_IF_NOT_FOUND is given\n         * - Returns the `notFoundValue` otherwise\n         */\n        Injector.prototype.get = function (token, notFoundValue) { return unimplemented(); };\n        Injector.THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;\n        Injector.NULL = new _NullInjector();\n        return Injector;\n    }());\n\n    // Safari and Internet Explorer do not support the iterable parameter to the\n    // Map constructor.  We work around that by manually adding the items.\n    var createMapFromPairs = (function () {\n        try {\n            if (new Map([[1, 2]]).size === 1) {\n                return function createMapFromPairs(pairs) { return new Map(pairs); };\n            }\n        }\n        catch (e) {\n        }\n        return function createMapAndPopulateFromPairs(pairs) {\n            var map = new Map();\n            for (var i = 0; i < pairs.length; i++) {\n                var pair = pairs[i];\n                map.set(pair[0], pair[1]);\n            }\n            return map;\n        };\n    })();\n    var _clearValues = (function () {\n        if ((new Map()).keys().next) {\n            return function _clearValues(m) {\n                var keyIterator = m.keys();\n                var k;\n                while (!((k = keyIterator.next()).done)) {\n                    m.set(k.value, null);\n                }\n            };\n        }\n        else {\n            return function _clearValuesWithForeEach(m) {\n                m.forEach(function (v, k) { m.set(k, null); });\n            };\n        }\n    })();\n    // Safari doesn't implement MapIterator.next(), which is used is Traceur's polyfill of Array.from\n    // TODO(mlaval): remove the work around once we have a working polyfill of Array.from\n    var _arrayFromMap = (function () {\n        try {\n            if ((new Map()).values().next) {\n                return function createArrayFromMap(m, getValues) {\n                    return getValues ? Array.from(m.values()) : Array.from(m.keys());\n                };\n            }\n        }\n        catch (e) {\n        }\n        return function createArrayFromMapWithForeach(m, getValues) {\n            var res = new Array(m.size), i = 0;\n            m.forEach(function (v, k) {\n                res[i] = getValues ? v : k;\n                i++;\n            });\n            return res;\n        };\n    })();\n    var MapWrapper = (function () {\n        function MapWrapper() {\n        }\n        MapWrapper.createFromStringMap = function (stringMap) {\n            var result = new Map();\n            for (var prop in stringMap) {\n                result.set(prop, stringMap[prop]);\n            }\n            return result;\n        };\n        MapWrapper.toStringMap = function (m) {\n            var r = {};\n            m.forEach(function (v, k) { return r[k] = v; });\n            return r;\n        };\n        MapWrapper.createFromPairs = function (pairs) { return createMapFromPairs(pairs); };\n        MapWrapper.iterable = function (m) { return m; };\n        MapWrapper.keys = function (m) { return _arrayFromMap(m, false); };\n        MapWrapper.values = function (m) { return _arrayFromMap(m, true); };\n        return MapWrapper;\n    }());\n    /**\n     * Wraps Javascript Objects\n     */\n    var StringMapWrapper = (function () {\n        function StringMapWrapper() {\n        }\n        StringMapWrapper.get = function (map, key) {\n            return map.hasOwnProperty(key) ? map[key] : undefined;\n        };\n        StringMapWrapper.set = function (map, key, value) { map[key] = value; };\n        StringMapWrapper.keys = function (map) { return Object.keys(map); };\n        StringMapWrapper.values = function (map) {\n            return Object.keys(map).map(function (k) { return map[k]; });\n        };\n        StringMapWrapper.isEmpty = function (map) {\n            for (var prop in map) {\n                return false;\n            }\n            return true;\n        };\n        StringMapWrapper.forEach = function (map, callback) {\n            for (var _i = 0, _a = Object.keys(map); _i < _a.length; _i++) {\n                var k = _a[_i];\n                callback(map[k], k);\n            }\n        };\n        StringMapWrapper.merge = function (m1, m2) {\n            var m = {};\n            for (var _i = 0, _a = Object.keys(m1); _i < _a.length; _i++) {\n                var k = _a[_i];\n                m[k] = m1[k];\n            }\n            for (var _b = 0, _c = Object.keys(m2); _b < _c.length; _b++) {\n                var k = _c[_b];\n                m[k] = m2[k];\n            }\n            return m;\n        };\n        StringMapWrapper.equals = function (m1, m2) {\n            var k1 = Object.keys(m1);\n            var k2 = Object.keys(m2);\n            if (k1.length != k2.length) {\n                return false;\n            }\n            for (var i = 0; i < k1.length; i++) {\n                var key = k1[i];\n                if (m1[key] !== m2[key]) {\n                    return false;\n                }\n            }\n            return true;\n        };\n        return StringMapWrapper;\n    }());\n    var ListWrapper = (function () {\n        function ListWrapper() {\n        }\n        // JS has no way to express a statically fixed size list, but dart does so we\n        // keep both methods.\n        ListWrapper.createFixedSize = function (size) { return new Array(size); };\n        ListWrapper.createGrowableSize = function (size) { return new Array(size); };\n        ListWrapper.clone = function (array) { return array.slice(0); };\n        ListWrapper.forEachWithIndex = function (array, fn) {\n            for (var i = 0; i < array.length; i++) {\n                fn(array[i], i);\n            }\n        };\n        ListWrapper.first = function (array) {\n            if (!array)\n                return null;\n            return array[0];\n        };\n        ListWrapper.last = function (array) {\n            if (!array || array.length == 0)\n                return null;\n            return array[array.length - 1];\n        };\n        ListWrapper.indexOf = function (array, value, startIndex) {\n            if (startIndex === void 0) { startIndex = 0; }\n            return array.indexOf(value, startIndex);\n        };\n        ListWrapper.contains = function (list, el) { return list.indexOf(el) !== -1; };\n        ListWrapper.reversed = function (array) {\n            var a = ListWrapper.clone(array);\n            return a.reverse();\n        };\n        ListWrapper.concat = function (a, b) { return a.concat(b); };\n        ListWrapper.insert = function (list, index, value) { list.splice(index, 0, value); };\n        ListWrapper.removeAt = function (list, index) {\n            var res = list[index];\n            list.splice(index, 1);\n            return res;\n        };\n        ListWrapper.removeAll = function (list, items) {\n            for (var i = 0; i < items.length; ++i) {\n                var index = list.indexOf(items[i]);\n                list.splice(index, 1);\n            }\n        };\n        ListWrapper.remove = function (list, el) {\n            var index = list.indexOf(el);\n            if (index > -1) {\n                list.splice(index, 1);\n                return true;\n            }\n            return false;\n        };\n        ListWrapper.clear = function (list) { list.length = 0; };\n        ListWrapper.isEmpty = function (list) { return list.length == 0; };\n        ListWrapper.fill = function (list, value, start, end) {\n            if (start === void 0) { start = 0; }\n            if (end === void 0) { end = null; }\n            list.fill(value, start, end === null ? list.length : end);\n        };\n        ListWrapper.equals = function (a, b) {\n            if (a.length != b.length)\n                return false;\n            for (var i = 0; i < a.length; ++i) {\n                if (a[i] !== b[i])\n                    return false;\n            }\n            return true;\n        };\n        ListWrapper.slice = function (l, from, to) {\n            if (from === void 0) { from = 0; }\n            if (to === void 0) { to = null; }\n            return l.slice(from, to === null ? undefined : to);\n        };\n        ListWrapper.splice = function (l, from, length) { return l.splice(from, length); };\n        ListWrapper.sort = function (l, compareFn) {\n            if (isPresent(compareFn)) {\n                l.sort(compareFn);\n            }\n            else {\n                l.sort();\n            }\n        };\n        ListWrapper.toString = function (l) { return l.toString(); };\n        ListWrapper.toJSON = function (l) { return JSON.stringify(l); };\n        ListWrapper.maximum = function (list, predicate) {\n            if (list.length == 0) {\n                return null;\n            }\n            var solution = null;\n            var maxValue = -Infinity;\n            for (var index = 0; index < list.length; index++) {\n                var candidate = list[index];\n                if (isBlank(candidate)) {\n                    continue;\n                }\n                var candidateValue = predicate(candidate);\n                if (candidateValue > maxValue) {\n                    solution = candidate;\n                    maxValue = candidateValue;\n                }\n            }\n            return solution;\n        };\n        ListWrapper.flatten = function (list) {\n            var target = [];\n            _flattenArray(list, target);\n            return target;\n        };\n        ListWrapper.addAll = function (list, source) {\n            for (var i = 0; i < source.length; i++) {\n                list.push(source[i]);\n            }\n        };\n        return ListWrapper;\n    }());\n    function _flattenArray(source, target) {\n        if (isPresent(source)) {\n            for (var i = 0; i < source.length; i++) {\n                var item = source[i];\n                if (isArray(item)) {\n                    _flattenArray(item, target);\n                }\n                else {\n                    target.push(item);\n                }\n            }\n        }\n        return target;\n    }\n    function isListLikeIterable(obj) {\n        if (!isJsObject(obj))\n            return false;\n        return isArray(obj) ||\n            (!(obj instanceof Map) &&\n                getSymbolIterator() in obj); // JS Iterable have a Symbol.iterator prop\n    }\n    function areIterablesEqual(a, b, comparator) {\n        var iterator1 = a[getSymbolIterator()]();\n        var iterator2 = b[getSymbolIterator()]();\n        while (true) {\n            var item1 = iterator1.next();\n            var item2 = iterator2.next();\n            if (item1.done && item2.done)\n                return true;\n            if (item1.done || item2.done)\n                return false;\n            if (!comparator(item1.value, item2.value))\n                return false;\n        }\n    }\n    function iterateListLike(obj, fn) {\n        if (isArray(obj)) {\n            for (var i = 0; i < obj.length; i++) {\n                fn(obj[i]);\n            }\n        }\n        else {\n            var iterator = obj[getSymbolIterator()]();\n            var item;\n            while (!((item = iterator.next()).done)) {\n                fn(item.value);\n            }\n        }\n    }\n    // Safari and Internet Explorer do not support the iterable parameter to the\n    // Set constructor.  We work around that by manually adding the items.\n    var createSetFromList = (function () {\n        var test = new Set([1, 2, 3]);\n        if (test.size === 3) {\n            return function createSetFromList(lst) { return new Set(lst); };\n        }\n        else {\n            return function createSetAndPopulateFromList(lst) {\n                var res = new Set(lst);\n                if (res.size !== lst.length) {\n                    for (var i = 0; i < lst.length; i++) {\n                        res.add(lst[i]);\n                    }\n                }\n                return res;\n            };\n        }\n    })();\n    var SetWrapper = (function () {\n        function SetWrapper() {\n        }\n        SetWrapper.createFromList = function (lst) { return createSetFromList(lst); };\n        SetWrapper.has = function (s, key) { return s.has(key); };\n        SetWrapper.delete = function (m, k) { m.delete(k); };\n        return SetWrapper;\n    }());\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$1 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    function findFirstClosedCycle(keys) {\n        var res = [];\n        for (var i = 0; i < keys.length; ++i) {\n            if (ListWrapper.contains(res, keys[i])) {\n                res.push(keys[i]);\n                return res;\n            }\n            res.push(keys[i]);\n        }\n        return res;\n    }\n    function constructResolvingPath(keys) {\n        if (keys.length > 1) {\n            var reversed = findFirstClosedCycle(ListWrapper.reversed(keys));\n            var tokenStrs = reversed.map(function (k) { return stringify(k.token); });\n            return ' (' + tokenStrs.join(' -> ') + ')';\n        }\n        return '';\n    }\n    /**\n     * Base class for all errors arising from misconfigured providers.\n     * @stable\n     */\n    var AbstractProviderError = (function (_super) {\n        __extends$1(AbstractProviderError, _super);\n        function AbstractProviderError(injector, key, constructResolvingMessage) {\n            _super.call(this, 'DI Error');\n            this.keys = [key];\n            this.injectors = [injector];\n            this.constructResolvingMessage = constructResolvingMessage;\n            this.message = this.constructResolvingMessage(this.keys);\n        }\n        AbstractProviderError.prototype.addKey = function (injector, key) {\n            this.injectors.push(injector);\n            this.keys.push(key);\n            this.message = this.constructResolvingMessage(this.keys);\n        };\n        return AbstractProviderError;\n    }(BaseError));\n    /**\n     * Thrown when trying to retrieve a dependency by key from {@link Injector}, but the\n     * {@link Injector} does not have a {@link Provider} for the given key.\n     *\n     * ### Example ([live demo](http://plnkr.co/edit/vq8D3FRB9aGbnWJqtEPE?p=preview))\n     *\n     * ```typescript\n     * class A {\n     *   constructor(b:B) {}\n     * }\n     *\n     * expect(() => Injector.resolveAndCreate([A])).toThrowError();\n     * ```\n     * @stable\n     */\n    var NoProviderError = (function (_super) {\n        __extends$1(NoProviderError, _super);\n        function NoProviderError(injector, key) {\n            _super.call(this, injector, key, function (keys) {\n                var first = stringify(ListWrapper.first(keys).token);\n                return \"No provider for \" + first + \"!\" + constructResolvingPath(keys);\n            });\n        }\n        return NoProviderError;\n    }(AbstractProviderError));\n    /**\n     * Thrown when dependencies form a cycle.\n     *\n     * ### Example ([live demo](http://plnkr.co/edit/wYQdNos0Tzql3ei1EV9j?p=info))\n     *\n     * ```typescript\n     * var injector = Injector.resolveAndCreate([\n     *   {provide: \"one\", useFactory: (two) => \"two\", deps: [[new Inject(\"two\")]]},\n     *   {provide: \"two\", useFactory: (one) => \"one\", deps: [[new Inject(\"one\")]]}\n     * ]);\n     *\n     * expect(() => injector.get(\"one\")).toThrowError();\n     * ```\n     *\n     * Retrieving `A` or `B` throws a `CyclicDependencyError` as the graph above cannot be constructed.\n     * @stable\n     */\n    var CyclicDependencyError = (function (_super) {\n        __extends$1(CyclicDependencyError, _super);\n        function CyclicDependencyError(injector, key) {\n            _super.call(this, injector, key, function (keys) {\n                return \"Cannot instantiate cyclic dependency!\" + constructResolvingPath(keys);\n            });\n        }\n        return CyclicDependencyError;\n    }(AbstractProviderError));\n    /**\n     * Thrown when a constructing type returns with an Error.\n     *\n     * The `InstantiationError` class contains the original error plus the dependency graph which caused\n     * this object to be instantiated.\n     *\n     * ### Example ([live demo](http://plnkr.co/edit/7aWYdcqTQsP0eNqEdUAf?p=preview))\n     *\n     * ```typescript\n     * class A {\n     *   constructor() {\n     *     throw new Error('message');\n     *   }\n     * }\n     *\n     * var injector = Injector.resolveAndCreate([A]);\n\n     * try {\n     *   injector.get(A);\n     * } catch (e) {\n     *   expect(e instanceof InstantiationError).toBe(true);\n     *   expect(e.originalException.message).toEqual(\"message\");\n     *   expect(e.originalStack).toBeDefined();\n     * }\n     * ```\n     * @stable\n     */\n    var InstantiationError = (function (_super) {\n        __extends$1(InstantiationError, _super);\n        function InstantiationError(injector, originalException, originalStack, key) {\n            _super.call(this, 'DI Error', originalException);\n            this.keys = [key];\n            this.injectors = [injector];\n        }\n        InstantiationError.prototype.addKey = function (injector, key) {\n            this.injectors.push(injector);\n            this.keys.push(key);\n        };\n        Object.defineProperty(InstantiationError.prototype, \"message\", {\n            get: function () {\n                var first = stringify(ListWrapper.first(this.keys).token);\n                return this.originalError.message + \": Error during instantiation of \" + first + \"!\" + constructResolvingPath(this.keys) + \".\";\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(InstantiationError.prototype, \"causeKey\", {\n            get: function () { return this.keys[0]; },\n            enumerable: true,\n            configurable: true\n        });\n        return InstantiationError;\n    }(WrappedError));\n    /**\n     * Thrown when an object other then {@link Provider} (or `Type`) is passed to {@link Injector}\n     * creation.\n     *\n     * ### Example ([live demo](http://plnkr.co/edit/YatCFbPAMCL0JSSQ4mvH?p=preview))\n     *\n     * ```typescript\n     * expect(() => Injector.resolveAndCreate([\"not a type\"])).toThrowError();\n     * ```\n     * @stable\n     */\n    var InvalidProviderError = (function (_super) {\n        __extends$1(InvalidProviderError, _super);\n        function InvalidProviderError(provider) {\n            _super.call(this, \"Invalid provider - only instances of Provider and Type are allowed, got: \" + provider);\n        }\n        return InvalidProviderError;\n    }(BaseError));\n    /**\n     * Thrown when the class has no annotation information.\n     *\n     * Lack of annotation information prevents the {@link Injector} from determining which dependencies\n     * need to be injected into the constructor.\n     *\n     * ### Example ([live demo](http://plnkr.co/edit/rHnZtlNS7vJOPQ6pcVkm?p=preview))\n     *\n     * ```typescript\n     * class A {\n     *   constructor(b) {}\n     * }\n     *\n     * expect(() => Injector.resolveAndCreate([A])).toThrowError();\n     * ```\n     *\n     * This error is also thrown when the class not marked with {@link Injectable} has parameter types.\n     *\n     * ```typescript\n     * class B {}\n     *\n     * class A {\n     *   constructor(b:B) {} // no information about the parameter types of A is available at runtime.\n     * }\n     *\n     * expect(() => Injector.resolveAndCreate([A,B])).toThrowError();\n     * ```\n     * @stable\n     */\n    var NoAnnotationError = (function (_super) {\n        __extends$1(NoAnnotationError, _super);\n        function NoAnnotationError(typeOrFunc, params) {\n            _super.call(this, NoAnnotationError._genMessage(typeOrFunc, params));\n        }\n        NoAnnotationError._genMessage = function (typeOrFunc, params) {\n            var signature = [];\n            for (var i = 0, ii = params.length; i < ii; i++) {\n                var parameter = params[i];\n                if (isBlank(parameter) || parameter.length == 0) {\n                    signature.push('?');\n                }\n                else {\n                    signature.push(parameter.map(stringify).join(' '));\n                }\n            }\n            return 'Cannot resolve all parameters for \\'' + stringify(typeOrFunc) + '\\'(' +\n                signature.join(', ') + '). ' +\n                'Make sure that all the parameters are decorated with Inject or have valid type annotations and that \\'' +\n                stringify(typeOrFunc) + '\\' is decorated with Injectable.';\n        };\n        return NoAnnotationError;\n    }(BaseError));\n    /**\n     * Thrown when getting an object by index.\n     *\n     * ### Example ([live demo](http://plnkr.co/edit/bRs0SX2OTQiJzqvjgl8P?p=preview))\n     *\n     * ```typescript\n     * class A {}\n     *\n     * var injector = Injector.resolveAndCreate([A]);\n     *\n     * expect(() => injector.getAt(100)).toThrowError();\n     * ```\n     * @stable\n     */\n    var OutOfBoundsError = (function (_super) {\n        __extends$1(OutOfBoundsError, _super);\n        function OutOfBoundsError(index) {\n            _super.call(this, \"Index \" + index + \" is out-of-bounds.\");\n        }\n        return OutOfBoundsError;\n    }(BaseError));\n    // TODO: add a working example after alpha38 is released\n    /**\n     * Thrown when a multi provider and a regular provider are bound to the same token.\n     *\n     * ### Example\n     *\n     * ```typescript\n     * expect(() => Injector.resolveAndCreate([\n     *   { provide: \"Strings\", useValue: \"string1\", multi: true},\n     *   { provide: \"Strings\", useValue: \"string2\", multi: false}\n     * ])).toThrowError();\n     * ```\n     */\n    var MixingMultiProvidersWithRegularProvidersError = (function (_super) {\n        __extends$1(MixingMultiProvidersWithRegularProvidersError, _super);\n        function MixingMultiProvidersWithRegularProvidersError(provider1, provider2) {\n            _super.call(this, 'Cannot mix multi providers and regular providers, got: ' + provider1.toString() + ' ' +\n                provider2.toString());\n        }\n        return MixingMultiProvidersWithRegularProvidersError;\n    }(BaseError));\n\n    /**\n     * A unique object used for retrieving items from the {@link ReflectiveInjector}.\n     *\n     * Keys have:\n     * - a system-wide unique `id`.\n     * - a `token`.\n     *\n     * `Key` is used internally by {@link ReflectiveInjector} because its system-wide unique `id` allows\n     * the\n     * injector to store created objects in a more efficient way.\n     *\n     * `Key` should not be created directly. {@link ReflectiveInjector} creates keys automatically when\n     * resolving\n     * providers.\n     * @experimental\n     */\n    var ReflectiveKey = (function () {\n        /**\n         * Private\n         */\n        function ReflectiveKey(token, id) {\n            this.token = token;\n            this.id = id;\n            if (isBlank(token)) {\n                throw new Error('Token must be defined!');\n            }\n        }\n        Object.defineProperty(ReflectiveKey.prototype, \"displayName\", {\n            /**\n             * Returns a stringified token.\n             */\n            get: function () { return stringify(this.token); },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * Retrieves a `Key` for a token.\n         */\n        ReflectiveKey.get = function (token) {\n            return _globalKeyRegistry.get(resolveForwardRef(token));\n        };\n        Object.defineProperty(ReflectiveKey, \"numberOfKeys\", {\n            /**\n             * @returns the number of keys registered in the system.\n             */\n            get: function () { return _globalKeyRegistry.numberOfKeys; },\n            enumerable: true,\n            configurable: true\n        });\n        return ReflectiveKey;\n    }());\n    /**\n     * @internal\n     */\n    var KeyRegistry = (function () {\n        function KeyRegistry() {\n            this._allKeys = new Map();\n        }\n        KeyRegistry.prototype.get = function (token) {\n            if (token instanceof ReflectiveKey)\n                return token;\n            if (this._allKeys.has(token)) {\n                return this._allKeys.get(token);\n            }\n            var newKey = new ReflectiveKey(token, ReflectiveKey.numberOfKeys);\n            this._allKeys.set(token, newKey);\n            return newKey;\n        };\n        Object.defineProperty(KeyRegistry.prototype, \"numberOfKeys\", {\n            get: function () { return this._allKeys.size; },\n            enumerable: true,\n            configurable: true\n        });\n        return KeyRegistry;\n    }());\n    var _globalKeyRegistry = new KeyRegistry();\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * @whatItDoes Represents a type that a Component or other object is instances of.\n     *\n     * @description\n     *\n     * An example of a `Type` is `MyCustomComponent` class, which in JavaScript is be represented by\n     * the `MyCustomComponent` constructor function.\n     *\n     * @stable\n     */\n    var Type = Function;\n\n    var ReflectionCapabilities = (function () {\n        function ReflectionCapabilities(reflect) {\n            this._reflect = reflect || global$1.Reflect;\n        }\n        ReflectionCapabilities.prototype.isReflectionEnabled = function () { return true; };\n        ReflectionCapabilities.prototype.factory = function (t) {\n            var prototype = t.prototype;\n            return function () {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i - 0] = arguments[_i];\n                }\n                var instance = Object.create(prototype);\n                t.apply(instance, args);\n                return instance;\n            };\n        };\n        /** @internal */\n        ReflectionCapabilities.prototype._zipTypesAndAnnotations = function (paramTypes /** TODO #9100 */, paramAnnotations /** TODO #9100 */) {\n            var result;\n            if (typeof paramTypes === 'undefined') {\n                result = new Array(paramAnnotations.length);\n            }\n            else {\n                result = new Array(paramTypes.length);\n            }\n            for (var i = 0; i < result.length; i++) {\n                // TS outputs Object for parameters without types, while Traceur omits\n                // the annotations. For now we preserve the Traceur behavior to aid\n                // migration, but this can be revisited.\n                if (typeof paramTypes === 'undefined') {\n                    result[i] = [];\n                }\n                else if (paramTypes[i] != Object) {\n                    result[i] = [paramTypes[i]];\n                }\n                else {\n                    result[i] = [];\n                }\n                if (isPresent(paramAnnotations) && isPresent(paramAnnotations[i])) {\n                    result[i] = result[i].concat(paramAnnotations[i]);\n                }\n            }\n            return result;\n        };\n        ReflectionCapabilities.prototype.parameters = function (typeOrFunc) {\n            // Prefer the direct API.\n            if (isPresent(typeOrFunc.parameters)) {\n                return typeOrFunc.parameters;\n            }\n            // API of tsickle for lowering decorators to properties on the class.\n            if (isPresent(typeOrFunc.ctorParameters)) {\n                var ctorParameters = typeOrFunc.ctorParameters;\n                var paramTypes_1 = ctorParameters.map(function (ctorParam /** TODO #9100 */) { return ctorParam && ctorParam.type; });\n                var paramAnnotations_1 = ctorParameters.map(function (ctorParam /** TODO #9100 */) {\n                    return ctorParam && convertTsickleDecoratorIntoMetadata(ctorParam.decorators);\n                });\n                return this._zipTypesAndAnnotations(paramTypes_1, paramAnnotations_1);\n            }\n            // API for metadata created by invoking the decorators.\n            if (isPresent(this._reflect) && isPresent(this._reflect.getMetadata)) {\n                var paramAnnotations = this._reflect.getMetadata('parameters', typeOrFunc);\n                var paramTypes = this._reflect.getMetadata('design:paramtypes', typeOrFunc);\n                if (isPresent(paramTypes) || isPresent(paramAnnotations)) {\n                    return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);\n                }\n            }\n            // The array has to be filled with `undefined` because holes would be skipped by `some`\n            var parameters = new Array(typeOrFunc.length);\n            parameters.fill(undefined);\n            return parameters;\n        };\n        ReflectionCapabilities.prototype.annotations = function (typeOrFunc) {\n            // Prefer the direct API.\n            if (isPresent(typeOrFunc.annotations)) {\n                var annotations = typeOrFunc.annotations;\n                if (isFunction(annotations) && annotations.annotations) {\n                    annotations = annotations.annotations;\n                }\n                return annotations;\n            }\n            // API of tsickle for lowering decorators to properties on the class.\n            if (isPresent(typeOrFunc.decorators)) {\n                return convertTsickleDecoratorIntoMetadata(typeOrFunc.decorators);\n            }\n            // API for metadata created by invoking the decorators.\n            if (isPresent(this._reflect) && isPresent(this._reflect.getMetadata)) {\n                var annotations = this._reflect.getMetadata('annotations', typeOrFunc);\n                if (isPresent(annotations))\n                    return annotations;\n            }\n            return [];\n        };\n        ReflectionCapabilities.prototype.propMetadata = function (typeOrFunc) {\n            // Prefer the direct API.\n            if (isPresent(typeOrFunc.propMetadata)) {\n                var propMetadata = typeOrFunc.propMetadata;\n                if (isFunction(propMetadata) && propMetadata.propMetadata) {\n                    propMetadata = propMetadata.propMetadata;\n                }\n                return propMetadata;\n            }\n            // API of tsickle for lowering decorators to properties on the class.\n            if (isPresent(typeOrFunc.propDecorators)) {\n                var propDecorators_1 = typeOrFunc.propDecorators;\n                var propMetadata_1 = {};\n                Object.keys(propDecorators_1).forEach(function (prop) {\n                    propMetadata_1[prop] = convertTsickleDecoratorIntoMetadata(propDecorators_1[prop]);\n                });\n                return propMetadata_1;\n            }\n            // API for metadata created by invoking the decorators.\n            if (isPresent(this._reflect) && isPresent(this._reflect.getMetadata)) {\n                var propMetadata = this._reflect.getMetadata('propMetadata', typeOrFunc);\n                if (isPresent(propMetadata))\n                    return propMetadata;\n            }\n            return {};\n        };\n        // Note: JavaScript does not support to query for interfaces during runtime.\n        // However, we can't throw here as the reflector will always call this method\n        // when asked for a lifecycle interface as this is what we check in Dart.\n        ReflectionCapabilities.prototype.interfaces = function (type) { return []; };\n        ReflectionCapabilities.prototype.hasLifecycleHook = function (type, lcInterface, lcProperty) {\n            if (!(type instanceof Type))\n                return false;\n            var proto = type.prototype;\n            return !!proto[lcProperty];\n        };\n        ReflectionCapabilities.prototype.getter = function (name) { return new Function('o', 'return o.' + name + ';'); };\n        ReflectionCapabilities.prototype.setter = function (name) {\n            return new Function('o', 'v', 'return o.' + name + ' = v;');\n        };\n        ReflectionCapabilities.prototype.method = function (name) {\n            var functionBody = \"if (!o.\" + name + \") throw new Error('\\\"\" + name + \"\\\" is undefined');\\n        return o.\" + name + \".apply(o, args);\";\n            return new Function('o', 'args', functionBody);\n        };\n        // There is not a concept of import uri in Js, but this is useful in developing Dart applications.\n        ReflectionCapabilities.prototype.importUri = function (type) {\n            // StaticSymbol\n            if (typeof type === 'object' && type['filePath']) {\n                return type['filePath'];\n            }\n            // Runtime type\n            return \"./\" + stringify(type);\n        };\n        ReflectionCapabilities.prototype.resolveIdentifier = function (name, moduleUrl, runtime) { return runtime; };\n        ReflectionCapabilities.prototype.resolveEnum = function (enumIdentifier, name) { return enumIdentifier[name]; };\n        return ReflectionCapabilities;\n    }());\n    function convertTsickleDecoratorIntoMetadata(decoratorInvocations) {\n        if (!decoratorInvocations) {\n            return [];\n        }\n        return decoratorInvocations.map(function (decoratorInvocation) {\n            var decoratorType = decoratorInvocation.type;\n            var annotationCls = decoratorType.annotationCls;\n            var annotationArgs = decoratorInvocation.args ? decoratorInvocation.args : [];\n            return new (annotationCls.bind.apply(annotationCls, [void 0].concat(annotationArgs)))();\n        });\n    }\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * Provides read-only access to reflection data about symbols. Used internally by Angular\n     * to power dependency injection and compilation.\n     */\n    var ReflectorReader = (function () {\n        function ReflectorReader() {\n        }\n        return ReflectorReader;\n    }());\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$2 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    /**\n     * Provides access to reflection data about symbols. Used internally by Angular\n     * to power dependency injection and compilation.\n     */\n    var Reflector = (function (_super) {\n        __extends$2(Reflector, _super);\n        function Reflector(reflectionCapabilities) {\n            _super.call(this);\n            this.reflectionCapabilities = reflectionCapabilities;\n            /** @internal */\n            this._injectableInfo = new Map();\n            /** @internal */\n            this._getters = new Map();\n            /** @internal */\n            this._setters = new Map();\n            /** @internal */\n            this._methods = new Map();\n            /** @internal */\n            this._usedKeys = null;\n        }\n        Reflector.prototype.updateCapabilities = function (caps) { this.reflectionCapabilities = caps; };\n        Reflector.prototype.isReflectionEnabled = function () { return this.reflectionCapabilities.isReflectionEnabled(); };\n        /**\n         * Causes `this` reflector to track keys used to access\n         * {@link ReflectionInfo} objects.\n         */\n        Reflector.prototype.trackUsage = function () { this._usedKeys = new Set(); };\n        /**\n         * Lists types for which reflection information was not requested since\n         * {@link #trackUsage} was called. This list could later be audited as\n         * potential dead code.\n         */\n        Reflector.prototype.listUnusedKeys = function () {\n            var _this = this;\n            if (this._usedKeys == null) {\n                throw new Error('Usage tracking is disabled');\n            }\n            var allTypes = MapWrapper.keys(this._injectableInfo);\n            return allTypes.filter(function (key) { return !SetWrapper.has(_this._usedKeys, key); });\n        };\n        Reflector.prototype.registerFunction = function (func, funcInfo) {\n            this._injectableInfo.set(func, funcInfo);\n        };\n        Reflector.prototype.registerType = function (type, typeInfo) {\n            this._injectableInfo.set(type, typeInfo);\n        };\n        Reflector.prototype.registerGetters = function (getters) { _mergeMaps(this._getters, getters); };\n        Reflector.prototype.registerSetters = function (setters) { _mergeMaps(this._setters, setters); };\n        Reflector.prototype.registerMethods = function (methods) { _mergeMaps(this._methods, methods); };\n        Reflector.prototype.factory = function (type) {\n            if (this._containsReflectionInfo(type)) {\n                var res = this._getReflectionInfo(type).factory;\n                return isPresent(res) ? res : null;\n            }\n            else {\n                return this.reflectionCapabilities.factory(type);\n            }\n        };\n        Reflector.prototype.parameters = function (typeOrFunc) {\n            if (this._injectableInfo.has(typeOrFunc)) {\n                var res = this._getReflectionInfo(typeOrFunc).parameters;\n                return isPresent(res) ? res : [];\n            }\n            else {\n                return this.reflectionCapabilities.parameters(typeOrFunc);\n            }\n        };\n        Reflector.prototype.annotations = function (typeOrFunc) {\n            if (this._injectableInfo.has(typeOrFunc)) {\n                var res = this._getReflectionInfo(typeOrFunc).annotations;\n                return isPresent(res) ? res : [];\n            }\n            else {\n                return this.reflectionCapabilities.annotations(typeOrFunc);\n            }\n        };\n        Reflector.prototype.propMetadata = function (typeOrFunc) {\n            if (this._injectableInfo.has(typeOrFunc)) {\n                var res = this._getReflectionInfo(typeOrFunc).propMetadata;\n                return isPresent(res) ? res : {};\n            }\n            else {\n                return this.reflectionCapabilities.propMetadata(typeOrFunc);\n            }\n        };\n        Reflector.prototype.interfaces = function (type) {\n            if (this._injectableInfo.has(type)) {\n                var res = this._getReflectionInfo(type).interfaces;\n                return isPresent(res) ? res : [];\n            }\n            else {\n                return this.reflectionCapabilities.interfaces(type);\n            }\n        };\n        Reflector.prototype.hasLifecycleHook = function (type, lcInterface, lcProperty) {\n            var interfaces = this.interfaces(type);\n            if (interfaces.indexOf(lcInterface) !== -1) {\n                return true;\n            }\n            else {\n                return this.reflectionCapabilities.hasLifecycleHook(type, lcInterface, lcProperty);\n            }\n        };\n        Reflector.prototype.getter = function (name) {\n            if (this._getters.has(name)) {\n                return this._getters.get(name);\n            }\n            else {\n                return this.reflectionCapabilities.getter(name);\n            }\n        };\n        Reflector.prototype.setter = function (name) {\n            if (this._setters.has(name)) {\n                return this._setters.get(name);\n            }\n            else {\n                return this.reflectionCapabilities.setter(name);\n            }\n        };\n        Reflector.prototype.method = function (name) {\n            if (this._methods.has(name)) {\n                return this._methods.get(name);\n            }\n            else {\n                return this.reflectionCapabilities.method(name);\n            }\n        };\n        /** @internal */\n        Reflector.prototype._getReflectionInfo = function (typeOrFunc) {\n            if (isPresent(this._usedKeys)) {\n                this._usedKeys.add(typeOrFunc);\n            }\n            return this._injectableInfo.get(typeOrFunc);\n        };\n        /** @internal */\n        Reflector.prototype._containsReflectionInfo = function (typeOrFunc) { return this._injectableInfo.has(typeOrFunc); };\n        Reflector.prototype.importUri = function (type) { return this.reflectionCapabilities.importUri(type); };\n        Reflector.prototype.resolveIdentifier = function (name, moduleUrl, runtime) {\n            return this.reflectionCapabilities.resolveIdentifier(name, moduleUrl, runtime);\n        };\n        Reflector.prototype.resolveEnum = function (identifier, name) {\n            return this.reflectionCapabilities.resolveEnum(identifier, name);\n        };\n        return Reflector;\n    }(ReflectorReader));\n    function _mergeMaps(target, config) {\n        StringMapWrapper.forEach(config, function (v, k) { return target.set(k, v); });\n    }\n\n    /**\n     * The {@link Reflector} used internally in Angular to access metadata\n     * about symbols.\n     */\n    var reflector = new Reflector(new ReflectionCapabilities());\n\n    /**\n     * `Dependency` is used by the framework to extend DI.\n     * This is internal to Angular and should not be used directly.\n     */\n    var ReflectiveDependency = (function () {\n        function ReflectiveDependency(key, optional, lowerBoundVisibility, upperBoundVisibility, properties) {\n            this.key = key;\n            this.optional = optional;\n            this.lowerBoundVisibility = lowerBoundVisibility;\n            this.upperBoundVisibility = upperBoundVisibility;\n            this.properties = properties;\n        }\n        ReflectiveDependency.fromKey = function (key) {\n            return new ReflectiveDependency(key, false, null, null, []);\n        };\n        return ReflectiveDependency;\n    }());\n    var _EMPTY_LIST = [];\n    var ResolvedReflectiveProvider_ = (function () {\n        function ResolvedReflectiveProvider_(key, resolvedFactories, multiProvider) {\n            this.key = key;\n            this.resolvedFactories = resolvedFactories;\n            this.multiProvider = multiProvider;\n        }\n        Object.defineProperty(ResolvedReflectiveProvider_.prototype, \"resolvedFactory\", {\n            get: function () { return this.resolvedFactories[0]; },\n            enumerable: true,\n            configurable: true\n        });\n        return ResolvedReflectiveProvider_;\n    }());\n    /**\n     * An internal resolved representation of a factory function created by resolving {@link\n     * Provider}.\n     * @experimental\n     */\n    var ResolvedReflectiveFactory = (function () {\n        function ResolvedReflectiveFactory(\n            /**\n             * Factory function which can return an instance of an object represented by a key.\n             */\n            factory,\n            /**\n             * Arguments (dependencies) to the `factory` function.\n             */\n            dependencies) {\n            this.factory = factory;\n            this.dependencies = dependencies;\n        }\n        return ResolvedReflectiveFactory;\n    }());\n    /**\n     * Resolve a single provider.\n     */\n    function resolveReflectiveFactory(provider) {\n        var factoryFn;\n        var resolvedDeps;\n        if (isPresent(provider.useClass)) {\n            var useClass = resolveForwardRef(provider.useClass);\n            factoryFn = reflector.factory(useClass);\n            resolvedDeps = _dependenciesFor(useClass);\n        }\n        else if (isPresent(provider.useExisting)) {\n            factoryFn = function (aliasInstance) { return aliasInstance; };\n            resolvedDeps = [ReflectiveDependency.fromKey(ReflectiveKey.get(provider.useExisting))];\n        }\n        else if (isPresent(provider.useFactory)) {\n            factoryFn = provider.useFactory;\n            resolvedDeps = constructDependencies(provider.useFactory, provider.deps);\n        }\n        else {\n            factoryFn = function () { return provider.useValue; };\n            resolvedDeps = _EMPTY_LIST;\n        }\n        return new ResolvedReflectiveFactory(factoryFn, resolvedDeps);\n    }\n    /**\n     * Converts the {@link Provider} into {@link ResolvedProvider}.\n     *\n     * {@link Injector} internally only uses {@link ResolvedProvider}, {@link Provider} contains\n     * convenience provider syntax.\n     */\n    function resolveReflectiveProvider(provider) {\n        return new ResolvedReflectiveProvider_(ReflectiveKey.get(provider.provide), [resolveReflectiveFactory(provider)], provider.multi);\n    }\n    /**\n     * Resolve a list of Providers.\n     */\n    function resolveReflectiveProviders(providers) {\n        var normalized = _normalizeProviders(providers, []);\n        var resolved = normalized.map(resolveReflectiveProvider);\n        return MapWrapper.values(mergeResolvedReflectiveProviders(resolved, new Map()));\n    }\n    /**\n     * Merges a list of ResolvedProviders into a list where\n     * each key is contained exactly once and multi providers\n     * have been merged.\n     */\n    function mergeResolvedReflectiveProviders(providers, normalizedProvidersMap) {\n        for (var i = 0; i < providers.length; i++) {\n            var provider = providers[i];\n            var existing = normalizedProvidersMap.get(provider.key.id);\n            if (isPresent(existing)) {\n                if (provider.multiProvider !== existing.multiProvider) {\n                    throw new MixingMultiProvidersWithRegularProvidersError(existing, provider);\n                }\n                if (provider.multiProvider) {\n                    for (var j = 0; j < provider.resolvedFactories.length; j++) {\n                        existing.resolvedFactories.push(provider.resolvedFactories[j]);\n                    }\n                }\n                else {\n                    normalizedProvidersMap.set(provider.key.id, provider);\n                }\n            }\n            else {\n                var resolvedProvider;\n                if (provider.multiProvider) {\n                    resolvedProvider = new ResolvedReflectiveProvider_(provider.key, ListWrapper.clone(provider.resolvedFactories), provider.multiProvider);\n                }\n                else {\n                    resolvedProvider = provider;\n                }\n                normalizedProvidersMap.set(provider.key.id, resolvedProvider);\n            }\n        }\n        return normalizedProvidersMap;\n    }\n    function _normalizeProviders(providers, res) {\n        providers.forEach(function (b) {\n            if (b instanceof Type) {\n                res.push({ provide: b, useClass: b });\n            }\n            else if (b && typeof b == 'object' && b.provide !== undefined) {\n                res.push(b);\n            }\n            else if (b instanceof Array) {\n                _normalizeProviders(b, res);\n            }\n            else {\n                throw new InvalidProviderError(b);\n            }\n        });\n        return res;\n    }\n    function constructDependencies(typeOrFunc, dependencies) {\n        if (isBlank(dependencies)) {\n            return _dependenciesFor(typeOrFunc);\n        }\n        else {\n            var params = dependencies.map(function (t) { return [t]; });\n            return dependencies.map(function (t) { return _extractToken(typeOrFunc, t, params); });\n        }\n    }\n    function _dependenciesFor(typeOrFunc) {\n        var params = reflector.parameters(typeOrFunc);\n        if (isBlank(params))\n            return [];\n        if (params.some(isBlank)) {\n            throw new NoAnnotationError(typeOrFunc, params);\n        }\n        return params.map(function (p) { return _extractToken(typeOrFunc, p, params); });\n    }\n    function _extractToken(typeOrFunc /** TODO #9100 */, metadata /** TODO #9100 */ /*any[] | any*/, params) {\n        var depProps = [];\n        var token = null;\n        var optional = false;\n        if (!isArray(metadata)) {\n            if (metadata instanceof Inject) {\n                return _createDependency(metadata.token, optional, null, null, depProps);\n            }\n            else {\n                return _createDependency(metadata, optional, null, null, depProps);\n            }\n        }\n        var lowerBoundVisibility = null;\n        var upperBoundVisibility = null;\n        for (var i = 0; i < metadata.length; ++i) {\n            var paramMetadata = metadata[i];\n            if (paramMetadata instanceof Type) {\n                token = paramMetadata;\n            }\n            else if (paramMetadata instanceof Inject) {\n                token = paramMetadata.token;\n            }\n            else if (paramMetadata instanceof Optional) {\n                optional = true;\n            }\n            else if (paramMetadata instanceof Self) {\n                upperBoundVisibility = paramMetadata;\n            }\n            else if (paramMetadata instanceof Host) {\n                upperBoundVisibility = paramMetadata;\n            }\n            else if (paramMetadata instanceof SkipSelf) {\n                lowerBoundVisibility = paramMetadata;\n            }\n        }\n        token = resolveForwardRef(token);\n        if (isPresent(token)) {\n            return _createDependency(token, optional, lowerBoundVisibility, upperBoundVisibility, depProps);\n        }\n        else {\n            throw new NoAnnotationError(typeOrFunc, params);\n        }\n    }\n    function _createDependency(token /** TODO #9100 */, optional /** TODO #9100 */, lowerBoundVisibility /** TODO #9100 */, upperBoundVisibility /** TODO #9100 */, depProps /** TODO #9100 */) {\n        return new ReflectiveDependency(ReflectiveKey.get(token), optional, lowerBoundVisibility, upperBoundVisibility, depProps);\n    }\n\n    // avoid unused import when Type union types are erased\n    // Threshold for the dynamic version\n    var _MAX_CONSTRUCTION_COUNTER = 10;\n    var UNDEFINED = new Object();\n    var ReflectiveProtoInjectorInlineStrategy = (function () {\n        function ReflectiveProtoInjectorInlineStrategy(protoEI, providers) {\n            this.provider0 = null;\n            this.provider1 = null;\n            this.provider2 = null;\n            this.provider3 = null;\n            this.provider4 = null;\n            this.provider5 = null;\n            this.provider6 = null;\n            this.provider7 = null;\n            this.provider8 = null;\n            this.provider9 = null;\n            this.keyId0 = null;\n            this.keyId1 = null;\n            this.keyId2 = null;\n            this.keyId3 = null;\n            this.keyId4 = null;\n            this.keyId5 = null;\n            this.keyId6 = null;\n            this.keyId7 = null;\n            this.keyId8 = null;\n            this.keyId9 = null;\n            var length = providers.length;\n            if (length > 0) {\n                this.provider0 = providers[0];\n                this.keyId0 = providers[0].key.id;\n            }\n            if (length > 1) {\n                this.provider1 = providers[1];\n                this.keyId1 = providers[1].key.id;\n            }\n            if (length > 2) {\n                this.provider2 = providers[2];\n                this.keyId2 = providers[2].key.id;\n            }\n            if (length > 3) {\n                this.provider3 = providers[3];\n                this.keyId3 = providers[3].key.id;\n            }\n            if (length > 4) {\n                this.provider4 = providers[4];\n                this.keyId4 = providers[4].key.id;\n            }\n            if (length > 5) {\n                this.provider5 = providers[5];\n                this.keyId5 = providers[5].key.id;\n            }\n            if (length > 6) {\n                this.provider6 = providers[6];\n                this.keyId6 = providers[6].key.id;\n            }\n            if (length > 7) {\n                this.provider7 = providers[7];\n                this.keyId7 = providers[7].key.id;\n            }\n            if (length > 8) {\n                this.provider8 = providers[8];\n                this.keyId8 = providers[8].key.id;\n            }\n            if (length > 9) {\n                this.provider9 = providers[9];\n                this.keyId9 = providers[9].key.id;\n            }\n        }\n        ReflectiveProtoInjectorInlineStrategy.prototype.getProviderAtIndex = function (index) {\n            if (index == 0)\n                return this.provider0;\n            if (index == 1)\n                return this.provider1;\n            if (index == 2)\n                return this.provider2;\n            if (index == 3)\n                return this.provider3;\n            if (index == 4)\n                return this.provider4;\n            if (index == 5)\n                return this.provider5;\n            if (index == 6)\n                return this.provider6;\n            if (index == 7)\n                return this.provider7;\n            if (index == 8)\n                return this.provider8;\n            if (index == 9)\n                return this.provider9;\n            throw new OutOfBoundsError(index);\n        };\n        ReflectiveProtoInjectorInlineStrategy.prototype.createInjectorStrategy = function (injector) {\n            return new ReflectiveInjectorInlineStrategy(injector, this);\n        };\n        return ReflectiveProtoInjectorInlineStrategy;\n    }());\n    var ReflectiveProtoInjectorDynamicStrategy = (function () {\n        function ReflectiveProtoInjectorDynamicStrategy(protoInj, providers) {\n            this.providers = providers;\n            var len = providers.length;\n            this.keyIds = new Array(len);\n            for (var i = 0; i < len; i++) {\n                this.keyIds[i] = providers[i].key.id;\n            }\n        }\n        ReflectiveProtoInjectorDynamicStrategy.prototype.getProviderAtIndex = function (index) {\n            if (index < 0 || index >= this.providers.length) {\n                throw new OutOfBoundsError(index);\n            }\n            return this.providers[index];\n        };\n        ReflectiveProtoInjectorDynamicStrategy.prototype.createInjectorStrategy = function (ei) {\n            return new ReflectiveInjectorDynamicStrategy(this, ei);\n        };\n        return ReflectiveProtoInjectorDynamicStrategy;\n    }());\n    var ReflectiveProtoInjector = (function () {\n        function ReflectiveProtoInjector(providers) {\n            this.numberOfProviders = providers.length;\n            this._strategy = providers.length > _MAX_CONSTRUCTION_COUNTER ?\n                new ReflectiveProtoInjectorDynamicStrategy(this, providers) :\n                new ReflectiveProtoInjectorInlineStrategy(this, providers);\n        }\n        ReflectiveProtoInjector.fromResolvedProviders = function (providers) {\n            return new ReflectiveProtoInjector(providers);\n        };\n        ReflectiveProtoInjector.prototype.getProviderAtIndex = function (index) {\n            return this._strategy.getProviderAtIndex(index);\n        };\n        return ReflectiveProtoInjector;\n    }());\n    var ReflectiveInjectorInlineStrategy = (function () {\n        function ReflectiveInjectorInlineStrategy(injector, protoStrategy) {\n            this.injector = injector;\n            this.protoStrategy = protoStrategy;\n            this.obj0 = UNDEFINED;\n            this.obj1 = UNDEFINED;\n            this.obj2 = UNDEFINED;\n            this.obj3 = UNDEFINED;\n            this.obj4 = UNDEFINED;\n            this.obj5 = UNDEFINED;\n            this.obj6 = UNDEFINED;\n            this.obj7 = UNDEFINED;\n            this.obj8 = UNDEFINED;\n            this.obj9 = UNDEFINED;\n        }\n        ReflectiveInjectorInlineStrategy.prototype.resetConstructionCounter = function () { this.injector._constructionCounter = 0; };\n        ReflectiveInjectorInlineStrategy.prototype.instantiateProvider = function (provider) {\n            return this.injector._new(provider);\n        };\n        ReflectiveInjectorInlineStrategy.prototype.getObjByKeyId = function (keyId) {\n            var p = this.protoStrategy;\n            var inj = this.injector;\n            if (p.keyId0 === keyId) {\n                if (this.obj0 === UNDEFINED) {\n                    this.obj0 = inj._new(p.provider0);\n                }\n                return this.obj0;\n            }\n            if (p.keyId1 === keyId) {\n                if (this.obj1 === UNDEFINED) {\n                    this.obj1 = inj._new(p.provider1);\n                }\n                return this.obj1;\n            }\n            if (p.keyId2 === keyId) {\n                if (this.obj2 === UNDEFINED) {\n                    this.obj2 = inj._new(p.provider2);\n                }\n                return this.obj2;\n            }\n            if (p.keyId3 === keyId) {\n                if (this.obj3 === UNDEFINED) {\n                    this.obj3 = inj._new(p.provider3);\n                }\n                return this.obj3;\n            }\n            if (p.keyId4 === keyId) {\n                if (this.obj4 === UNDEFINED) {\n                    this.obj4 = inj._new(p.provider4);\n                }\n                return this.obj4;\n            }\n            if (p.keyId5 === keyId) {\n                if (this.obj5 === UNDEFINED) {\n                    this.obj5 = inj._new(p.provider5);\n                }\n                return this.obj5;\n            }\n            if (p.keyId6 === keyId) {\n                if (this.obj6 === UNDEFINED) {\n                    this.obj6 = inj._new(p.provider6);\n                }\n                return this.obj6;\n            }\n            if (p.keyId7 === keyId) {\n                if (this.obj7 === UNDEFINED) {\n                    this.obj7 = inj._new(p.provider7);\n                }\n                return this.obj7;\n            }\n            if (p.keyId8 === keyId) {\n                if (this.obj8 === UNDEFINED) {\n                    this.obj8 = inj._new(p.provider8);\n                }\n                return this.obj8;\n            }\n            if (p.keyId9 === keyId) {\n                if (this.obj9 === UNDEFINED) {\n                    this.obj9 = inj._new(p.provider9);\n                }\n                return this.obj9;\n            }\n            return UNDEFINED;\n        };\n        ReflectiveInjectorInlineStrategy.prototype.getObjAtIndex = function (index) {\n            if (index == 0)\n                return this.obj0;\n            if (index == 1)\n                return this.obj1;\n            if (index == 2)\n                return this.obj2;\n            if (index == 3)\n                return this.obj3;\n            if (index == 4)\n                return this.obj4;\n            if (index == 5)\n                return this.obj5;\n            if (index == 6)\n                return this.obj6;\n            if (index == 7)\n                return this.obj7;\n            if (index == 8)\n                return this.obj8;\n            if (index == 9)\n                return this.obj9;\n            throw new OutOfBoundsError(index);\n        };\n        ReflectiveInjectorInlineStrategy.prototype.getMaxNumberOfObjects = function () { return _MAX_CONSTRUCTION_COUNTER; };\n        return ReflectiveInjectorInlineStrategy;\n    }());\n    var ReflectiveInjectorDynamicStrategy = (function () {\n        function ReflectiveInjectorDynamicStrategy(protoStrategy, injector) {\n            this.protoStrategy = protoStrategy;\n            this.injector = injector;\n            this.objs = new Array(protoStrategy.providers.length);\n            ListWrapper.fill(this.objs, UNDEFINED);\n        }\n        ReflectiveInjectorDynamicStrategy.prototype.resetConstructionCounter = function () { this.injector._constructionCounter = 0; };\n        ReflectiveInjectorDynamicStrategy.prototype.instantiateProvider = function (provider) {\n            return this.injector._new(provider);\n        };\n        ReflectiveInjectorDynamicStrategy.prototype.getObjByKeyId = function (keyId) {\n            var p = this.protoStrategy;\n            for (var i = 0; i < p.keyIds.length; i++) {\n                if (p.keyIds[i] === keyId) {\n                    if (this.objs[i] === UNDEFINED) {\n                        this.objs[i] = this.injector._new(p.providers[i]);\n                    }\n                    return this.objs[i];\n                }\n            }\n            return UNDEFINED;\n        };\n        ReflectiveInjectorDynamicStrategy.prototype.getObjAtIndex = function (index) {\n            if (index < 0 || index >= this.objs.length) {\n                throw new OutOfBoundsError(index);\n            }\n            return this.objs[index];\n        };\n        ReflectiveInjectorDynamicStrategy.prototype.getMaxNumberOfObjects = function () { return this.objs.length; };\n        return ReflectiveInjectorDynamicStrategy;\n    }());\n    /**\n     * A ReflectiveDependency injection container used for instantiating objects and resolving\n     * dependencies.\n     *\n     * An `Injector` is a replacement for a `new` operator, which can automatically resolve the\n     * constructor dependencies.\n     *\n     * In typical use, application code asks for the dependencies in the constructor and they are\n     * resolved by the `Injector`.\n     *\n     * ### Example ([live demo](http://plnkr.co/edit/jzjec0?p=preview))\n     *\n     * The following example creates an `Injector` configured to create `Engine` and `Car`.\n     *\n     * ```typescript\n     * @Injectable()\n     * class Engine {\n     * }\n     *\n     * @Injectable()\n     * class Car {\n     *   constructor(public engine:Engine) {}\n     * }\n     *\n     * var injector = ReflectiveInjector.resolveAndCreate([Car, Engine]);\n     * var car = injector.get(Car);\n     * expect(car instanceof Car).toBe(true);\n     * expect(car.engine instanceof Engine).toBe(true);\n     * ```\n     *\n     * Notice, we don't use the `new` operator because we explicitly want to have the `Injector`\n     * resolve all of the object's dependencies automatically.\n     *\n     * @stable\n     */\n    var ReflectiveInjector = (function () {\n        function ReflectiveInjector() {\n        }\n        /**\n         * Turns an array of provider definitions into an array of resolved providers.\n         *\n         * A resolution is a process of flattening multiple nested arrays and converting individual\n         * providers into an array of {@link ResolvedReflectiveProvider}s.\n         *\n         * ### Example ([live demo](http://plnkr.co/edit/AiXTHi?p=preview))\n         *\n         * ```typescript\n         * @Injectable()\n         * class Engine {\n         * }\n         *\n         * @Injectable()\n         * class Car {\n         *   constructor(public engine:Engine) {}\n         * }\n         *\n         * var providers = ReflectiveInjector.resolve([Car, [[Engine]]]);\n         *\n         * expect(providers.length).toEqual(2);\n         *\n         * expect(providers[0] instanceof ResolvedReflectiveProvider).toBe(true);\n         * expect(providers[0].key.displayName).toBe(\"Car\");\n         * expect(providers[0].dependencies.length).toEqual(1);\n         * expect(providers[0].factory).toBeDefined();\n         *\n         * expect(providers[1].key.displayName).toBe(\"Engine\");\n         * });\n         * ```\n         *\n         * See {@link ReflectiveInjector#fromResolvedProviders} for more info.\n         */\n        ReflectiveInjector.resolve = function (providers) {\n            return resolveReflectiveProviders(providers);\n        };\n        /**\n         * Resolves an array of providers and creates an injector from those providers.\n         *\n         * The passed-in providers can be an array of `Type`, {@link Provider},\n         * or a recursive array of more providers.\n         *\n         * ### Example ([live demo](http://plnkr.co/edit/ePOccA?p=preview))\n         *\n         * ```typescript\n         * @Injectable()\n         * class Engine {\n         * }\n         *\n         * @Injectable()\n         * class Car {\n         *   constructor(public engine:Engine) {}\n         * }\n         *\n         * var injector = ReflectiveInjector.resolveAndCreate([Car, Engine]);\n         * expect(injector.get(Car) instanceof Car).toBe(true);\n         * ```\n         *\n         * This function is slower than the corresponding `fromResolvedProviders`\n         * because it needs to resolve the passed-in providers first.\n         * See {@link Injector#resolve} and {@link Injector#fromResolvedProviders}.\n         */\n        ReflectiveInjector.resolveAndCreate = function (providers, parent) {\n            if (parent === void 0) { parent = null; }\n            var ResolvedReflectiveProviders = ReflectiveInjector.resolve(providers);\n            return ReflectiveInjector.fromResolvedProviders(ResolvedReflectiveProviders, parent);\n        };\n        /**\n         * Creates an injector from previously resolved providers.\n         *\n         * This API is the recommended way to construct injectors in performance-sensitive parts.\n         *\n         * ### Example ([live demo](http://plnkr.co/edit/KrSMci?p=preview))\n         *\n         * ```typescript\n         * @Injectable()\n         * class Engine {\n         * }\n         *\n         * @Injectable()\n         * class Car {\n         *   constructor(public engine:Engine) {}\n         * }\n         *\n         * var providers = ReflectiveInjector.resolve([Car, Engine]);\n         * var injector = ReflectiveInjector.fromResolvedProviders(providers);\n         * expect(injector.get(Car) instanceof Car).toBe(true);\n         * ```\n         * @experimental\n         */\n        ReflectiveInjector.fromResolvedProviders = function (providers, parent) {\n            if (parent === void 0) { parent = null; }\n            return new ReflectiveInjector_(ReflectiveProtoInjector.fromResolvedProviders(providers), parent);\n        };\n        Object.defineProperty(ReflectiveInjector.prototype, \"parent\", {\n            /**\n             * Parent of this injector.\n             *\n             * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.\n             * -->\n             *\n             * ### Example ([live demo](http://plnkr.co/edit/eosMGo?p=preview))\n             *\n             * ```typescript\n             * var parent = ReflectiveInjector.resolveAndCreate([]);\n             * var child = parent.resolveAndCreateChild([]);\n             * expect(child.parent).toBe(parent);\n             * ```\n             */\n            get: function () { return unimplemented(); },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * Resolves an array of providers and creates a child injector from those providers.\n         *\n         * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.\n         * -->\n         *\n         * The passed-in providers can be an array of `Type`, {@link Provider},\n         * or a recursive array of more providers.\n         *\n         * ### Example ([live demo](http://plnkr.co/edit/opB3T4?p=preview))\n         *\n         * ```typescript\n         * class ParentProvider {}\n         * class ChildProvider {}\n         *\n         * var parent = ReflectiveInjector.resolveAndCreate([ParentProvider]);\n         * var child = parent.resolveAndCreateChild([ChildProvider]);\n         *\n         * expect(child.get(ParentProvider) instanceof ParentProvider).toBe(true);\n         * expect(child.get(ChildProvider) instanceof ChildProvider).toBe(true);\n         * expect(child.get(ParentProvider)).toBe(parent.get(ParentProvider));\n         * ```\n         *\n         * This function is slower than the corresponding `createChildFromResolved`\n         * because it needs to resolve the passed-in providers first.\n         * See {@link Injector#resolve} and {@link Injector#createChildFromResolved}.\n         */\n        ReflectiveInjector.prototype.resolveAndCreateChild = function (providers) { return unimplemented(); };\n        /**\n         * Creates a child injector from previously resolved providers.\n         *\n         * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.\n         * -->\n         *\n         * This API is the recommended way to construct injectors in performance-sensitive parts.\n         *\n         * ### Example ([live demo](http://plnkr.co/edit/VhyfjN?p=preview))\n         *\n         * ```typescript\n         * class ParentProvider {}\n         * class ChildProvider {}\n         *\n         * var parentProviders = ReflectiveInjector.resolve([ParentProvider]);\n         * var childProviders = ReflectiveInjector.resolve([ChildProvider]);\n         *\n         * var parent = ReflectiveInjector.fromResolvedProviders(parentProviders);\n         * var child = parent.createChildFromResolved(childProviders);\n         *\n         * expect(child.get(ParentProvider) instanceof ParentProvider).toBe(true);\n         * expect(child.get(ChildProvider) instanceof ChildProvider).toBe(true);\n         * expect(child.get(ParentProvider)).toBe(parent.get(ParentProvider));\n         * ```\n         */\n        ReflectiveInjector.prototype.createChildFromResolved = function (providers) {\n            return unimplemented();\n        };\n        /**\n         * Resolves a provider and instantiates an object in the context of the injector.\n         *\n         * The created object does not get cached by the injector.\n         *\n         * ### Example ([live demo](http://plnkr.co/edit/yvVXoB?p=preview))\n         *\n         * ```typescript\n         * @Injectable()\n         * class Engine {\n         * }\n         *\n         * @Injectable()\n         * class Car {\n         *   constructor(public engine:Engine) {}\n         * }\n         *\n         * var injector = ReflectiveInjector.resolveAndCreate([Engine]);\n         *\n         * var car = injector.resolveAndInstantiate(Car);\n         * expect(car.engine).toBe(injector.get(Engine));\n         * expect(car).not.toBe(injector.resolveAndInstantiate(Car));\n         * ```\n         */\n        ReflectiveInjector.prototype.resolveAndInstantiate = function (provider) { return unimplemented(); };\n        /**\n         * Instantiates an object using a resolved provider in the context of the injector.\n         *\n         * The created object does not get cached by the injector.\n         *\n         * ### Example ([live demo](http://plnkr.co/edit/ptCImQ?p=preview))\n         *\n         * ```typescript\n         * @Injectable()\n         * class Engine {\n         * }\n         *\n         * @Injectable()\n         * class Car {\n         *   constructor(public engine:Engine) {}\n         * }\n         *\n         * var injector = ReflectiveInjector.resolveAndCreate([Engine]);\n         * var carProvider = ReflectiveInjector.resolve([Car])[0];\n         * var car = injector.instantiateResolved(carProvider);\n         * expect(car.engine).toBe(injector.get(Engine));\n         * expect(car).not.toBe(injector.instantiateResolved(carProvider));\n         * ```\n         */\n        ReflectiveInjector.prototype.instantiateResolved = function (provider) { return unimplemented(); };\n        return ReflectiveInjector;\n    }());\n    var ReflectiveInjector_ = (function () {\n        /**\n         * Private\n         */\n        function ReflectiveInjector_(_proto /* ProtoInjector */, _parent) {\n            if (_parent === void 0) { _parent = null; }\n            /** @internal */\n            this._constructionCounter = 0;\n            this._proto = _proto;\n            this._parent = _parent;\n            this._strategy = _proto._strategy.createInjectorStrategy(this);\n        }\n        ReflectiveInjector_.prototype.get = function (token, notFoundValue) {\n            if (notFoundValue === void 0) { notFoundValue = THROW_IF_NOT_FOUND; }\n            return this._getByKey(ReflectiveKey.get(token), null, null, notFoundValue);\n        };\n        ReflectiveInjector_.prototype.getAt = function (index) { return this._strategy.getObjAtIndex(index); };\n        Object.defineProperty(ReflectiveInjector_.prototype, \"parent\", {\n            get: function () { return this._parent; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ReflectiveInjector_.prototype, \"internalStrategy\", {\n            /**\n             * @internal\n             * Internal. Do not use.\n             * We return `any` not to export the InjectorStrategy type.\n             */\n            get: function () { return this._strategy; },\n            enumerable: true,\n            configurable: true\n        });\n        ReflectiveInjector_.prototype.resolveAndCreateChild = function (providers) {\n            var ResolvedReflectiveProviders = ReflectiveInjector.resolve(providers);\n            return this.createChildFromResolved(ResolvedReflectiveProviders);\n        };\n        ReflectiveInjector_.prototype.createChildFromResolved = function (providers) {\n            var proto = new ReflectiveProtoInjector(providers);\n            var inj = new ReflectiveInjector_(proto);\n            inj._parent = this;\n            return inj;\n        };\n        ReflectiveInjector_.prototype.resolveAndInstantiate = function (provider) {\n            return this.instantiateResolved(ReflectiveInjector.resolve([provider])[0]);\n        };\n        ReflectiveInjector_.prototype.instantiateResolved = function (provider) {\n            return this._instantiateProvider(provider);\n        };\n        /** @internal */\n        ReflectiveInjector_.prototype._new = function (provider) {\n            if (this._constructionCounter++ > this._strategy.getMaxNumberOfObjects()) {\n                throw new CyclicDependencyError(this, provider.key);\n            }\n            return this._instantiateProvider(provider);\n        };\n        ReflectiveInjector_.prototype._instantiateProvider = function (provider) {\n            if (provider.multiProvider) {\n                var res = new Array(provider.resolvedFactories.length);\n                for (var i = 0; i < provider.resolvedFactories.length; ++i) {\n                    res[i] = this._instantiate(provider, provider.resolvedFactories[i]);\n                }\n                return res;\n            }\n            else {\n                return this._instantiate(provider, provider.resolvedFactories[0]);\n            }\n        };\n        ReflectiveInjector_.prototype._instantiate = function (provider, ResolvedReflectiveFactory) {\n            var factory = ResolvedReflectiveFactory.factory;\n            var deps = ResolvedReflectiveFactory.dependencies;\n            var length = deps.length;\n            var d0;\n            var d1;\n            var d2;\n            var d3;\n            var d4;\n            var d5;\n            var d6;\n            var d7;\n            var d8;\n            var d9;\n            var d10;\n            var d11;\n            var d12;\n            var d13;\n            var d14;\n            var d15;\n            var d16;\n            var d17;\n            var d18;\n            var d19;\n            try {\n                d0 = length > 0 ? this._getByReflectiveDependency(provider, deps[0]) : null;\n                d1 = length > 1 ? this._getByReflectiveDependency(provider, deps[1]) : null;\n                d2 = length > 2 ? this._getByReflectiveDependency(provider, deps[2]) : null;\n                d3 = length > 3 ? this._getByReflectiveDependency(provider, deps[3]) : null;\n                d4 = length > 4 ? this._getByReflectiveDependency(provider, deps[4]) : null;\n                d5 = length > 5 ? this._getByReflectiveDependency(provider, deps[5]) : null;\n                d6 = length > 6 ? this._getByReflectiveDependency(provider, deps[6]) : null;\n                d7 = length > 7 ? this._getByReflectiveDependency(provider, deps[7]) : null;\n                d8 = length > 8 ? this._getByReflectiveDependency(provider, deps[8]) : null;\n                d9 = length > 9 ? this._getByReflectiveDependency(provider, deps[9]) : null;\n                d10 = length > 10 ? this._getByReflectiveDependency(provider, deps[10]) : null;\n                d11 = length > 11 ? this._getByReflectiveDependency(provider, deps[11]) : null;\n                d12 = length > 12 ? this._getByReflectiveDependency(provider, deps[12]) : null;\n                d13 = length > 13 ? this._getByReflectiveDependency(provider, deps[13]) : null;\n                d14 = length > 14 ? this._getByReflectiveDependency(provider, deps[14]) : null;\n                d15 = length > 15 ? this._getByReflectiveDependency(provider, deps[15]) : null;\n                d16 = length > 16 ? this._getByReflectiveDependency(provider, deps[16]) : null;\n                d17 = length > 17 ? this._getByReflectiveDependency(provider, deps[17]) : null;\n                d18 = length > 18 ? this._getByReflectiveDependency(provider, deps[18]) : null;\n                d19 = length > 19 ? this._getByReflectiveDependency(provider, deps[19]) : null;\n            }\n            catch (e) {\n                if (e instanceof AbstractProviderError || e instanceof InstantiationError) {\n                    e.addKey(this, provider.key);\n                }\n                throw e;\n            }\n            var obj;\n            try {\n                switch (length) {\n                    case 0:\n                        obj = factory();\n                        break;\n                    case 1:\n                        obj = factory(d0);\n                        break;\n                    case 2:\n                        obj = factory(d0, d1);\n                        break;\n                    case 3:\n                        obj = factory(d0, d1, d2);\n                        break;\n                    case 4:\n                        obj = factory(d0, d1, d2, d3);\n                        break;\n                    case 5:\n                        obj = factory(d0, d1, d2, d3, d4);\n                        break;\n                    case 6:\n                        obj = factory(d0, d1, d2, d3, d4, d5);\n                        break;\n                    case 7:\n                        obj = factory(d0, d1, d2, d3, d4, d5, d6);\n                        break;\n                    case 8:\n                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7);\n                        break;\n                    case 9:\n                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8);\n                        break;\n                    case 10:\n                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9);\n                        break;\n                    case 11:\n                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10);\n                        break;\n                    case 12:\n                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11);\n                        break;\n                    case 13:\n                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12);\n                        break;\n                    case 14:\n                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13);\n                        break;\n                    case 15:\n                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14);\n                        break;\n                    case 16:\n                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15);\n                        break;\n                    case 17:\n                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15, d16);\n                        break;\n                    case 18:\n                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15, d16, d17);\n                        break;\n                    case 19:\n                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15, d16, d17, d18);\n                        break;\n                    case 20:\n                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15, d16, d17, d18, d19);\n                        break;\n                    default:\n                        throw new Error(\"Cannot instantiate '\" + provider.key.displayName + \"' because it has more than 20 dependencies\");\n                }\n            }\n            catch (e) {\n                throw new InstantiationError(this, e, e.stack, provider.key);\n            }\n            return obj;\n        };\n        ReflectiveInjector_.prototype._getByReflectiveDependency = function (provider, dep) {\n            return this._getByKey(dep.key, dep.lowerBoundVisibility, dep.upperBoundVisibility, dep.optional ? null : THROW_IF_NOT_FOUND);\n        };\n        ReflectiveInjector_.prototype._getByKey = function (key, lowerBoundVisibility, upperBoundVisibility, notFoundValue) {\n            if (key === INJECTOR_KEY) {\n                return this;\n            }\n            if (upperBoundVisibility instanceof Self) {\n                return this._getByKeySelf(key, notFoundValue);\n            }\n            else {\n                return this._getByKeyDefault(key, notFoundValue, lowerBoundVisibility);\n            }\n        };\n        /** @internal */\n        ReflectiveInjector_.prototype._throwOrNull = function (key, notFoundValue) {\n            if (notFoundValue !== THROW_IF_NOT_FOUND) {\n                return notFoundValue;\n            }\n            else {\n                throw new NoProviderError(this, key);\n            }\n        };\n        /** @internal */\n        ReflectiveInjector_.prototype._getByKeySelf = function (key, notFoundValue) {\n            var obj = this._strategy.getObjByKeyId(key.id);\n            return (obj !== UNDEFINED) ? obj : this._throwOrNull(key, notFoundValue);\n        };\n        /** @internal */\n        ReflectiveInjector_.prototype._getByKeyDefault = function (key, notFoundValue, lowerBoundVisibility) {\n            var inj;\n            if (lowerBoundVisibility instanceof SkipSelf) {\n                inj = this._parent;\n            }\n            else {\n                inj = this;\n            }\n            while (inj instanceof ReflectiveInjector_) {\n                var inj_ = inj;\n                var obj = inj_._strategy.getObjByKeyId(key.id);\n                if (obj !== UNDEFINED)\n                    return obj;\n                inj = inj_._parent;\n            }\n            if (inj !== null) {\n                return inj.get(key.token, notFoundValue);\n            }\n            else {\n                return this._throwOrNull(key, notFoundValue);\n            }\n        };\n        Object.defineProperty(ReflectiveInjector_.prototype, \"displayName\", {\n            get: function () {\n                var providers = _mapProviders(this, function (b) { return ' \"' + b.key.displayName + '\" '; })\n                    .join(', ');\n                return \"ReflectiveInjector(providers: [\" + providers + \"])\";\n            },\n            enumerable: true,\n            configurable: true\n        });\n        ReflectiveInjector_.prototype.toString = function () { return this.displayName; };\n        return ReflectiveInjector_;\n    }());\n    var INJECTOR_KEY = ReflectiveKey.get(Injector);\n    function _mapProviders(injector, fn) {\n        var res = new Array(injector._proto.numberOfProviders);\n        for (var i = 0; i < injector._proto.numberOfProviders; ++i) {\n            res[i] = fn(injector._proto.getProviderAtIndex(i));\n        }\n        return res;\n    }\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * Provides a hook for centralized exception handling.\n     *\n     * The default implementation of `ErrorHandler` prints error messages to the `Console`. To\n     * intercept error handling,\n     * write a custom exception handler that replaces this default as appropriate for your app.\n     *\n     * ### Example\n     *\n     * ```javascript\n     *\n     * class MyErrorHandler implements ErrorHandler {\n     *   call(error, stackTrace = null, reason = null) {\n     *     // do something with the exception\n     *   }\n     * }\n     *\n     * @NgModule({\n     *   providers: [{provide: ErrorHandler, useClass: MyErrorHandler}]\n     * })\n     * class MyModule {}\n     * ```\n     * @stable\n     */\n    var ErrorHandler = (function () {\n        function ErrorHandler(rethrowError) {\n            if (rethrowError === void 0) { rethrowError = true; }\n            /**\n             * @internal\n             */\n            this._console = console;\n            this.rethrowError = rethrowError;\n        }\n        ErrorHandler.prototype.handleError = function (error) {\n            var originalError = this._findOriginalError(error);\n            var originalStack = this._findOriginalStack(error);\n            var context = this._findContext(error);\n            this._console.error(\"EXCEPTION: \" + this._extractMessage(error));\n            if (originalError) {\n                this._console.error(\"ORIGINAL EXCEPTION: \" + this._extractMessage(originalError));\n            }\n            if (originalStack) {\n                this._console.error('ORIGINAL STACKTRACE:');\n                this._console.error(originalStack);\n            }\n            if (context) {\n                this._console.error('ERROR CONTEXT:');\n                this._console.error(context);\n            }\n            // We rethrow exceptions, so operations like 'bootstrap' will result in an error\n            // when an error happens. If we do not rethrow, bootstrap will always succeed.\n            if (this.rethrowError)\n                throw error;\n        };\n        /** @internal */\n        ErrorHandler.prototype._extractMessage = function (error) {\n            return error instanceof Error ? error.message : error.toString();\n        };\n        /** @internal */\n        ErrorHandler.prototype._findContext = function (error) {\n            if (error) {\n                return error.context ? error.context :\n                    this._findContext(error.originalError);\n            }\n            else {\n                return null;\n            }\n        };\n        /** @internal */\n        ErrorHandler.prototype._findOriginalError = function (error) {\n            var e = error.originalError;\n            while (e && e.originalError) {\n                e = e.originalError;\n            }\n            return e;\n        };\n        /** @internal */\n        ErrorHandler.prototype._findOriginalStack = function (error) {\n            if (!(error instanceof Error))\n                return null;\n            var e = error;\n            var stack = e.stack;\n            while (e instanceof Error && e.originalError) {\n                e = e.originalError;\n                if (e instanceof Error && e.stack) {\n                    stack = e.stack;\n                }\n            }\n            return stack;\n        };\n        return ErrorHandler;\n    }());\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    function isPromise(obj) {\n        // allow any Promise/A+ compliant thenable.\n        // It's up to the caller to ensure that obj.then conforms to the spec\n        return !!obj && typeof obj.then === 'function';\n    }\n\n    /**\n     * A function that will be executed when an application is initialized.\n     * @experimental\n     */\n    var APP_INITIALIZER = new OpaqueToken('Application Initializer');\n    /**\n     * A class that reflects the state of running {@link APP_INITIALIZER}s.\n     *\n     * @experimental\n     */\n    var ApplicationInitStatus = (function () {\n        function ApplicationInitStatus(appInits) {\n            var _this = this;\n            this._done = false;\n            var asyncInitPromises = [];\n            if (appInits) {\n                for (var i = 0; i < appInits.length; i++) {\n                    var initResult = appInits[i]();\n                    if (isPromise(initResult)) {\n                        asyncInitPromises.push(initResult);\n                    }\n                }\n            }\n            this._donePromise = Promise.all(asyncInitPromises).then(function () { _this._done = true; });\n            if (asyncInitPromises.length === 0) {\n                this._done = true;\n            }\n        }\n        Object.defineProperty(ApplicationInitStatus.prototype, \"done\", {\n            get: function () { return this._done; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ApplicationInitStatus.prototype, \"donePromise\", {\n            get: function () { return this._donePromise; },\n            enumerable: true,\n            configurable: true\n        });\n        ApplicationInitStatus.decorators = [\n            { type: Injectable },\n        ];\n        /** @nocollapse */\n        ApplicationInitStatus.ctorParameters = [\n            { type: Array, decorators: [{ type: Inject, args: [APP_INITIALIZER,] }, { type: Optional },] },\n        ];\n        return ApplicationInitStatus;\n    }());\n\n    /**\n     * A DI Token representing a unique string id assigned to the application by Angular and used\n     * primarily for prefixing application attributes and CSS styles when\n     * {@link ViewEncapsulation#Emulated} is being used.\n     *\n     * If you need to avoid randomly generated value to be used as an application id, you can provide\n     * a custom value via a DI provider <!-- TODO: provider --> configuring the root {@link Injector}\n     * using this token.\n     * @experimental\n     */\n    var APP_ID = new OpaqueToken('AppId');\n    function _appIdRandomProviderFactory() {\n        return \"\" + _randomChar() + _randomChar() + _randomChar();\n    }\n    /**\n     * Providers that will generate a random APP_ID_TOKEN.\n     * @experimental\n     */\n    var APP_ID_RANDOM_PROVIDER = {\n        provide: APP_ID,\n        useFactory: _appIdRandomProviderFactory,\n        deps: [],\n    };\n    function _randomChar() {\n        return StringWrapper.fromCharCode(97 + Math.floor(Math.random() * 25));\n    }\n    /**\n     * A function that will be executed when a platform is initialized.\n     * @experimental\n     */\n    var PLATFORM_INITIALIZER = new OpaqueToken('Platform Initializer');\n    /**\n     * All callbacks provided via this token will be called for every component that is bootstrapped.\n     * Signature of the callback:\n     *\n     * `(componentRef: ComponentRef) => void`.\n     *\n     * @experimental\n     */\n    var APP_BOOTSTRAP_LISTENER = new OpaqueToken('appBootstrapListener');\n    /**\n     * A token which indicates the root directory of the application\n     * @experimental\n     */\n    var PACKAGE_ROOT_URL = new OpaqueToken('Application Packages Root URL');\n\n    var Console = (function () {\n        function Console() {\n        }\n        Console.prototype.log = function (message) { print(message); };\n        // Note: for reporting errors use `DOM.logError()` as it is platform specific\n        Console.prototype.warn = function (message) { warn(message); };\n        Console.decorators = [\n            { type: Injectable },\n        ];\n        /** @nocollapse */\n        Console.ctorParameters = [];\n        return Console;\n    }());\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$4 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    /**\n     * Indicates that a component is still being loaded in a synchronous compile.\n     *\n     * @stable\n     */\n    var ComponentStillLoadingError = (function (_super) {\n        __extends$4(ComponentStillLoadingError, _super);\n        function ComponentStillLoadingError(compType) {\n            _super.call(this, \"Can't compile synchronously as \" + stringify(compType) + \" is still being loaded!\");\n            this.compType = compType;\n        }\n        return ComponentStillLoadingError;\n    }(BaseError));\n    /**\n     * Combination of NgModuleFactory and ComponentFactorys.\n     *\n     * @experimental\n     */\n    var ModuleWithComponentFactories = (function () {\n        function ModuleWithComponentFactories(ngModuleFactory, componentFactories) {\n            this.ngModuleFactory = ngModuleFactory;\n            this.componentFactories = componentFactories;\n        }\n        return ModuleWithComponentFactories;\n    }());\n    function _throwError() {\n        throw new Error(\"Runtime compiler is not loaded\");\n    }\n    /**\n     * Low-level service for running the angular compiler during runtime\n     * to create {@link ComponentFactory}s, which\n     * can later be used to create and render a Component instance.\n     *\n     * Each `@NgModule` provides an own `Compiler` to its injector,\n     * that will use the directives/pipes of the ng module for compilation\n     * of components.\n     * @stable\n     */\n    var Compiler = (function () {\n        function Compiler() {\n        }\n        /**\n         * Compiles the given NgModule and all of its components. All templates of the components listed\n         * in `entryComponents`\n         * have to be inlined. Otherwise throws a {@link ComponentStillLoadingError}.\n         */\n        Compiler.prototype.compileModuleSync = function (moduleType) { throw _throwError(); };\n        /**\n         * Compiles the given NgModule and all of its components\n         */\n        Compiler.prototype.compileModuleAsync = function (moduleType) { throw _throwError(); };\n        /**\n         * Same as {@link compileModuleSync} but also creates ComponentFactories for all components.\n         */\n        Compiler.prototype.compileModuleAndAllComponentsSync = function (moduleType) {\n            throw _throwError();\n        };\n        /**\n         * Same as {@link compileModuleAsync} but also creates ComponentFactories for all components.\n         */\n        Compiler.prototype.compileModuleAndAllComponentsAsync = function (moduleType) {\n            throw _throwError();\n        };\n        /**\n         * Clears all caches.\n         */\n        Compiler.prototype.clearCache = function () { };\n        /**\n         * Clears the cache for the given component/ngModule.\n         */\n        Compiler.prototype.clearCacheFor = function (type) { };\n        return Compiler;\n    }());\n    /**\n     * Token to provide CompilerOptions in the platform injector.\n     *\n     * @experimental\n     */\n    var COMPILER_OPTIONS = new OpaqueToken('compilerOptions');\n    /**\n     * A factory for creating a Compiler\n     *\n     * @experimental\n     */\n    var CompilerFactory = (function () {\n        function CompilerFactory() {\n        }\n        return CompilerFactory;\n    }());\n\n    var DefaultIterableDifferFactory = (function () {\n        function DefaultIterableDifferFactory() {\n        }\n        DefaultIterableDifferFactory.prototype.supports = function (obj) { return isListLikeIterable(obj); };\n        DefaultIterableDifferFactory.prototype.create = function (cdRef, trackByFn) {\n            return new DefaultIterableDiffer(trackByFn);\n        };\n        return DefaultIterableDifferFactory;\n    }());\n    var trackByIdentity = function (index, item) { return item; };\n    /**\n     * @stable\n     */\n    var DefaultIterableDiffer = (function () {\n        function DefaultIterableDiffer(_trackByFn) {\n            this._trackByFn = _trackByFn;\n            this._length = null;\n            this._collection = null;\n            // Keeps track of the used records at any point in time (during & across `_check()` calls)\n            this._linkedRecords = null;\n            // Keeps track of the removed records at any point in time during `_check()` calls.\n            this._unlinkedRecords = null;\n            this._previousItHead = null;\n            this._itHead = null;\n            this._itTail = null;\n            this._additionsHead = null;\n            this._additionsTail = null;\n            this._movesHead = null;\n            this._movesTail = null;\n            this._removalsHead = null;\n            this._removalsTail = null;\n            // Keeps track of records where custom track by is the same, but item identity has changed\n            this._identityChangesHead = null;\n            this._identityChangesTail = null;\n            this._trackByFn = isPresent(this._trackByFn) ? this._trackByFn : trackByIdentity;\n        }\n        Object.defineProperty(DefaultIterableDiffer.prototype, \"collection\", {\n            get: function () { return this._collection; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(DefaultIterableDiffer.prototype, \"length\", {\n            get: function () { return this._length; },\n            enumerable: true,\n            configurable: true\n        });\n        DefaultIterableDiffer.prototype.forEachItem = function (fn) {\n            var record;\n            for (record = this._itHead; record !== null; record = record._next) {\n                fn(record);\n            }\n        };\n        DefaultIterableDiffer.prototype.forEachOperation = function (fn) {\n            var nextIt = this._itHead;\n            var nextRemove = this._removalsHead;\n            var addRemoveOffset = 0;\n            var moveOffsets = null;\n            while (nextIt || nextRemove) {\n                // Figure out which is the next record to process\n                // Order: remove, add, move\n                var record = !nextRemove ||\n                    nextIt &&\n                        nextIt.currentIndex < getPreviousIndex(nextRemove, addRemoveOffset, moveOffsets) ?\n                    nextIt :\n                    nextRemove;\n                var adjPreviousIndex = getPreviousIndex(record, addRemoveOffset, moveOffsets);\n                var currentIndex = record.currentIndex;\n                // consume the item, and adjust the addRemoveOffset and update moveDistance if necessary\n                if (record === nextRemove) {\n                    addRemoveOffset--;\n                    nextRemove = nextRemove._nextRemoved;\n                }\n                else {\n                    nextIt = nextIt._next;\n                    if (record.previousIndex == null) {\n                        addRemoveOffset++;\n                    }\n                    else {\n                        // INVARIANT:  currentIndex < previousIndex\n                        if (!moveOffsets)\n                            moveOffsets = [];\n                        var localMovePreviousIndex = adjPreviousIndex - addRemoveOffset;\n                        var localCurrentIndex = currentIndex - addRemoveOffset;\n                        if (localMovePreviousIndex != localCurrentIndex) {\n                            for (var i = 0; i < localMovePreviousIndex; i++) {\n                                var offset = i < moveOffsets.length ? moveOffsets[i] : (moveOffsets[i] = 0);\n                                var index = offset + i;\n                                if (localCurrentIndex <= index && index < localMovePreviousIndex) {\n                                    moveOffsets[i] = offset + 1;\n                                }\n                            }\n                            var previousIndex = record.previousIndex;\n                            moveOffsets[previousIndex] = localCurrentIndex - localMovePreviousIndex;\n                        }\n                    }\n                }\n                if (adjPreviousIndex !== currentIndex) {\n                    fn(record, adjPreviousIndex, currentIndex);\n                }\n            }\n        };\n        DefaultIterableDiffer.prototype.forEachPreviousItem = function (fn) {\n            var record;\n            for (record = this._previousItHead; record !== null; record = record._nextPrevious) {\n                fn(record);\n            }\n        };\n        DefaultIterableDiffer.prototype.forEachAddedItem = function (fn) {\n            var record;\n            for (record = this._additionsHead; record !== null; record = record._nextAdded) {\n                fn(record);\n            }\n        };\n        DefaultIterableDiffer.prototype.forEachMovedItem = function (fn) {\n            var record;\n            for (record = this._movesHead; record !== null; record = record._nextMoved) {\n                fn(record);\n            }\n        };\n        DefaultIterableDiffer.prototype.forEachRemovedItem = function (fn) {\n            var record;\n            for (record = this._removalsHead; record !== null; record = record._nextRemoved) {\n                fn(record);\n            }\n        };\n        DefaultIterableDiffer.prototype.forEachIdentityChange = function (fn) {\n            var record;\n            for (record = this._identityChangesHead; record !== null; record = record._nextIdentityChange) {\n                fn(record);\n            }\n        };\n        DefaultIterableDiffer.prototype.diff = function (collection) {\n            if (isBlank(collection))\n                collection = [];\n            if (!isListLikeIterable(collection)) {\n                throw new Error(\"Error trying to diff '\" + collection + \"'\");\n            }\n            if (this.check(collection)) {\n                return this;\n            }\n            else {\n                return null;\n            }\n        };\n        DefaultIterableDiffer.prototype.onDestroy = function () { };\n        // todo(vicb): optim for UnmodifiableListView (frozen arrays)\n        DefaultIterableDiffer.prototype.check = function (collection) {\n            var _this = this;\n            this._reset();\n            var record = this._itHead;\n            var mayBeDirty = false;\n            var index;\n            var item;\n            var itemTrackBy;\n            if (isArray(collection)) {\n                var list = collection;\n                this._length = collection.length;\n                for (index = 0; index < this._length; index++) {\n                    item = list[index];\n                    itemTrackBy = this._trackByFn(index, item);\n                    if (record === null || !looseIdentical(record.trackById, itemTrackBy)) {\n                        record = this._mismatch(record, item, itemTrackBy, index);\n                        mayBeDirty = true;\n                    }\n                    else {\n                        if (mayBeDirty) {\n                            // TODO(misko): can we limit this to duplicates only?\n                            record = this._verifyReinsertion(record, item, itemTrackBy, index);\n                        }\n                        if (!looseIdentical(record.item, item))\n                            this._addIdentityChange(record, item);\n                    }\n                    record = record._next;\n                }\n            }\n            else {\n                index = 0;\n                iterateListLike(collection, function (item /** TODO #9100 */) {\n                    itemTrackBy = _this._trackByFn(index, item);\n                    if (record === null || !looseIdentical(record.trackById, itemTrackBy)) {\n                        record = _this._mismatch(record, item, itemTrackBy, index);\n                        mayBeDirty = true;\n                    }\n                    else {\n                        if (mayBeDirty) {\n                            // TODO(misko): can we limit this to duplicates only?\n                            record = _this._verifyReinsertion(record, item, itemTrackBy, index);\n                        }\n                        if (!looseIdentical(record.item, item))\n                            _this._addIdentityChange(record, item);\n                    }\n                    record = record._next;\n                    index++;\n                });\n                this._length = index;\n            }\n            this._truncate(record);\n            this._collection = collection;\n            return this.isDirty;\n        };\n        Object.defineProperty(DefaultIterableDiffer.prototype, \"isDirty\", {\n            /* CollectionChanges is considered dirty if it has any additions, moves, removals, or identity\n             * changes.\n             */\n            get: function () {\n                return this._additionsHead !== null || this._movesHead !== null ||\n                    this._removalsHead !== null || this._identityChangesHead !== null;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * Reset the state of the change objects to show no changes. This means set previousKey to\n         * currentKey, and clear all of the queues (additions, moves, removals).\n         * Set the previousIndexes of moved and added items to their currentIndexes\n         * Reset the list of additions, moves and removals\n         *\n         * @internal\n         */\n        DefaultIterableDiffer.prototype._reset = function () {\n            if (this.isDirty) {\n                var record;\n                var nextRecord;\n                for (record = this._previousItHead = this._itHead; record !== null; record = record._next) {\n                    record._nextPrevious = record._next;\n                }\n                for (record = this._additionsHead; record !== null; record = record._nextAdded) {\n                    record.previousIndex = record.currentIndex;\n                }\n                this._additionsHead = this._additionsTail = null;\n                for (record = this._movesHead; record !== null; record = nextRecord) {\n                    record.previousIndex = record.currentIndex;\n                    nextRecord = record._nextMoved;\n                }\n                this._movesHead = this._movesTail = null;\n                this._removalsHead = this._removalsTail = null;\n                this._identityChangesHead = this._identityChangesTail = null;\n            }\n        };\n        /**\n         * This is the core function which handles differences between collections.\n         *\n         * - `record` is the record which we saw at this position last time. If null then it is a new\n         *   item.\n         * - `item` is the current item in the collection\n         * - `index` is the position of the item in the collection\n         *\n         * @internal\n         */\n        DefaultIterableDiffer.prototype._mismatch = function (record, item, itemTrackBy, index) {\n            // The previous record after which we will append the current one.\n            var previousRecord;\n            if (record === null) {\n                previousRecord = this._itTail;\n            }\n            else {\n                previousRecord = record._prev;\n                // Remove the record from the collection since we know it does not match the item.\n                this._remove(record);\n            }\n            // Attempt to see if we have seen the item before.\n            record = this._linkedRecords === null ? null : this._linkedRecords.get(itemTrackBy, index);\n            if (record !== null) {\n                // We have seen this before, we need to move it forward in the collection.\n                // But first we need to check if identity changed, so we can update in view if necessary\n                if (!looseIdentical(record.item, item))\n                    this._addIdentityChange(record, item);\n                this._moveAfter(record, previousRecord, index);\n            }\n            else {\n                // Never seen it, check evicted list.\n                record = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy);\n                if (record !== null) {\n                    // It is an item which we have evicted earlier: reinsert it back into the list.\n                    // But first we need to check if identity changed, so we can update in view if necessary\n                    if (!looseIdentical(record.item, item))\n                        this._addIdentityChange(record, item);\n                    this._reinsertAfter(record, previousRecord, index);\n                }\n                else {\n                    // It is a new item: add it.\n                    record =\n                        this._addAfter(new CollectionChangeRecord(item, itemTrackBy), previousRecord, index);\n                }\n            }\n            return record;\n        };\n        /**\n         * This check is only needed if an array contains duplicates. (Short circuit of nothing dirty)\n         *\n         * Use case: `[a, a]` => `[b, a, a]`\n         *\n         * If we did not have this check then the insertion of `b` would:\n         *   1) evict first `a`\n         *   2) insert `b` at `0` index.\n         *   3) leave `a` at index `1` as is. <-- this is wrong!\n         *   3) reinsert `a` at index 2. <-- this is wrong!\n         *\n         * The correct behavior is:\n         *   1) evict first `a`\n         *   2) insert `b` at `0` index.\n         *   3) reinsert `a` at index 1.\n         *   3) move `a` at from `1` to `2`.\n         *\n         *\n         * Double check that we have not evicted a duplicate item. We need to check if the item type may\n         * have already been removed:\n         * The insertion of b will evict the first 'a'. If we don't reinsert it now it will be reinserted\n         * at the end. Which will show up as the two 'a's switching position. This is incorrect, since a\n         * better way to think of it is as insert of 'b' rather then switch 'a' with 'b' and then add 'a'\n         * at the end.\n         *\n         * @internal\n         */\n        DefaultIterableDiffer.prototype._verifyReinsertion = function (record, item, itemTrackBy, index) {\n            var reinsertRecord = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy);\n            if (reinsertRecord !== null) {\n                record = this._reinsertAfter(reinsertRecord, record._prev, index);\n            }\n            else if (record.currentIndex != index) {\n                record.currentIndex = index;\n                this._addToMoves(record, index);\n            }\n            return record;\n        };\n        /**\n         * Get rid of any excess {@link CollectionChangeRecord}s from the previous collection\n         *\n         * - `record` The first excess {@link CollectionChangeRecord}.\n         *\n         * @internal\n         */\n        DefaultIterableDiffer.prototype._truncate = function (record) {\n            // Anything after that needs to be removed;\n            while (record !== null) {\n                var nextRecord = record._next;\n                this._addToRemovals(this._unlink(record));\n                record = nextRecord;\n            }\n            if (this._unlinkedRecords !== null) {\n                this._unlinkedRecords.clear();\n            }\n            if (this._additionsTail !== null) {\n                this._additionsTail._nextAdded = null;\n            }\n            if (this._movesTail !== null) {\n                this._movesTail._nextMoved = null;\n            }\n            if (this._itTail !== null) {\n                this._itTail._next = null;\n            }\n            if (this._removalsTail !== null) {\n                this._removalsTail._nextRemoved = null;\n            }\n            if (this._identityChangesTail !== null) {\n                this._identityChangesTail._nextIdentityChange = null;\n            }\n        };\n        /** @internal */\n        DefaultIterableDiffer.prototype._reinsertAfter = function (record, prevRecord, index) {\n            if (this._unlinkedRecords !== null) {\n                this._unlinkedRecords.remove(record);\n            }\n            var prev = record._prevRemoved;\n            var next = record._nextRemoved;\n            if (prev === null) {\n                this._removalsHead = next;\n            }\n            else {\n                prev._nextRemoved = next;\n            }\n            if (next === null) {\n                this._removalsTail = prev;\n            }\n            else {\n                next._prevRemoved = prev;\n            }\n            this._insertAfter(record, prevRecord, index);\n            this._addToMoves(record, index);\n            return record;\n        };\n        /** @internal */\n        DefaultIterableDiffer.prototype._moveAfter = function (record, prevRecord, index) {\n            this._unlink(record);\n            this._insertAfter(record, prevRecord, index);\n            this._addToMoves(record, index);\n            return record;\n        };\n        /** @internal */\n        DefaultIterableDiffer.prototype._addAfter = function (record, prevRecord, index) {\n            this._insertAfter(record, prevRecord, index);\n            if (this._additionsTail === null) {\n                // todo(vicb)\n                // assert(this._additionsHead === null);\n                this._additionsTail = this._additionsHead = record;\n            }\n            else {\n                // todo(vicb)\n                // assert(_additionsTail._nextAdded === null);\n                // assert(record._nextAdded === null);\n                this._additionsTail = this._additionsTail._nextAdded = record;\n            }\n            return record;\n        };\n        /** @internal */\n        DefaultIterableDiffer.prototype._insertAfter = function (record, prevRecord, index) {\n            // todo(vicb)\n            // assert(record != prevRecord);\n            // assert(record._next === null);\n            // assert(record._prev === null);\n            var next = prevRecord === null ? this._itHead : prevRecord._next;\n            // todo(vicb)\n            // assert(next != record);\n            // assert(prevRecord != record);\n            record._next = next;\n            record._prev = prevRecord;\n            if (next === null) {\n                this._itTail = record;\n            }\n            else {\n                next._prev = record;\n            }\n            if (prevRecord === null) {\n                this._itHead = record;\n            }\n            else {\n                prevRecord._next = record;\n            }\n            if (this._linkedRecords === null) {\n                this._linkedRecords = new _DuplicateMap();\n            }\n            this._linkedRecords.put(record);\n            record.currentIndex = index;\n            return record;\n        };\n        /** @internal */\n        DefaultIterableDiffer.prototype._remove = function (record) {\n            return this._addToRemovals(this._unlink(record));\n        };\n        /** @internal */\n        DefaultIterableDiffer.prototype._unlink = function (record) {\n            if (this._linkedRecords !== null) {\n                this._linkedRecords.remove(record);\n            }\n            var prev = record._prev;\n            var next = record._next;\n            // todo(vicb)\n            // assert((record._prev = null) === null);\n            // assert((record._next = null) === null);\n            if (prev === null) {\n                this._itHead = next;\n            }\n            else {\n                prev._next = next;\n            }\n            if (next === null) {\n                this._itTail = prev;\n            }\n            else {\n                next._prev = prev;\n            }\n            return record;\n        };\n        /** @internal */\n        DefaultIterableDiffer.prototype._addToMoves = function (record, toIndex) {\n            // todo(vicb)\n            // assert(record._nextMoved === null);\n            if (record.previousIndex === toIndex) {\n                return record;\n            }\n            if (this._movesTail === null) {\n                // todo(vicb)\n                // assert(_movesHead === null);\n                this._movesTail = this._movesHead = record;\n            }\n            else {\n                // todo(vicb)\n                // assert(_movesTail._nextMoved === null);\n                this._movesTail = this._movesTail._nextMoved = record;\n            }\n            return record;\n        };\n        /** @internal */\n        DefaultIterableDiffer.prototype._addToRemovals = function (record) {\n            if (this._unlinkedRecords === null) {\n                this._unlinkedRecords = new _DuplicateMap();\n            }\n            this._unlinkedRecords.put(record);\n            record.currentIndex = null;\n            record._nextRemoved = null;\n            if (this._removalsTail === null) {\n                // todo(vicb)\n                // assert(_removalsHead === null);\n                this._removalsTail = this._removalsHead = record;\n                record._prevRemoved = null;\n            }\n            else {\n                // todo(vicb)\n                // assert(_removalsTail._nextRemoved === null);\n                // assert(record._nextRemoved === null);\n                record._prevRemoved = this._removalsTail;\n                this._removalsTail = this._removalsTail._nextRemoved = record;\n            }\n            return record;\n        };\n        /** @internal */\n        DefaultIterableDiffer.prototype._addIdentityChange = function (record, item) {\n            record.item = item;\n            if (this._identityChangesTail === null) {\n                this._identityChangesTail = this._identityChangesHead = record;\n            }\n            else {\n                this._identityChangesTail = this._identityChangesTail._nextIdentityChange = record;\n            }\n            return record;\n        };\n        DefaultIterableDiffer.prototype.toString = function () {\n            var list = [];\n            this.forEachItem(function (record /** TODO #9100 */) { return list.push(record); });\n            var previous = [];\n            this.forEachPreviousItem(function (record /** TODO #9100 */) { return previous.push(record); });\n            var additions = [];\n            this.forEachAddedItem(function (record /** TODO #9100 */) { return additions.push(record); });\n            var moves = [];\n            this.forEachMovedItem(function (record /** TODO #9100 */) { return moves.push(record); });\n            var removals = [];\n            this.forEachRemovedItem(function (record /** TODO #9100 */) { return removals.push(record); });\n            var identityChanges = [];\n            this.forEachIdentityChange(function (record /** TODO #9100 */) { return identityChanges.push(record); });\n            return 'collection: ' + list.join(', ') + '\\n' +\n                'previous: ' + previous.join(', ') + '\\n' +\n                'additions: ' + additions.join(', ') + '\\n' +\n                'moves: ' + moves.join(', ') + '\\n' +\n                'removals: ' + removals.join(', ') + '\\n' +\n                'identityChanges: ' + identityChanges.join(', ') + '\\n';\n        };\n        return DefaultIterableDiffer;\n    }());\n    /**\n     * @stable\n     */\n    var CollectionChangeRecord = (function () {\n        function CollectionChangeRecord(item, trackById) {\n            this.item = item;\n            this.trackById = trackById;\n            this.currentIndex = null;\n            this.previousIndex = null;\n            /** @internal */\n            this._nextPrevious = null;\n            /** @internal */\n            this._prev = null;\n            /** @internal */\n            this._next = null;\n            /** @internal */\n            this._prevDup = null;\n            /** @internal */\n            this._nextDup = null;\n            /** @internal */\n            this._prevRemoved = null;\n            /** @internal */\n            this._nextRemoved = null;\n            /** @internal */\n            this._nextAdded = null;\n            /** @internal */\n            this._nextMoved = null;\n            /** @internal */\n            this._nextIdentityChange = null;\n        }\n        CollectionChangeRecord.prototype.toString = function () {\n            return this.previousIndex === this.currentIndex ? stringify(this.item) :\n                stringify(this.item) + '[' +\n                    stringify(this.previousIndex) + '->' + stringify(this.currentIndex) + ']';\n        };\n        return CollectionChangeRecord;\n    }());\n    // A linked list of CollectionChangeRecords with the same CollectionChangeRecord.item\n    var _DuplicateItemRecordList = (function () {\n        function _DuplicateItemRecordList() {\n            /** @internal */\n            this._head = null;\n            /** @internal */\n            this._tail = null;\n        }\n        /**\n         * Append the record to the list of duplicates.\n         *\n         * Note: by design all records in the list of duplicates hold the same value in record.item.\n         */\n        _DuplicateItemRecordList.prototype.add = function (record) {\n            if (this._head === null) {\n                this._head = this._tail = record;\n                record._nextDup = null;\n                record._prevDup = null;\n            }\n            else {\n                // todo(vicb)\n                // assert(record.item ==  _head.item ||\n                //       record.item is num && record.item.isNaN && _head.item is num && _head.item.isNaN);\n                this._tail._nextDup = record;\n                record._prevDup = this._tail;\n                record._nextDup = null;\n                this._tail = record;\n            }\n        };\n        // Returns a CollectionChangeRecord having CollectionChangeRecord.trackById == trackById and\n        // CollectionChangeRecord.currentIndex >= afterIndex\n        _DuplicateItemRecordList.prototype.get = function (trackById, afterIndex) {\n            var record;\n            for (record = this._head; record !== null; record = record._nextDup) {\n                if ((afterIndex === null || afterIndex < record.currentIndex) &&\n                    looseIdentical(record.trackById, trackById)) {\n                    return record;\n                }\n            }\n            return null;\n        };\n        /**\n         * Remove one {@link CollectionChangeRecord} from the list of duplicates.\n         *\n         * Returns whether the list of duplicates is empty.\n         */\n        _DuplicateItemRecordList.prototype.remove = function (record) {\n            // todo(vicb)\n            // assert(() {\n            //  // verify that the record being removed is in the list.\n            //  for (CollectionChangeRecord cursor = _head; cursor != null; cursor = cursor._nextDup) {\n            //    if (identical(cursor, record)) return true;\n            //  }\n            //  return false;\n            //});\n            var prev = record._prevDup;\n            var next = record._nextDup;\n            if (prev === null) {\n                this._head = next;\n            }\n            else {\n                prev._nextDup = next;\n            }\n            if (next === null) {\n                this._tail = prev;\n            }\n            else {\n                next._prevDup = prev;\n            }\n            return this._head === null;\n        };\n        return _DuplicateItemRecordList;\n    }());\n    var _DuplicateMap = (function () {\n        function _DuplicateMap() {\n            this.map = new Map();\n        }\n        _DuplicateMap.prototype.put = function (record) {\n            // todo(vicb) handle corner cases\n            var key = getMapKey(record.trackById);\n            var duplicates = this.map.get(key);\n            if (!isPresent(duplicates)) {\n                duplicates = new _DuplicateItemRecordList();\n                this.map.set(key, duplicates);\n            }\n            duplicates.add(record);\n        };\n        /**\n         * Retrieve the `value` using key. Because the CollectionChangeRecord value may be one which we\n         * have already iterated over, we use the afterIndex to pretend it is not there.\n         *\n         * Use case: `[a, b, c, a, a]` if we are at index `3` which is the second `a` then asking if we\n         * have any more `a`s needs to return the last `a` not the first or second.\n         */\n        _DuplicateMap.prototype.get = function (trackById, afterIndex) {\n            if (afterIndex === void 0) { afterIndex = null; }\n            var key = getMapKey(trackById);\n            var recordList = this.map.get(key);\n            return isBlank(recordList) ? null : recordList.get(trackById, afterIndex);\n        };\n        /**\n         * Removes a {@link CollectionChangeRecord} from the list of duplicates.\n         *\n         * The list of duplicates also is removed from the map if it gets empty.\n         */\n        _DuplicateMap.prototype.remove = function (record) {\n            var key = getMapKey(record.trackById);\n            // todo(vicb)\n            // assert(this.map.containsKey(key));\n            var recordList = this.map.get(key);\n            // Remove the list of duplicates when it gets empty\n            if (recordList.remove(record)) {\n                this.map.delete(key);\n            }\n            return record;\n        };\n        Object.defineProperty(_DuplicateMap.prototype, \"isEmpty\", {\n            get: function () { return this.map.size === 0; },\n            enumerable: true,\n            configurable: true\n        });\n        _DuplicateMap.prototype.clear = function () { this.map.clear(); };\n        _DuplicateMap.prototype.toString = function () { return '_DuplicateMap(' + stringify(this.map) + ')'; };\n        return _DuplicateMap;\n    }());\n    function getPreviousIndex(item, addRemoveOffset, moveOffsets) {\n        var previousIndex = item.previousIndex;\n        if (previousIndex === null)\n            return previousIndex;\n        var moveOffset = 0;\n        if (moveOffsets && previousIndex < moveOffsets.length) {\n            moveOffset = moveOffsets[previousIndex];\n        }\n        return previousIndex + addRemoveOffset + moveOffset;\n    }\n\n    var DefaultKeyValueDifferFactory = (function () {\n        function DefaultKeyValueDifferFactory() {\n        }\n        DefaultKeyValueDifferFactory.prototype.supports = function (obj) { return obj instanceof Map || isJsObject(obj); };\n        DefaultKeyValueDifferFactory.prototype.create = function (cdRef) { return new DefaultKeyValueDiffer(); };\n        return DefaultKeyValueDifferFactory;\n    }());\n    var DefaultKeyValueDiffer = (function () {\n        function DefaultKeyValueDiffer() {\n            this._records = new Map();\n            this._mapHead = null;\n            this._previousMapHead = null;\n            this._changesHead = null;\n            this._changesTail = null;\n            this._additionsHead = null;\n            this._additionsTail = null;\n            this._removalsHead = null;\n            this._removalsTail = null;\n        }\n        Object.defineProperty(DefaultKeyValueDiffer.prototype, \"isDirty\", {\n            get: function () {\n                return this._additionsHead !== null || this._changesHead !== null ||\n                    this._removalsHead !== null;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        DefaultKeyValueDiffer.prototype.forEachItem = function (fn) {\n            var record;\n            for (record = this._mapHead; record !== null; record = record._next) {\n                fn(record);\n            }\n        };\n        DefaultKeyValueDiffer.prototype.forEachPreviousItem = function (fn) {\n            var record;\n            for (record = this._previousMapHead; record !== null; record = record._nextPrevious) {\n                fn(record);\n            }\n        };\n        DefaultKeyValueDiffer.prototype.forEachChangedItem = function (fn) {\n            var record;\n            for (record = this._changesHead; record !== null; record = record._nextChanged) {\n                fn(record);\n            }\n        };\n        DefaultKeyValueDiffer.prototype.forEachAddedItem = function (fn) {\n            var record;\n            for (record = this._additionsHead; record !== null; record = record._nextAdded) {\n                fn(record);\n            }\n        };\n        DefaultKeyValueDiffer.prototype.forEachRemovedItem = function (fn) {\n            var record;\n            for (record = this._removalsHead; record !== null; record = record._nextRemoved) {\n                fn(record);\n            }\n        };\n        DefaultKeyValueDiffer.prototype.diff = function (map) {\n            if (!map) {\n                map = new Map();\n            }\n            else if (!(map instanceof Map || isJsObject(map))) {\n                throw new Error(\"Error trying to diff '\" + map + \"'\");\n            }\n            return this.check(map) ? this : null;\n        };\n        DefaultKeyValueDiffer.prototype.onDestroy = function () { };\n        DefaultKeyValueDiffer.prototype.check = function (map) {\n            var _this = this;\n            this._reset();\n            var records = this._records;\n            var oldSeqRecord = this._mapHead;\n            var lastOldSeqRecord = null;\n            var lastNewSeqRecord = null;\n            var seqChanged = false;\n            this._forEach(map, function (value, key) {\n                var newSeqRecord;\n                if (oldSeqRecord && key === oldSeqRecord.key) {\n                    newSeqRecord = oldSeqRecord;\n                    _this._maybeAddToChanges(newSeqRecord, value);\n                }\n                else {\n                    seqChanged = true;\n                    if (oldSeqRecord !== null) {\n                        _this._removeFromSeq(lastOldSeqRecord, oldSeqRecord);\n                        _this._addToRemovals(oldSeqRecord);\n                    }\n                    if (records.has(key)) {\n                        newSeqRecord = records.get(key);\n                        _this._maybeAddToChanges(newSeqRecord, value);\n                    }\n                    else {\n                        newSeqRecord = new KeyValueChangeRecord(key);\n                        records.set(key, newSeqRecord);\n                        newSeqRecord.currentValue = value;\n                        _this._addToAdditions(newSeqRecord);\n                    }\n                }\n                if (seqChanged) {\n                    if (_this._isInRemovals(newSeqRecord)) {\n                        _this._removeFromRemovals(newSeqRecord);\n                    }\n                    if (lastNewSeqRecord == null) {\n                        _this._mapHead = newSeqRecord;\n                    }\n                    else {\n                        lastNewSeqRecord._next = newSeqRecord;\n                    }\n                }\n                lastOldSeqRecord = oldSeqRecord;\n                lastNewSeqRecord = newSeqRecord;\n                oldSeqRecord = oldSeqRecord && oldSeqRecord._next;\n            });\n            this._truncate(lastOldSeqRecord, oldSeqRecord);\n            return this.isDirty;\n        };\n        /** @internal */\n        DefaultKeyValueDiffer.prototype._reset = function () {\n            if (this.isDirty) {\n                var record = void 0;\n                // Record the state of the mapping\n                for (record = this._previousMapHead = this._mapHead; record !== null; record = record._next) {\n                    record._nextPrevious = record._next;\n                }\n                for (record = this._changesHead; record !== null; record = record._nextChanged) {\n                    record.previousValue = record.currentValue;\n                }\n                for (record = this._additionsHead; record != null; record = record._nextAdded) {\n                    record.previousValue = record.currentValue;\n                }\n                this._changesHead = this._changesTail = null;\n                this._additionsHead = this._additionsTail = null;\n                this._removalsHead = this._removalsTail = null;\n            }\n        };\n        /** @internal */\n        DefaultKeyValueDiffer.prototype._truncate = function (lastRecord, record) {\n            while (record !== null) {\n                if (lastRecord === null) {\n                    this._mapHead = null;\n                }\n                else {\n                    lastRecord._next = null;\n                }\n                var nextRecord = record._next;\n                this._addToRemovals(record);\n                lastRecord = record;\n                record = nextRecord;\n            }\n            for (var rec = this._removalsHead; rec !== null; rec = rec._nextRemoved) {\n                rec.previousValue = rec.currentValue;\n                rec.currentValue = null;\n                this._records.delete(rec.key);\n            }\n        };\n        DefaultKeyValueDiffer.prototype._maybeAddToChanges = function (record, newValue) {\n            if (!looseIdentical(newValue, record.currentValue)) {\n                record.previousValue = record.currentValue;\n                record.currentValue = newValue;\n                this._addToChanges(record);\n            }\n        };\n        /** @internal */\n        DefaultKeyValueDiffer.prototype._isInRemovals = function (record) {\n            return record === this._removalsHead || record._nextRemoved !== null ||\n                record._prevRemoved !== null;\n        };\n        /** @internal */\n        DefaultKeyValueDiffer.prototype._addToRemovals = function (record) {\n            if (this._removalsHead === null) {\n                this._removalsHead = this._removalsTail = record;\n            }\n            else {\n                this._removalsTail._nextRemoved = record;\n                record._prevRemoved = this._removalsTail;\n                this._removalsTail = record;\n            }\n        };\n        /** @internal */\n        DefaultKeyValueDiffer.prototype._removeFromSeq = function (prev, record) {\n            var next = record._next;\n            if (prev === null) {\n                this._mapHead = next;\n            }\n            else {\n                prev._next = next;\n            }\n            record._next = null;\n        };\n        /** @internal */\n        DefaultKeyValueDiffer.prototype._removeFromRemovals = function (record) {\n            var prev = record._prevRemoved;\n            var next = record._nextRemoved;\n            if (prev === null) {\n                this._removalsHead = next;\n            }\n            else {\n                prev._nextRemoved = next;\n            }\n            if (next === null) {\n                this._removalsTail = prev;\n            }\n            else {\n                next._prevRemoved = prev;\n            }\n            record._prevRemoved = record._nextRemoved = null;\n        };\n        /** @internal */\n        DefaultKeyValueDiffer.prototype._addToAdditions = function (record) {\n            if (this._additionsHead === null) {\n                this._additionsHead = this._additionsTail = record;\n            }\n            else {\n                this._additionsTail._nextAdded = record;\n                this._additionsTail = record;\n            }\n        };\n        /** @internal */\n        DefaultKeyValueDiffer.prototype._addToChanges = function (record) {\n            if (this._changesHead === null) {\n                this._changesHead = this._changesTail = record;\n            }\n            else {\n                this._changesTail._nextChanged = record;\n                this._changesTail = record;\n            }\n        };\n        DefaultKeyValueDiffer.prototype.toString = function () {\n            var items = [];\n            var previous = [];\n            var changes = [];\n            var additions = [];\n            var removals = [];\n            var record;\n            for (record = this._mapHead; record !== null; record = record._next) {\n                items.push(stringify(record));\n            }\n            for (record = this._previousMapHead; record !== null; record = record._nextPrevious) {\n                previous.push(stringify(record));\n            }\n            for (record = this._changesHead; record !== null; record = record._nextChanged) {\n                changes.push(stringify(record));\n            }\n            for (record = this._additionsHead; record !== null; record = record._nextAdded) {\n                additions.push(stringify(record));\n            }\n            for (record = this._removalsHead; record !== null; record = record._nextRemoved) {\n                removals.push(stringify(record));\n            }\n            return 'map: ' + items.join(', ') + '\\n' +\n                'previous: ' + previous.join(', ') + '\\n' +\n                'additions: ' + additions.join(', ') + '\\n' +\n                'changes: ' + changes.join(', ') + '\\n' +\n                'removals: ' + removals.join(', ') + '\\n';\n        };\n        /** @internal */\n        DefaultKeyValueDiffer.prototype._forEach = function (obj, fn) {\n            if (obj instanceof Map) {\n                obj.forEach(fn);\n            }\n            else {\n                StringMapWrapper.forEach(obj, fn);\n            }\n        };\n        return DefaultKeyValueDiffer;\n    }());\n    /**\n     * @stable\n     */\n    var KeyValueChangeRecord = (function () {\n        function KeyValueChangeRecord(key) {\n            this.key = key;\n            this.previousValue = null;\n            this.currentValue = null;\n            /** @internal */\n            this._nextPrevious = null;\n            /** @internal */\n            this._next = null;\n            /** @internal */\n            this._nextAdded = null;\n            /** @internal */\n            this._nextRemoved = null;\n            /** @internal */\n            this._prevRemoved = null;\n            /** @internal */\n            this._nextChanged = null;\n        }\n        KeyValueChangeRecord.prototype.toString = function () {\n            return looseIdentical(this.previousValue, this.currentValue) ?\n                stringify(this.key) :\n                (stringify(this.key) + '[' + stringify(this.previousValue) + '->' +\n                    stringify(this.currentValue) + ']');\n        };\n        return KeyValueChangeRecord;\n    }());\n\n    /**\n     * A repository of different iterable diffing strategies used by NgFor, NgClass, and others.\n     * @stable\n     */\n    var IterableDiffers = (function () {\n        function IterableDiffers(factories) {\n            this.factories = factories;\n        }\n        IterableDiffers.create = function (factories, parent) {\n            if (isPresent(parent)) {\n                var copied = ListWrapper.clone(parent.factories);\n                factories = factories.concat(copied);\n                return new IterableDiffers(factories);\n            }\n            else {\n                return new IterableDiffers(factories);\n            }\n        };\n        /**\n         * Takes an array of {@link IterableDifferFactory} and returns a provider used to extend the\n         * inherited {@link IterableDiffers} instance with the provided factories and return a new\n         * {@link IterableDiffers} instance.\n         *\n         * The following example shows how to extend an existing list of factories,\n               * which will only be applied to the injector for this component and its children.\n               * This step is all that's required to make a new {@link IterableDiffer} available.\n         *\n         * ### Example\n         *\n         * ```\n         * @Component({\n         *   viewProviders: [\n         *     IterableDiffers.extend([new ImmutableListDiffer()])\n         *   ]\n         * })\n         * ```\n         */\n        IterableDiffers.extend = function (factories) {\n            return {\n                provide: IterableDiffers,\n                useFactory: function (parent) {\n                    if (isBlank(parent)) {\n                        // Typically would occur when calling IterableDiffers.extend inside of dependencies passed\n                        // to\n                        // bootstrap(), which would override default pipes instead of extending them.\n                        throw new Error('Cannot extend IterableDiffers without a parent injector');\n                    }\n                    return IterableDiffers.create(factories, parent);\n                },\n                // Dependency technically isn't optional, but we can provide a better error message this way.\n                deps: [[IterableDiffers, new SkipSelf(), new Optional()]]\n            };\n        };\n        IterableDiffers.prototype.find = function (iterable) {\n            var factory = this.factories.find(function (f) { return f.supports(iterable); });\n            if (isPresent(factory)) {\n                return factory;\n            }\n            else {\n                throw new Error(\"Cannot find a differ supporting object '\" + iterable + \"' of type '\" + getTypeNameForDebugging(iterable) + \"'\");\n            }\n        };\n        return IterableDiffers;\n    }());\n\n    /**\n     * A repository of different Map diffing strategies used by NgClass, NgStyle, and others.\n     * @stable\n     */\n    var KeyValueDiffers = (function () {\n        function KeyValueDiffers(factories) {\n            this.factories = factories;\n        }\n        KeyValueDiffers.create = function (factories, parent) {\n            if (isPresent(parent)) {\n                var copied = ListWrapper.clone(parent.factories);\n                factories = factories.concat(copied);\n                return new KeyValueDiffers(factories);\n            }\n            else {\n                return new KeyValueDiffers(factories);\n            }\n        };\n        /**\n         * Takes an array of {@link KeyValueDifferFactory} and returns a provider used to extend the\n         * inherited {@link KeyValueDiffers} instance with the provided factories and return a new\n         * {@link KeyValueDiffers} instance.\n         *\n         * The following example shows how to extend an existing list of factories,\n               * which will only be applied to the injector for this component and its children.\n               * This step is all that's required to make a new {@link KeyValueDiffer} available.\n         *\n         * ### Example\n         *\n         * ```\n         * @Component({\n         *   viewProviders: [\n         *     KeyValueDiffers.extend([new ImmutableMapDiffer()])\n         *   ]\n         * })\n         * ```\n         */\n        KeyValueDiffers.extend = function (factories) {\n            return {\n                provide: KeyValueDiffers,\n                useFactory: function (parent) {\n                    if (isBlank(parent)) {\n                        // Typically would occur when calling KeyValueDiffers.extend inside of dependencies passed\n                        // to\n                        // bootstrap(), which would override default pipes instead of extending them.\n                        throw new Error('Cannot extend KeyValueDiffers without a parent injector');\n                    }\n                    return KeyValueDiffers.create(factories, parent);\n                },\n                // Dependency technically isn't optional, but we can provide a better error message this way.\n                deps: [[KeyValueDiffers, new SkipSelf(), new Optional()]]\n            };\n        };\n        KeyValueDiffers.prototype.find = function (kv) {\n            var factory = this.factories.find(function (f) { return f.supports(kv); });\n            if (isPresent(factory)) {\n                return factory;\n            }\n            else {\n                throw new Error(\"Cannot find a differ supporting object '\" + kv + \"'\");\n            }\n        };\n        return KeyValueDiffers;\n    }());\n\n    var UNINITIALIZED = {\n        toString: function () { return 'CD_INIT_VALUE'; }\n    };\n    function devModeEqual(a, b) {\n        if (isListLikeIterable(a) && isListLikeIterable(b)) {\n            return areIterablesEqual(a, b, devModeEqual);\n        }\n        else if (!isListLikeIterable(a) && !isPrimitive(a) && !isListLikeIterable(b) && !isPrimitive(b)) {\n            return true;\n        }\n        else {\n            return looseIdentical(a, b);\n        }\n    }\n    /**\n     * Indicates that the result of a {@link Pipe} transformation has changed even though the\n     * reference\n     * has not changed.\n     *\n     * The wrapped value will be unwrapped by change detection, and the unwrapped value will be stored.\n     *\n     * Example:\n     *\n     * ```\n     * if (this._latestValue === this._latestReturnedValue) {\n     *    return this._latestReturnedValue;\n     *  } else {\n     *    this._latestReturnedValue = this._latestValue;\n     *    return WrappedValue.wrap(this._latestValue); // this will force update\n     *  }\n     * ```\n     * @stable\n     */\n    var WrappedValue = (function () {\n        function WrappedValue(wrapped) {\n            this.wrapped = wrapped;\n        }\n        WrappedValue.wrap = function (value) { return new WrappedValue(value); };\n        return WrappedValue;\n    }());\n    /**\n     * Helper class for unwrapping WrappedValue s\n     */\n    var ValueUnwrapper = (function () {\n        function ValueUnwrapper() {\n            this.hasWrappedValue = false;\n        }\n        ValueUnwrapper.prototype.unwrap = function (value) {\n            if (value instanceof WrappedValue) {\n                this.hasWrappedValue = true;\n                return value.wrapped;\n            }\n            return value;\n        };\n        ValueUnwrapper.prototype.reset = function () { this.hasWrappedValue = false; };\n        return ValueUnwrapper;\n    }());\n    /**\n     * Represents a basic change from a previous to a new value.\n     * @stable\n     */\n    var SimpleChange = (function () {\n        function SimpleChange(previousValue, currentValue) {\n            this.previousValue = previousValue;\n            this.currentValue = currentValue;\n        }\n        /**\n         * Check whether the new value is the first value assigned.\n         */\n        SimpleChange.prototype.isFirstChange = function () { return this.previousValue === UNINITIALIZED; };\n        return SimpleChange;\n    }());\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * @stable\n     */\n    var ChangeDetectorRef = (function () {\n        function ChangeDetectorRef() {\n        }\n        return ChangeDetectorRef;\n    }());\n\n    /**\n     * Structural diffing for `Object`s and `Map`s.\n     */\n    var keyValDiff = [new DefaultKeyValueDifferFactory()];\n    /**\n     * Structural diffing for `Iterable` types such as `Array`s.\n     */\n    var iterableDiff = [new DefaultIterableDifferFactory()];\n    var defaultIterableDiffers = new IterableDiffers(iterableDiff);\n    var defaultKeyValueDiffers = new KeyValueDiffers(keyValDiff);\n\n    /**\n     * @experimental\n     */\n    // TODO (matsko): add typing for the animation function\n    var RenderComponentType = (function () {\n        function RenderComponentType(id, templateUrl, slotCount, encapsulation, styles, animations) {\n            this.id = id;\n            this.templateUrl = templateUrl;\n            this.slotCount = slotCount;\n            this.encapsulation = encapsulation;\n            this.styles = styles;\n            this.animations = animations;\n        }\n        return RenderComponentType;\n    }());\n    var RenderDebugInfo = (function () {\n        function RenderDebugInfo() {\n        }\n        Object.defineProperty(RenderDebugInfo.prototype, \"injector\", {\n            get: function () { return unimplemented(); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(RenderDebugInfo.prototype, \"component\", {\n            get: function () { return unimplemented(); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(RenderDebugInfo.prototype, \"providerTokens\", {\n            get: function () { return unimplemented(); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(RenderDebugInfo.prototype, \"references\", {\n            get: function () { return unimplemented(); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(RenderDebugInfo.prototype, \"context\", {\n            get: function () { return unimplemented(); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(RenderDebugInfo.prototype, \"source\", {\n            get: function () { return unimplemented(); },\n            enumerable: true,\n            configurable: true\n        });\n        return RenderDebugInfo;\n    }());\n    /**\n     * @experimental\n     */\n    var Renderer = (function () {\n        function Renderer() {\n        }\n        return Renderer;\n    }());\n    /**\n     * Injectable service that provides a low-level interface for modifying the UI.\n     *\n     * Use this service to bypass Angular's templating and make custom UI changes that can't be\n     * expressed declaratively. For example if you need to set a property or an attribute whose name is\n     * not statically known, use {@link #setElementProperty} or {@link #setElementAttribute}\n     * respectively.\n     *\n     * If you are implementing a custom renderer, you must implement this interface.\n     *\n     * The default Renderer implementation is `DomRenderer`. Also available is `WebWorkerRenderer`.\n     * @experimental\n     */\n    var RootRenderer = (function () {\n        function RootRenderer() {\n        }\n        return RootRenderer;\n    }());\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * A SecurityContext marks a location that has dangerous security implications, e.g. a DOM property\n     * like `innerHTML` that could cause Cross Site Scripting (XSS) security bugs when improperly\n     * handled.\n     *\n     * See DomSanitizer for more details on security in Angular applications.\n     *\n     * @stable\n     */\n    exports.SecurityContext;\n    (function (SecurityContext) {\n        SecurityContext[SecurityContext[\"NONE\"] = 0] = \"NONE\";\n        SecurityContext[SecurityContext[\"HTML\"] = 1] = \"HTML\";\n        SecurityContext[SecurityContext[\"STYLE\"] = 2] = \"STYLE\";\n        SecurityContext[SecurityContext[\"SCRIPT\"] = 3] = \"SCRIPT\";\n        SecurityContext[SecurityContext[\"URL\"] = 4] = \"URL\";\n        SecurityContext[SecurityContext[\"RESOURCE_URL\"] = 5] = \"RESOURCE_URL\";\n    })(exports.SecurityContext || (exports.SecurityContext = {}));\n    /**\n     * Sanitizer is used by the views to sanitize potentially dangerous values.\n     *\n     * @stable\n     */\n    var Sanitizer = (function () {\n        function Sanitizer() {\n        }\n        return Sanitizer;\n    }());\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * A wrapper around a native element inside of a View.\n     *\n     * An `ElementRef` is backed by a render-specific element. In the browser, this is usually a DOM\n     * element.\n     *\n     * @security Permitting direct access to the DOM can make your application more vulnerable to\n     * XSS attacks. Carefully review any use of `ElementRef` in your code. For more detail, see the\n     * [Security Guide](http://g.co/ng/security).\n     *\n     * @stable\n     */\n    // Note: We don't expose things like `Injector`, `ViewContainer`, ... here,\n    // i.e. users have to ask for what they need. With that, we can build better analysis tools\n    // and could do better codegen in the future.\n    var ElementRef = (function () {\n        function ElementRef(nativeElement) {\n            this.nativeElement = nativeElement;\n        }\n        return ElementRef;\n    }());\n\n    var trace;\n    var events;\n    function detectWTF() {\n        var wtf = global$1['wtf'];\n        if (wtf) {\n            trace = wtf['trace'];\n            if (trace) {\n                events = trace['events'];\n                return true;\n            }\n        }\n        return false;\n    }\n    function createScope(signature, flags) {\n        if (flags === void 0) { flags = null; }\n        return events.createScope(signature, flags);\n    }\n    function leave(scope, returnValue) {\n        trace.leaveScope(scope, returnValue);\n        return returnValue;\n    }\n    function startTimeRange(rangeType, action) {\n        return trace.beginTimeRange(rangeType, action);\n    }\n    function endTimeRange(range) {\n        trace.endTimeRange(range);\n    }\n\n    /**\n     * True if WTF is enabled.\n     */\n    var wtfEnabled = detectWTF();\n    function noopScope(arg0, arg1) {\n        return null;\n    }\n    /**\n     * Create trace scope.\n     *\n     * Scopes must be strictly nested and are analogous to stack frames, but\n     * do not have to follow the stack frames. Instead it is recommended that they follow logical\n     * nesting. You may want to use\n     * [Event\n     * Signatures](http://google.github.io/tracing-framework/instrumenting-code.html#custom-events)\n     * as they are defined in WTF.\n     *\n     * Used to mark scope entry. The return value is used to leave the scope.\n     *\n     *     var myScope = wtfCreateScope('MyClass#myMethod(ascii someVal)');\n     *\n     *     someMethod() {\n     *        var s = myScope('Foo'); // 'Foo' gets stored in tracing UI\n     *        // DO SOME WORK HERE\n     *        return wtfLeave(s, 123); // Return value 123\n     *     }\n     *\n     * Note, adding try-finally block around the work to ensure that `wtfLeave` gets called can\n     * negatively impact the performance of your application. For this reason we recommend that\n     * you don't add them to ensure that `wtfLeave` gets called. In production `wtfLeave` is a noop and\n     * so try-finally block has no value. When debugging perf issues, skipping `wtfLeave`, do to\n     * exception, will produce incorrect trace, but presence of exception signifies logic error which\n     * needs to be fixed before the app should be profiled. Add try-finally only when you expect that\n     * an exception is expected during normal execution while profiling.\n     *\n     * @experimental\n     */\n    var wtfCreateScope = wtfEnabled ? createScope : function (signature, flags) { return noopScope; };\n    /**\n     * Used to mark end of Scope.\n     *\n     * - `scope` to end.\n     * - `returnValue` (optional) to be passed to the WTF.\n     *\n     * Returns the `returnValue for easy chaining.\n     * @experimental\n     */\n    var wtfLeave = wtfEnabled ? leave : function (s, r) { return r; };\n    /**\n     * Used to mark Async start. Async are similar to scope but they don't have to be strictly nested.\n     * The return value is used in the call to [endAsync]. Async ranges only work if WTF has been\n     * enabled.\n     *\n     *     someMethod() {\n     *        var s = wtfStartTimeRange('HTTP:GET', 'some.url');\n     *        var future = new Future.delay(5).then((_) {\n     *          wtfEndTimeRange(s);\n     *        });\n     *     }\n     * @experimental\n     */\n    var wtfStartTimeRange = wtfEnabled ? startTimeRange : function (rangeType, action) { return null; };\n    /**\n     * Ends a async time range operation.\n     * [range] is the return value from [wtfStartTimeRange] Async ranges only work if WTF has been\n     * enabled.\n     * @experimental\n     */\n    var wtfEndTimeRange = wtfEnabled ? endTimeRange : function (r) { return null; };\n\n    /**\n     * Represents a container where one or more Views can be attached.\n     *\n     * The container can contain two kinds of Views. Host Views, created by instantiating a\n     * {@link Component} via {@link #createComponent}, and Embedded Views, created by instantiating an\n     * {@link TemplateRef Embedded Template} via {@link #createEmbeddedView}.\n     *\n     * The location of the View Container within the containing View is specified by the Anchor\n     * `element`. Each View Container can have only one Anchor Element and each Anchor Element can only\n     * have a single View Container.\n     *\n     * Root elements of Views attached to this container become siblings of the Anchor Element in\n     * the Rendered View.\n     *\n     * To access a `ViewContainerRef` of an Element, you can either place a {@link Directive} injected\n     * with `ViewContainerRef` on the Element, or you obtain it via a {@link ViewChild} query.\n     * @stable\n     */\n    var ViewContainerRef = (function () {\n        function ViewContainerRef() {\n        }\n        Object.defineProperty(ViewContainerRef.prototype, \"element\", {\n            /**\n             * Anchor element that specifies the location of this container in the containing View.\n             * <!-- TODO: rename to anchorElement -->\n             */\n            get: function () { return unimplemented(); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ViewContainerRef.prototype, \"injector\", {\n            get: function () { return unimplemented(); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ViewContainerRef.prototype, \"parentInjector\", {\n            get: function () { return unimplemented(); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ViewContainerRef.prototype, \"length\", {\n            /**\n             * Returns the number of Views currently attached to this container.\n             */\n            get: function () { return unimplemented(); },\n            enumerable: true,\n            configurable: true\n        });\n        ;\n        return ViewContainerRef;\n    }());\n    var ViewContainerRef_ = (function () {\n        function ViewContainerRef_(_element) {\n            this._element = _element;\n            /** @internal */\n            this._createComponentInContainerScope = wtfCreateScope('ViewContainerRef#createComponent()');\n            /** @internal */\n            this._insertScope = wtfCreateScope('ViewContainerRef#insert()');\n            /** @internal */\n            this._removeScope = wtfCreateScope('ViewContainerRef#remove()');\n            /** @internal */\n            this._detachScope = wtfCreateScope('ViewContainerRef#detach()');\n        }\n        ViewContainerRef_.prototype.get = function (index) { return this._element.nestedViews[index].ref; };\n        Object.defineProperty(ViewContainerRef_.prototype, \"length\", {\n            get: function () {\n                var views = this._element.nestedViews;\n                return isPresent(views) ? views.length : 0;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ViewContainerRef_.prototype, \"element\", {\n            get: function () { return this._element.elementRef; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ViewContainerRef_.prototype, \"injector\", {\n            get: function () { return this._element.injector; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ViewContainerRef_.prototype, \"parentInjector\", {\n            get: function () { return this._element.parentInjector; },\n            enumerable: true,\n            configurable: true\n        });\n        // TODO(rado): profile and decide whether bounds checks should be added\n        // to the methods below.\n        ViewContainerRef_.prototype.createEmbeddedView = function (templateRef, context, index) {\n            if (context === void 0) { context = null; }\n            if (index === void 0) { index = -1; }\n            var viewRef = templateRef.createEmbeddedView(context);\n            this.insert(viewRef, index);\n            return viewRef;\n        };\n        ViewContainerRef_.prototype.createComponent = function (componentFactory, index, injector, projectableNodes) {\n            if (index === void 0) { index = -1; }\n            if (injector === void 0) { injector = null; }\n            if (projectableNodes === void 0) { projectableNodes = null; }\n            var s = this._createComponentInContainerScope();\n            var contextInjector = isPresent(injector) ? injector : this._element.parentInjector;\n            var componentRef = componentFactory.create(contextInjector, projectableNodes);\n            this.insert(componentRef.hostView, index);\n            return wtfLeave(s, componentRef);\n        };\n        // TODO(i): refactor insert+remove into move\n        ViewContainerRef_.prototype.insert = function (viewRef, index) {\n            if (index === void 0) { index = -1; }\n            var s = this._insertScope();\n            if (index == -1)\n                index = this.length;\n            var viewRef_ = viewRef;\n            this._element.attachView(viewRef_.internalView, index);\n            return wtfLeave(s, viewRef_);\n        };\n        ViewContainerRef_.prototype.move = function (viewRef, currentIndex) {\n            var s = this._insertScope();\n            if (currentIndex == -1)\n                return;\n            var viewRef_ = viewRef;\n            this._element.moveView(viewRef_.internalView, currentIndex);\n            return wtfLeave(s, viewRef_);\n        };\n        ViewContainerRef_.prototype.indexOf = function (viewRef) {\n            return ListWrapper.indexOf(this._element.nestedViews, viewRef.internalView);\n        };\n        // TODO(i): rename to destroy\n        ViewContainerRef_.prototype.remove = function (index) {\n            if (index === void 0) { index = -1; }\n            var s = this._removeScope();\n            if (index == -1)\n                index = this.length - 1;\n            var view = this._element.detachView(index);\n            view.destroy();\n            // view is intentionally not returned to the client.\n            wtfLeave(s);\n        };\n        // TODO(i): refactor insert+remove into move\n        ViewContainerRef_.prototype.detach = function (index) {\n            if (index === void 0) { index = -1; }\n            var s = this._detachScope();\n            if (index == -1)\n                index = this.length - 1;\n            var view = this._element.detachView(index);\n            return wtfLeave(s, view.ref);\n        };\n        ViewContainerRef_.prototype.clear = function () {\n            for (var i = this.length - 1; i >= 0; i--) {\n                this.remove(i);\n            }\n        };\n        return ViewContainerRef_;\n    }());\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var ViewType;\n    (function (ViewType) {\n        // A view that contains the host element with bound component directive.\n        // Contains a COMPONENT view\n        ViewType[ViewType[\"HOST\"] = 0] = \"HOST\";\n        // The view of the component\n        // Can contain 0 to n EMBEDDED views\n        ViewType[ViewType[\"COMPONENT\"] = 1] = \"COMPONENT\";\n        // A view that is embedded into another View via a <template> element\n        // inside of a COMPONENT view\n        ViewType[ViewType[\"EMBEDDED\"] = 2] = \"EMBEDDED\";\n    })(ViewType || (ViewType = {}));\n\n    /**\n     * An AppElement is created for elements that have a ViewContainerRef,\n     * a nested component or a <template> element to keep data around\n     * that is needed for later instantiations.\n     */\n    var AppElement = (function () {\n        function AppElement(index, parentIndex, parentView, nativeElement) {\n            this.index = index;\n            this.parentIndex = parentIndex;\n            this.parentView = parentView;\n            this.nativeElement = nativeElement;\n            this.nestedViews = null;\n            this.componentView = null;\n        }\n        Object.defineProperty(AppElement.prototype, \"elementRef\", {\n            get: function () { return new ElementRef(this.nativeElement); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AppElement.prototype, \"vcRef\", {\n            get: function () { return new ViewContainerRef_(this); },\n            enumerable: true,\n            configurable: true\n        });\n        AppElement.prototype.initComponent = function (component, componentConstructorViewQueries, view) {\n            this.component = component;\n            this.componentConstructorViewQueries = componentConstructorViewQueries;\n            this.componentView = view;\n        };\n        Object.defineProperty(AppElement.prototype, \"parentInjector\", {\n            get: function () { return this.parentView.injector(this.parentIndex); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AppElement.prototype, \"injector\", {\n            get: function () { return this.parentView.injector(this.index); },\n            enumerable: true,\n            configurable: true\n        });\n        AppElement.prototype.mapNestedViews = function (nestedViewClass, callback) {\n            var result = [];\n            if (isPresent(this.nestedViews)) {\n                this.nestedViews.forEach(function (nestedView) {\n                    if (nestedView.clazz === nestedViewClass) {\n                        result.push(callback(nestedView));\n                    }\n                });\n            }\n            return result;\n        };\n        AppElement.prototype.moveView = function (view, currentIndex) {\n            var previousIndex = this.nestedViews.indexOf(view);\n            if (view.type === ViewType.COMPONENT) {\n                throw new Error(\"Component views can't be moved!\");\n            }\n            var nestedViews = this.nestedViews;\n            if (nestedViews == null) {\n                nestedViews = [];\n                this.nestedViews = nestedViews;\n            }\n            ListWrapper.removeAt(nestedViews, previousIndex);\n            ListWrapper.insert(nestedViews, currentIndex, view);\n            var refRenderNode;\n            if (currentIndex > 0) {\n                var prevView = nestedViews[currentIndex - 1];\n                refRenderNode = prevView.lastRootNode;\n            }\n            else {\n                refRenderNode = this.nativeElement;\n            }\n            if (isPresent(refRenderNode)) {\n                view.renderer.attachViewAfter(refRenderNode, view.flatRootNodes);\n            }\n            view.markContentChildAsMoved(this);\n        };\n        AppElement.prototype.attachView = function (view, viewIndex) {\n            if (view.type === ViewType.COMPONENT) {\n                throw new Error(\"Component views can't be moved!\");\n            }\n            var nestedViews = this.nestedViews;\n            if (nestedViews == null) {\n                nestedViews = [];\n                this.nestedViews = nestedViews;\n            }\n            ListWrapper.insert(nestedViews, viewIndex, view);\n            var refRenderNode;\n            if (viewIndex > 0) {\n                var prevView = nestedViews[viewIndex - 1];\n                refRenderNode = prevView.lastRootNode;\n            }\n            else {\n                refRenderNode = this.nativeElement;\n            }\n            if (isPresent(refRenderNode)) {\n                view.renderer.attachViewAfter(refRenderNode, view.flatRootNodes);\n            }\n            view.addToContentChildren(this);\n        };\n        AppElement.prototype.detachView = function (viewIndex) {\n            var view = ListWrapper.removeAt(this.nestedViews, viewIndex);\n            if (view.type === ViewType.COMPONENT) {\n                throw new Error(\"Component views can't be moved!\");\n            }\n            view.detach();\n            view.removeFromContentChildren(this);\n            return view;\n        };\n        return AppElement;\n    }());\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$6 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    /**\n     * An error thrown if application changes model breaking the top-down data flow.\n     *\n     * This exception is only thrown in dev mode.\n     *\n     * <!-- TODO: Add a link once the dev mode option is configurable -->\n     *\n     * ### Example\n     *\n     * ```typescript\n     * @Component({\n     *   selector: 'parent',\n     *   template: `\n     *     <child [prop]=\"parentProp\"></child>\n     *   `,\n     *   directives: [forwardRef(() => Child)]\n     * })\n     * class Parent {\n     *   parentProp = \"init\";\n     * }\n     *\n     * @Directive({selector: 'child', inputs: ['prop']})\n     * class Child {\n     *   constructor(public parent: Parent) {}\n     *\n     *   set prop(v) {\n     *     // this updates the parent property, which is disallowed during change detection\n     *     // this will result in ExpressionChangedAfterItHasBeenCheckedError\n     *     this.parent.parentProp = \"updated\";\n     *   }\n     * }\n     * ```\n     * @stable\n     */\n    var ExpressionChangedAfterItHasBeenCheckedError = (function (_super) {\n        __extends$6(ExpressionChangedAfterItHasBeenCheckedError, _super);\n        function ExpressionChangedAfterItHasBeenCheckedError(oldValue, currValue) {\n            var msg = \"Expression has changed after it was checked. Previous value: '\" + oldValue + \"'. Current value: '\" + currValue + \"'.\";\n            if (oldValue === UNINITIALIZED) {\n                msg +=\n                    \" It seems like the view has been created after its parent and its children have been dirty checked.\" +\n                        \" Has it been created in a change detection hook ?\";\n            }\n            _super.call(this, msg);\n        }\n        return ExpressionChangedAfterItHasBeenCheckedError;\n    }(BaseError));\n    /**\n     * Thrown when an exception was raised during view creation, change detection or destruction.\n     *\n     * This error wraps the original exception to attach additional contextual information that can\n     * be useful for debugging.\n     * @stable\n     */\n    var ViewWrappedError = (function (_super) {\n        __extends$6(ViewWrappedError, _super);\n        function ViewWrappedError(originalError, context) {\n            _super.call(this, \"Error in \" + context.source, originalError);\n            this.context = context;\n        }\n        return ViewWrappedError;\n    }(WrappedError));\n    /**\n     * Thrown when a destroyed view is used.\n     *\n     * This error indicates a bug in the framework.\n     *\n     * This is an internal Angular error.\n     * @stable\n     */\n    var ViewDestroyedError = (function (_super) {\n        __extends$6(ViewDestroyedError, _super);\n        function ViewDestroyedError(details) {\n            _super.call(this, \"Attempt to use a destroyed view: \" + details);\n        }\n        return ViewDestroyedError;\n    }(BaseError));\n\n    var ViewUtils = (function () {\n        function ViewUtils(_renderer, _appId, sanitizer) {\n            this._renderer = _renderer;\n            this._appId = _appId;\n            this._nextCompTypeId = 0;\n            this.sanitizer = sanitizer;\n        }\n        /**\n         * Used by the generated code\n         */\n        // TODO (matsko): add typing for the animation function\n        ViewUtils.prototype.createRenderComponentType = function (templateUrl, slotCount, encapsulation, styles, animations) {\n            return new RenderComponentType(this._appId + \"-\" + this._nextCompTypeId++, templateUrl, slotCount, encapsulation, styles, animations);\n        };\n        /** @internal */\n        ViewUtils.prototype.renderComponent = function (renderComponentType) {\n            return this._renderer.renderComponent(renderComponentType);\n        };\n        ViewUtils.decorators = [\n            { type: Injectable },\n        ];\n        /** @nocollapse */\n        ViewUtils.ctorParameters = [\n            { type: RootRenderer, },\n            { type: undefined, decorators: [{ type: Inject, args: [APP_ID,] },] },\n            { type: Sanitizer, },\n        ];\n        return ViewUtils;\n    }());\n    function flattenNestedViewRenderNodes(nodes) {\n        return _flattenNestedViewRenderNodes(nodes, []);\n    }\n    function _flattenNestedViewRenderNodes(nodes, renderNodes) {\n        for (var i = 0; i < nodes.length; i++) {\n            var node = nodes[i];\n            if (node instanceof AppElement) {\n                var appEl = node;\n                renderNodes.push(appEl.nativeElement);\n                if (isPresent(appEl.nestedViews)) {\n                    for (var k = 0; k < appEl.nestedViews.length; k++) {\n                        _flattenNestedViewRenderNodes(appEl.nestedViews[k].rootNodesOrAppElements, renderNodes);\n                    }\n                }\n            }\n            else {\n                renderNodes.push(node);\n            }\n        }\n        return renderNodes;\n    }\n    var EMPTY_ARR = [];\n    function ensureSlotCount(projectableNodes, expectedSlotCount) {\n        var res;\n        if (isBlank(projectableNodes)) {\n            res = EMPTY_ARR;\n        }\n        else if (projectableNodes.length < expectedSlotCount) {\n            var givenSlotCount = projectableNodes.length;\n            res = new Array(expectedSlotCount);\n            for (var i = 0; i < expectedSlotCount; i++) {\n                res[i] = (i < givenSlotCount) ? projectableNodes[i] : EMPTY_ARR;\n            }\n        }\n        else {\n            res = projectableNodes;\n        }\n        return res;\n    }\n    var MAX_INTERPOLATION_VALUES = 9;\n    function interpolate(valueCount, c0, a1, c1, a2, c2, a3, c3, a4, c4, a5, c5, a6, c6, a7, c7, a8, c8, a9, c9) {\n        switch (valueCount) {\n            case 1:\n                return c0 + _toStringWithNull(a1) + c1;\n            case 2:\n                return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2;\n            case 3:\n                return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +\n                    c3;\n            case 4:\n                return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +\n                    c3 + _toStringWithNull(a4) + c4;\n            case 5:\n                return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +\n                    c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5;\n            case 6:\n                return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +\n                    c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) + c6;\n            case 7:\n                return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +\n                    c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) +\n                    c6 + _toStringWithNull(a7) + c7;\n            case 8:\n                return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +\n                    c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) +\n                    c6 + _toStringWithNull(a7) + c7 + _toStringWithNull(a8) + c8;\n            case 9:\n                return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +\n                    c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) +\n                    c6 + _toStringWithNull(a7) + c7 + _toStringWithNull(a8) + c8 + _toStringWithNull(a9) + c9;\n            default:\n                throw new Error(\"Does not support more than 9 expressions\");\n        }\n    }\n    function _toStringWithNull(v) {\n        return v != null ? v.toString() : '';\n    }\n    function checkBinding(throwOnChange, oldValue, newValue) {\n        if (throwOnChange) {\n            if (!devModeEqual(oldValue, newValue)) {\n                throw new ExpressionChangedAfterItHasBeenCheckedError(oldValue, newValue);\n            }\n            return false;\n        }\n        else {\n            return !looseIdentical(oldValue, newValue);\n        }\n    }\n    function castByValue(input, value) {\n        return input;\n    }\n    var EMPTY_ARRAY = [];\n    var EMPTY_MAP = {};\n    function pureProxy1(fn) {\n        var result;\n        var v0 = UNINITIALIZED;\n        return function (p0) {\n            if (!looseIdentical(v0, p0)) {\n                v0 = p0;\n                result = fn(p0);\n            }\n            return result;\n        };\n    }\n    function pureProxy2(fn) {\n        var result;\n        var v0 = UNINITIALIZED;\n        var v1 = UNINITIALIZED;\n        return function (p0, p1) {\n            if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1)) {\n                v0 = p0;\n                v1 = p1;\n                result = fn(p0, p1);\n            }\n            return result;\n        };\n    }\n    function pureProxy3(fn) {\n        var result;\n        var v0 = UNINITIALIZED;\n        var v1 = UNINITIALIZED;\n        var v2 = UNINITIALIZED;\n        return function (p0, p1, p2) {\n            if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1) || !looseIdentical(v2, p2)) {\n                v0 = p0;\n                v1 = p1;\n                v2 = p2;\n                result = fn(p0, p1, p2);\n            }\n            return result;\n        };\n    }\n    function pureProxy4(fn) {\n        var result;\n        var v0, v1, v2, v3;\n        v0 = v1 = v2 = v3 = UNINITIALIZED;\n        return function (p0, p1, p2, p3) {\n            if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1) || !looseIdentical(v2, p2) ||\n                !looseIdentical(v3, p3)) {\n                v0 = p0;\n                v1 = p1;\n                v2 = p2;\n                v3 = p3;\n                result = fn(p0, p1, p2, p3);\n            }\n            return result;\n        };\n    }\n    function pureProxy5(fn) {\n        var result;\n        var v0, v1, v2, v3, v4;\n        v0 = v1 = v2 = v3 = v4 = UNINITIALIZED;\n        return function (p0, p1, p2, p3, p4) {\n            if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1) || !looseIdentical(v2, p2) ||\n                !looseIdentical(v3, p3) || !looseIdentical(v4, p4)) {\n                v0 = p0;\n                v1 = p1;\n                v2 = p2;\n                v3 = p3;\n                v4 = p4;\n                result = fn(p0, p1, p2, p3, p4);\n            }\n            return result;\n        };\n    }\n    function pureProxy6(fn) {\n        var result;\n        var v0, v1, v2, v3, v4, v5;\n        v0 = v1 = v2 = v3 = v4 = v5 = UNINITIALIZED;\n        return function (p0, p1, p2, p3, p4, p5) {\n            if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1) || !looseIdentical(v2, p2) ||\n                !looseIdentical(v3, p3) || !looseIdentical(v4, p4) || !looseIdentical(v5, p5)) {\n                v0 = p0;\n                v1 = p1;\n                v2 = p2;\n                v3 = p3;\n                v4 = p4;\n                v5 = p5;\n                result = fn(p0, p1, p2, p3, p4, p5);\n            }\n            return result;\n        };\n    }\n    function pureProxy7(fn) {\n        var result;\n        var v0, v1, v2, v3, v4, v5, v6;\n        v0 = v1 = v2 = v3 = v4 = v5 = v6 = UNINITIALIZED;\n        return function (p0, p1, p2, p3, p4, p5, p6) {\n            if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1) || !looseIdentical(v2, p2) ||\n                !looseIdentical(v3, p3) || !looseIdentical(v4, p4) || !looseIdentical(v5, p5) ||\n                !looseIdentical(v6, p6)) {\n                v0 = p0;\n                v1 = p1;\n                v2 = p2;\n                v3 = p3;\n                v4 = p4;\n                v5 = p5;\n                v6 = p6;\n                result = fn(p0, p1, p2, p3, p4, p5, p6);\n            }\n            return result;\n        };\n    }\n    function pureProxy8(fn) {\n        var result;\n        var v0, v1, v2, v3, v4, v5, v6, v7;\n        v0 = v1 = v2 = v3 = v4 = v5 = v6 = v7 = UNINITIALIZED;\n        return function (p0, p1, p2, p3, p4, p5, p6, p7) {\n            if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1) || !looseIdentical(v2, p2) ||\n                !looseIdentical(v3, p3) || !looseIdentical(v4, p4) || !looseIdentical(v5, p5) ||\n                !looseIdentical(v6, p6) || !looseIdentical(v7, p7)) {\n                v0 = p0;\n                v1 = p1;\n                v2 = p2;\n                v3 = p3;\n                v4 = p4;\n                v5 = p5;\n                v6 = p6;\n                v7 = p7;\n                result = fn(p0, p1, p2, p3, p4, p5, p6, p7);\n            }\n            return result;\n        };\n    }\n    function pureProxy9(fn) {\n        var result;\n        var v0, v1, v2, v3, v4, v5, v6, v7, v8;\n        v0 = v1 = v2 = v3 = v4 = v5 = v6 = v7 = v8 = UNINITIALIZED;\n        return function (p0, p1, p2, p3, p4, p5, p6, p7, p8) {\n            if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1) || !looseIdentical(v2, p2) ||\n                !looseIdentical(v3, p3) || !looseIdentical(v4, p4) || !looseIdentical(v5, p5) ||\n                !looseIdentical(v6, p6) || !looseIdentical(v7, p7) || !looseIdentical(v8, p8)) {\n                v0 = p0;\n                v1 = p1;\n                v2 = p2;\n                v3 = p3;\n                v4 = p4;\n                v5 = p5;\n                v6 = p6;\n                v7 = p7;\n                v8 = p8;\n                result = fn(p0, p1, p2, p3, p4, p5, p6, p7, p8);\n            }\n            return result;\n        };\n    }\n    function pureProxy10(fn) {\n        var result;\n        var v0, v1, v2, v3, v4, v5, v6, v7, v8, v9;\n        v0 = v1 = v2 = v3 = v4 = v5 = v6 = v7 = v8 = v9 = UNINITIALIZED;\n        return function (p0, p1, p2, p3, p4, p5, p6, p7, p8, p9) {\n            if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1) || !looseIdentical(v2, p2) ||\n                !looseIdentical(v3, p3) || !looseIdentical(v4, p4) || !looseIdentical(v5, p5) ||\n                !looseIdentical(v6, p6) || !looseIdentical(v7, p7) || !looseIdentical(v8, p8) ||\n                !looseIdentical(v9, p9)) {\n                v0 = p0;\n                v1 = p1;\n                v2 = p2;\n                v3 = p3;\n                v4 = p4;\n                v5 = p5;\n                v6 = p6;\n                v7 = p7;\n                v8 = p8;\n                v9 = p9;\n                result = fn(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);\n            }\n            return result;\n        };\n    }\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$5 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    /**\n     * Represents an instance of a Component created via a {@link ComponentFactory}.\n     *\n     * `ComponentRef` provides access to the Component Instance as well other objects related to this\n     * Component Instance and allows you to destroy the Component Instance via the {@link #destroy}\n     * method.\n     * @stable\n     */\n    var ComponentRef = (function () {\n        function ComponentRef() {\n        }\n        Object.defineProperty(ComponentRef.prototype, \"location\", {\n            /**\n             * Location of the Host Element of this Component Instance.\n             */\n            get: function () { return unimplemented(); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ComponentRef.prototype, \"injector\", {\n            /**\n             * The injector on which the component instance exists.\n             */\n            get: function () { return unimplemented(); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ComponentRef.prototype, \"instance\", {\n            /**\n             * The instance of the Component.\n             */\n            get: function () { return unimplemented(); },\n            enumerable: true,\n            configurable: true\n        });\n        ;\n        Object.defineProperty(ComponentRef.prototype, \"hostView\", {\n            /**\n             * The {@link ViewRef} of the Host View of this Component instance.\n             */\n            get: function () { return unimplemented(); },\n            enumerable: true,\n            configurable: true\n        });\n        ;\n        Object.defineProperty(ComponentRef.prototype, \"changeDetectorRef\", {\n            /**\n             * The {@link ChangeDetectorRef} of the Component instance.\n             */\n            get: function () { return unimplemented(); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ComponentRef.prototype, \"componentType\", {\n            /**\n             * The component type.\n             */\n            get: function () { return unimplemented(); },\n            enumerable: true,\n            configurable: true\n        });\n        return ComponentRef;\n    }());\n    var ComponentRef_ = (function (_super) {\n        __extends$5(ComponentRef_, _super);\n        function ComponentRef_(_hostElement, _componentType) {\n            _super.call(this);\n            this._hostElement = _hostElement;\n            this._componentType = _componentType;\n        }\n        Object.defineProperty(ComponentRef_.prototype, \"location\", {\n            get: function () { return this._hostElement.elementRef; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ComponentRef_.prototype, \"injector\", {\n            get: function () { return this._hostElement.injector; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ComponentRef_.prototype, \"instance\", {\n            get: function () { return this._hostElement.component; },\n            enumerable: true,\n            configurable: true\n        });\n        ;\n        Object.defineProperty(ComponentRef_.prototype, \"hostView\", {\n            get: function () { return this._hostElement.parentView.ref; },\n            enumerable: true,\n            configurable: true\n        });\n        ;\n        Object.defineProperty(ComponentRef_.prototype, \"changeDetectorRef\", {\n            get: function () { return this._hostElement.parentView.ref; },\n            enumerable: true,\n            configurable: true\n        });\n        ;\n        Object.defineProperty(ComponentRef_.prototype, \"componentType\", {\n            get: function () { return this._componentType; },\n            enumerable: true,\n            configurable: true\n        });\n        ComponentRef_.prototype.destroy = function () { this._hostElement.parentView.destroy(); };\n        ComponentRef_.prototype.onDestroy = function (callback) { this.hostView.onDestroy(callback); };\n        return ComponentRef_;\n    }(ComponentRef));\n    /**\n     * @experimental\n     */\n    var EMPTY_CONTEXT = new Object();\n    /**\n     * @stable\n     */\n    var ComponentFactory = (function () {\n        function ComponentFactory(selector, _viewFactory, _componentType) {\n            this.selector = selector;\n            this._viewFactory = _viewFactory;\n            this._componentType = _componentType;\n        }\n        Object.defineProperty(ComponentFactory.prototype, \"componentType\", {\n            get: function () { return this._componentType; },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * Creates a new component.\n         */\n        ComponentFactory.prototype.create = function (injector, projectableNodes, rootSelectorOrNode) {\n            if (projectableNodes === void 0) { projectableNodes = null; }\n            if (rootSelectorOrNode === void 0) { rootSelectorOrNode = null; }\n            var vu = injector.get(ViewUtils);\n            if (isBlank(projectableNodes)) {\n                projectableNodes = [];\n            }\n            // Note: Host views don't need a declarationAppElement!\n            var hostView = this._viewFactory(vu, injector, null);\n            var hostElement = hostView.create(EMPTY_CONTEXT, projectableNodes, rootSelectorOrNode);\n            return new ComponentRef_(hostElement, this._componentType);\n        };\n        return ComponentFactory;\n    }());\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$7 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    /**\n     * @stable\n     */\n    var NoComponentFactoryError = (function (_super) {\n        __extends$7(NoComponentFactoryError, _super);\n        function NoComponentFactoryError(component) {\n            _super.call(this, \"No component factory found for \" + stringify(component));\n            this.component = component;\n        }\n        return NoComponentFactoryError;\n    }(BaseError));\n    var _NullComponentFactoryResolver = (function () {\n        function _NullComponentFactoryResolver() {\n        }\n        _NullComponentFactoryResolver.prototype.resolveComponentFactory = function (component) {\n            throw new NoComponentFactoryError(component);\n        };\n        return _NullComponentFactoryResolver;\n    }());\n    /**\n     * @stable\n     */\n    var ComponentFactoryResolver = (function () {\n        function ComponentFactoryResolver() {\n        }\n        ComponentFactoryResolver.NULL = new _NullComponentFactoryResolver();\n        return ComponentFactoryResolver;\n    }());\n    var CodegenComponentFactoryResolver = (function () {\n        function CodegenComponentFactoryResolver(factories, _parent) {\n            this._parent = _parent;\n            this._factories = new Map();\n            for (var i = 0; i < factories.length; i++) {\n                var factory = factories[i];\n                this._factories.set(factory.componentType, factory);\n            }\n        }\n        CodegenComponentFactoryResolver.prototype.resolveComponentFactory = function (component) {\n            var result = this._factories.get(component);\n            if (!result) {\n                result = this._parent.resolveComponentFactory(component);\n            }\n            return result;\n        };\n        return CodegenComponentFactoryResolver;\n    }());\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$8 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    /**\n     * Use by directives and components to emit custom Events.\n     *\n     * ### Examples\n     *\n     * In the following example, `Zippy` alternatively emits `open` and `close` events when its\n     * title gets clicked:\n     *\n     * ```\n     * @Component({\n     *   selector: 'zippy',\n     *   template: `\n     *   <div class=\"zippy\">\n     *     <div (click)=\"toggle()\">Toggle</div>\n     *     <div [hidden]=\"!visible\">\n     *       <ng-content></ng-content>\n     *     </div>\n     *  </div>`})\n     * export class Zippy {\n     *   visible: boolean = true;\n     *   @Output() open: EventEmitter<any> = new EventEmitter();\n     *   @Output() close: EventEmitter<any> = new EventEmitter();\n     *\n     *   toggle() {\n     *     this.visible = !this.visible;\n     *     if (this.visible) {\n     *       this.open.emit(null);\n     *     } else {\n     *       this.close.emit(null);\n     *     }\n     *   }\n     * }\n     * ```\n     *\n     * The events payload can be accessed by the parameter `$event` on the components output event\n     * handler:\n     *\n     * ```\n     * <zippy (open)=\"onOpen($event)\" (close)=\"onClose($event)\"></zippy>\n     * ```\n     *\n     * Uses Rx.Observable but provides an adapter to make it work as specified here:\n     * https://github.com/jhusain/observable-spec\n     *\n     * Once a reference implementation of the spec is available, switch to it.\n     * @stable\n     */\n    var EventEmitter = (function (_super) {\n        __extends$8(EventEmitter, _super);\n        /**\n         * Creates an instance of [EventEmitter], which depending on [isAsync],\n         * delivers events synchronously or asynchronously.\n         */\n        function EventEmitter(isAsync) {\n            if (isAsync === void 0) { isAsync = false; }\n            _super.call(this);\n            this.__isAsync = isAsync;\n        }\n        EventEmitter.prototype.emit = function (value) { _super.prototype.next.call(this, value); };\n        EventEmitter.prototype.subscribe = function (generatorOrNext, error, complete) {\n            var schedulerFn;\n            var errorFn = function (err) { return null; };\n            var completeFn = function () { return null; };\n            if (generatorOrNext && typeof generatorOrNext === 'object') {\n                schedulerFn = this.__isAsync ? function (value /** TODO #9100 */) {\n                    setTimeout(function () { return generatorOrNext.next(value); });\n                } : function (value /** TODO #9100 */) { generatorOrNext.next(value); };\n                if (generatorOrNext.error) {\n                    errorFn = this.__isAsync ? function (err) { setTimeout(function () { return generatorOrNext.error(err); }); } :\n                        function (err) { generatorOrNext.error(err); };\n                }\n                if (generatorOrNext.complete) {\n                    completeFn = this.__isAsync ? function () { setTimeout(function () { return generatorOrNext.complete(); }); } :\n                        function () { generatorOrNext.complete(); };\n                }\n            }\n            else {\n                schedulerFn = this.__isAsync ? function (value /** TODO #9100 */) {\n                    setTimeout(function () { return generatorOrNext(value); });\n                } : function (value /** TODO #9100 */) { generatorOrNext(value); };\n                if (error) {\n                    errorFn =\n                        this.__isAsync ? function (err) { setTimeout(function () { return error(err); }); } : function (err) { error(err); };\n                }\n                if (complete) {\n                    completeFn =\n                        this.__isAsync ? function () { setTimeout(function () { return complete(); }); } : function () { complete(); };\n                }\n            }\n            return _super.prototype.subscribe.call(this, schedulerFn, errorFn, completeFn);\n        };\n        return EventEmitter;\n    }(rxjs_Subject.Subject));\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var NgZoneImpl = (function () {\n        function NgZoneImpl(_a) {\n            var _this = this;\n            var trace = _a.trace, onEnter = _a.onEnter, onLeave = _a.onLeave, setMicrotask = _a.setMicrotask, setMacrotask = _a.setMacrotask, onError = _a.onError;\n            this.onEnter = onEnter;\n            this.onLeave = onLeave;\n            this.setMicrotask = setMicrotask;\n            this.setMacrotask = setMacrotask;\n            this.onError = onError;\n            if (typeof Zone == 'undefined') {\n                throw new Error('Angular requires Zone.js prolyfill.');\n            }\n            Zone.assertZonePatched();\n            this.outer = this.inner = Zone.current;\n            if (Zone['wtfZoneSpec']) {\n                this.inner = this.inner.fork(Zone['wtfZoneSpec']);\n            }\n            if (trace && Zone['longStackTraceZoneSpec']) {\n                this.inner = this.inner.fork(Zone['longStackTraceZoneSpec']);\n            }\n            this.inner = this.inner.fork({\n                name: 'angular',\n                properties: { 'isAngularZone': true },\n                onInvokeTask: function (delegate, current, target, task, applyThis, applyArgs) {\n                    try {\n                        _this.onEnter();\n                        return delegate.invokeTask(target, task, applyThis, applyArgs);\n                    }\n                    finally {\n                        _this.onLeave();\n                    }\n                },\n                onInvoke: function (delegate, current, target, callback, applyThis, applyArgs, source) {\n                    try {\n                        _this.onEnter();\n                        return delegate.invoke(target, callback, applyThis, applyArgs, source);\n                    }\n                    finally {\n                        _this.onLeave();\n                    }\n                },\n                onHasTask: function (delegate, current, target, hasTaskState) {\n                    delegate.hasTask(target, hasTaskState);\n                    if (current === target) {\n                        // We are only interested in hasTask events which originate from our zone\n                        // (A child hasTask event is not interesting to us)\n                        if (hasTaskState.change == 'microTask') {\n                            _this.setMicrotask(hasTaskState.microTask);\n                        }\n                        else if (hasTaskState.change == 'macroTask') {\n                            _this.setMacrotask(hasTaskState.macroTask);\n                        }\n                    }\n                },\n                onHandleError: function (delegate, current, target, error) {\n                    delegate.handleError(target, error);\n                    _this.onError(error);\n                    return false;\n                }\n            });\n        }\n        NgZoneImpl.isInAngularZone = function () { return Zone.current.get('isAngularZone') === true; };\n        NgZoneImpl.prototype.runInner = function (fn) { return this.inner.run(fn); };\n        ;\n        NgZoneImpl.prototype.runInnerGuarded = function (fn) { return this.inner.runGuarded(fn); };\n        ;\n        NgZoneImpl.prototype.runOuter = function (fn) { return this.outer.run(fn); };\n        ;\n        return NgZoneImpl;\n    }());\n\n    /**\n     * An injectable service for executing work inside or outside of the Angular zone.\n     *\n     * The most common use of this service is to optimize performance when starting a work consisting of\n     * one or more asynchronous tasks that don't require UI updates or error handling to be handled by\n     * Angular. Such tasks can be kicked off via {@link #runOutsideAngular} and if needed, these tasks\n     * can reenter the Angular zone via {@link #run}.\n     *\n     * <!-- TODO: add/fix links to:\n     *   - docs explaining zones and the use of zones in Angular and change-detection\n     *   - link to runOutsideAngular/run (throughout this file!)\n     *   -->\n     *\n     * ### Example ([live demo](http://plnkr.co/edit/lY9m8HLy7z06vDoUaSN2?p=preview))\n     * ```\n     * import {Component, View, NgZone} from '@angular/core';\n     * import {NgIf} from '@angular/common';\n     *\n     * @Component({\n     *   selector: 'ng-zone-demo'.\n     *   template: `\n     *     <h2>Demo: NgZone</h2>\n     *\n     *     <p>Progress: {{progress}}%</p>\n     *     <p *ngIf=\"progress >= 100\">Done processing {{label}} of Angular zone!</p>\n     *\n     *     <button (click)=\"processWithinAngularZone()\">Process within Angular zone</button>\n     *     <button (click)=\"processOutsideOfAngularZone()\">Process outside of Angular zone</button>\n     *   `,\n     *   directives: [NgIf]\n     * })\n     * export class NgZoneDemo {\n     *   progress: number = 0;\n     *   label: string;\n     *\n     *   constructor(private _ngZone: NgZone) {}\n     *\n     *   // Loop inside the Angular zone\n     *   // so the UI DOES refresh after each setTimeout cycle\n     *   processWithinAngularZone() {\n     *     this.label = 'inside';\n     *     this.progress = 0;\n     *     this._increaseProgress(() => console.log('Inside Done!'));\n     *   }\n     *\n     *   // Loop outside of the Angular zone\n     *   // so the UI DOES NOT refresh after each setTimeout cycle\n     *   processOutsideOfAngularZone() {\n     *     this.label = 'outside';\n     *     this.progress = 0;\n     *     this._ngZone.runOutsideAngular(() => {\n     *       this._increaseProgress(() => {\n     *       // reenter the Angular zone and display done\n     *       this._ngZone.run(() => {console.log('Outside Done!') });\n     *     }}));\n     *   }\n     *\n     *\n     *   _increaseProgress(doneCallback: () => void) {\n     *     this.progress += 1;\n     *     console.log(`Current progress: ${this.progress}%`);\n     *\n     *     if (this.progress < 100) {\n     *       window.setTimeout(() => this._increaseProgress(doneCallback)), 10)\n     *     } else {\n     *       doneCallback();\n     *     }\n     *   }\n     * }\n     * ```\n     * @experimental\n     */\n    var NgZone = (function () {\n        function NgZone(_a) {\n            var _this = this;\n            var _b = _a.enableLongStackTrace, enableLongStackTrace = _b === void 0 ? false : _b;\n            this._hasPendingMicrotasks = false;\n            this._hasPendingMacrotasks = false;\n            /** @internal */\n            this._isStable = true;\n            /** @internal */\n            this._nesting = 0;\n            /** @internal */\n            this._onUnstable = new EventEmitter(false);\n            /** @internal */\n            this._onMicrotaskEmpty = new EventEmitter(false);\n            /** @internal */\n            this._onStable = new EventEmitter(false);\n            /** @internal */\n            this._onErrorEvents = new EventEmitter(false);\n            this._zoneImpl = new NgZoneImpl({\n                trace: enableLongStackTrace,\n                onEnter: function () {\n                    // console.log('ZONE.enter', this._nesting, this._isStable);\n                    _this._nesting++;\n                    if (_this._isStable) {\n                        _this._isStable = false;\n                        _this._onUnstable.emit(null);\n                    }\n                },\n                onLeave: function () {\n                    _this._nesting--;\n                    // console.log('ZONE.leave', this._nesting, this._isStable);\n                    _this._checkStable();\n                },\n                setMicrotask: function (hasMicrotasks) {\n                    _this._hasPendingMicrotasks = hasMicrotasks;\n                    _this._checkStable();\n                },\n                setMacrotask: function (hasMacrotasks) { _this._hasPendingMacrotasks = hasMacrotasks; },\n                onError: function (error) { return _this._onErrorEvents.emit(error); }\n            });\n        }\n        NgZone.isInAngularZone = function () { return NgZoneImpl.isInAngularZone(); };\n        NgZone.assertInAngularZone = function () {\n            if (!NgZoneImpl.isInAngularZone()) {\n                throw new Error('Expected to be in Angular Zone, but it is not!');\n            }\n        };\n        NgZone.assertNotInAngularZone = function () {\n            if (NgZoneImpl.isInAngularZone()) {\n                throw new Error('Expected to not be in Angular Zone, but it is!');\n            }\n        };\n        NgZone.prototype._checkStable = function () {\n            var _this = this;\n            if (this._nesting == 0) {\n                if (!this._hasPendingMicrotasks && !this._isStable) {\n                    try {\n                        // console.log('ZONE.microtaskEmpty');\n                        this._nesting++;\n                        this._onMicrotaskEmpty.emit(null);\n                    }\n                    finally {\n                        this._nesting--;\n                        if (!this._hasPendingMicrotasks) {\n                            try {\n                                // console.log('ZONE.stable', this._nesting, this._isStable);\n                                this.runOutsideAngular(function () { return _this._onStable.emit(null); });\n                            }\n                            finally {\n                                this._isStable = true;\n                            }\n                        }\n                    }\n                }\n            }\n        };\n        ;\n        Object.defineProperty(NgZone.prototype, \"onUnstable\", {\n            /**\n             * Notifies when code enters Angular Zone. This gets fired first on VM Turn.\n             */\n            get: function () { return this._onUnstable; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(NgZone.prototype, \"onMicrotaskEmpty\", {\n            /**\n             * Notifies when there is no more microtasks enqueue in the current VM Turn.\n             * This is a hint for Angular to do change detection, which may enqueue more microtasks.\n             * For this reason this event can fire multiple times per VM Turn.\n             */\n            get: function () { return this._onMicrotaskEmpty; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(NgZone.prototype, \"onStable\", {\n            /**\n             * Notifies when the last `onMicrotaskEmpty` has run and there are no more microtasks, which\n             * implies we are about to relinquish VM turn.\n             * This event gets called just once.\n             */\n            get: function () { return this._onStable; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(NgZone.prototype, \"onError\", {\n            /**\n             * Notify that an error has been delivered.\n             */\n            get: function () { return this._onErrorEvents; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(NgZone.prototype, \"isStable\", {\n            /**\n             * Whether there are no outstanding microtasks or microtasks.\n             */\n            get: function () { return this._isStable; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(NgZone.prototype, \"hasPendingMicrotasks\", {\n            /**\n             * Whether there are any outstanding microtasks.\n             */\n            get: function () { return this._hasPendingMicrotasks; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(NgZone.prototype, \"hasPendingMacrotasks\", {\n            /**\n             * Whether there are any outstanding microtasks.\n             */\n            get: function () { return this._hasPendingMacrotasks; },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * Executes the `fn` function synchronously within the Angular zone and returns value returned by\n         * the function.\n         *\n         * Running functions via `run` allows you to reenter Angular zone from a task that was executed\n         * outside of the Angular zone (typically started via {@link #runOutsideAngular}).\n         *\n         * Any future tasks or microtasks scheduled from within this function will continue executing from\n         * within the Angular zone.\n         *\n         * If a synchronous error happens it will be rethrown and not reported via `onError`.\n         */\n        NgZone.prototype.run = function (fn) { return this._zoneImpl.runInner(fn); };\n        /**\n         * Same as #run, except that synchronous errors are caught and forwarded\n         * via `onError` and not rethrown.\n         */\n        NgZone.prototype.runGuarded = function (fn) { return this._zoneImpl.runInnerGuarded(fn); };\n        /**\n         * Executes the `fn` function synchronously in Angular's parent zone and returns value returned by\n         * the function.\n         *\n         * Running functions via `runOutsideAngular` allows you to escape Angular's zone and do work that\n         * doesn't trigger Angular change-detection or is subject to Angular's error handling.\n         *\n         * Any future tasks or microtasks scheduled from within this function will continue executing from\n         * outside of the Angular zone.\n         *\n         * Use {@link #run} to reenter the Angular zone and do work that updates the application model.\n         */\n        NgZone.prototype.runOutsideAngular = function (fn) { return this._zoneImpl.runOuter(fn); };\n        return NgZone;\n    }());\n\n    /**\n     * The Testability service provides testing hooks that can be accessed from\n     * the browser and by services such as Protractor. Each bootstrapped Angular\n     * application on the page will have an instance of Testability.\n     * @experimental\n     */\n    var Testability = (function () {\n        function Testability(_ngZone) {\n            this._ngZone = _ngZone;\n            /** @internal */\n            this._pendingCount = 0;\n            /** @internal */\n            this._isZoneStable = true;\n            /**\n             * Whether any work was done since the last 'whenStable' callback. This is\n             * useful to detect if this could have potentially destabilized another\n             * component while it is stabilizing.\n             * @internal\n             */\n            this._didWork = false;\n            /** @internal */\n            this._callbacks = [];\n            this._watchAngularEvents();\n        }\n        /** @internal */\n        Testability.prototype._watchAngularEvents = function () {\n            var _this = this;\n            this._ngZone.onUnstable.subscribe({\n                next: function () {\n                    _this._didWork = true;\n                    _this._isZoneStable = false;\n                }\n            });\n            this._ngZone.runOutsideAngular(function () {\n                _this._ngZone.onStable.subscribe({\n                    next: function () {\n                        NgZone.assertNotInAngularZone();\n                        scheduleMicroTask(function () {\n                            _this._isZoneStable = true;\n                            _this._runCallbacksIfReady();\n                        });\n                    }\n                });\n            });\n        };\n        Testability.prototype.increasePendingRequestCount = function () {\n            this._pendingCount += 1;\n            this._didWork = true;\n            return this._pendingCount;\n        };\n        Testability.prototype.decreasePendingRequestCount = function () {\n            this._pendingCount -= 1;\n            if (this._pendingCount < 0) {\n                throw new Error('pending async requests below zero');\n            }\n            this._runCallbacksIfReady();\n            return this._pendingCount;\n        };\n        Testability.prototype.isStable = function () {\n            return this._isZoneStable && this._pendingCount == 0 && !this._ngZone.hasPendingMacrotasks;\n        };\n        /** @internal */\n        Testability.prototype._runCallbacksIfReady = function () {\n            var _this = this;\n            if (this.isStable()) {\n                // Schedules the call backs in a new frame so that it is always async.\n                scheduleMicroTask(function () {\n                    while (_this._callbacks.length !== 0) {\n                        (_this._callbacks.pop())(_this._didWork);\n                    }\n                    _this._didWork = false;\n                });\n            }\n            else {\n                // Not Ready\n                this._didWork = true;\n            }\n        };\n        Testability.prototype.whenStable = function (callback) {\n            this._callbacks.push(callback);\n            this._runCallbacksIfReady();\n        };\n        Testability.prototype.getPendingRequestCount = function () { return this._pendingCount; };\n        /** @deprecated use findProviders */\n        Testability.prototype.findBindings = function (using, provider, exactMatch) {\n            // TODO(juliemr): implement.\n            return [];\n        };\n        Testability.prototype.findProviders = function (using, provider, exactMatch) {\n            // TODO(juliemr): implement.\n            return [];\n        };\n        Testability.decorators = [\n            { type: Injectable },\n        ];\n        /** @nocollapse */\n        Testability.ctorParameters = [\n            { type: NgZone, },\n        ];\n        return Testability;\n    }());\n    /**\n     * A global registry of {@link Testability} instances for specific elements.\n     * @experimental\n     */\n    var TestabilityRegistry = (function () {\n        function TestabilityRegistry() {\n            /** @internal */\n            this._applications = new Map();\n            _testabilityGetter.addToWindow(this);\n        }\n        TestabilityRegistry.prototype.registerApplication = function (token, testability) {\n            this._applications.set(token, testability);\n        };\n        TestabilityRegistry.prototype.getTestability = function (elem) { return this._applications.get(elem); };\n        TestabilityRegistry.prototype.getAllTestabilities = function () { return MapWrapper.values(this._applications); };\n        TestabilityRegistry.prototype.getAllRootElements = function () { return MapWrapper.keys(this._applications); };\n        TestabilityRegistry.prototype.findTestabilityInTree = function (elem, findInAncestors) {\n            if (findInAncestors === void 0) { findInAncestors = true; }\n            return _testabilityGetter.findTestabilityInTree(this, elem, findInAncestors);\n        };\n        TestabilityRegistry.decorators = [\n            { type: Injectable },\n        ];\n        /** @nocollapse */\n        TestabilityRegistry.ctorParameters = [];\n        return TestabilityRegistry;\n    }());\n    var _NoopGetTestability = (function () {\n        function _NoopGetTestability() {\n        }\n        _NoopGetTestability.prototype.addToWindow = function (registry) { };\n        _NoopGetTestability.prototype.findTestabilityInTree = function (registry, elem, findInAncestors) {\n            return null;\n        };\n        return _NoopGetTestability;\n    }());\n    /**\n     * Set the {@link GetTestability} implementation used by the Angular testing framework.\n     * @experimental\n     */\n    function setTestabilityGetter(getter) {\n        _testabilityGetter = getter;\n    }\n    var _testabilityGetter = new _NoopGetTestability();\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$3 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    var _devMode = true;\n    var _runModeLocked = false;\n    var _platform;\n    /**\n     * Disable Angular's development mode, which turns off assertions and other\n     * checks within the framework.\n     *\n     * One important assertion this disables verifies that a change detection pass\n     * does not result in additional changes to any bindings (also known as\n     * unidirectional data flow).\n     *\n     * @stable\n     */\n    function enableProdMode() {\n        if (_runModeLocked) {\n            throw new Error('Cannot enable prod mode after platform setup.');\n        }\n        _devMode = false;\n    }\n    /**\n     * Returns whether Angular is in development mode. After called once,\n     * the value is locked and won't change any more.\n     *\n     * By default, this is true, unless a user calls `enableProdMode` before calling this.\n     *\n     * @experimental APIs related to application bootstrap are currently under review.\n     */\n    function isDevMode() {\n        _runModeLocked = true;\n        return _devMode;\n    }\n    /**\n     * Creates a platform.\n     * Platforms have to be eagerly created via this function.\n     *\n     * @experimental APIs related to application bootstrap are currently under review.\n     */\n    function createPlatform(injector) {\n        if (_platform && !_platform.destroyed) {\n            throw new Error('There can be only one platform. Destroy the previous one to create a new one.');\n        }\n        _platform = injector.get(PlatformRef);\n        var inits = injector.get(PLATFORM_INITIALIZER, null);\n        if (inits)\n            inits.forEach(function (init) { return init(); });\n        return _platform;\n    }\n    /**\n     * Creates a factory for a platform\n     *\n     * @experimental APIs related to application bootstrap are currently under review.\n     */\n    function createPlatformFactory(parentPlaformFactory, name, providers) {\n        if (providers === void 0) { providers = []; }\n        var marker = new OpaqueToken(\"Platform: \" + name);\n        return function (extraProviders) {\n            if (extraProviders === void 0) { extraProviders = []; }\n            if (!getPlatform()) {\n                if (parentPlaformFactory) {\n                    parentPlaformFactory(providers.concat(extraProviders).concat({ provide: marker, useValue: true }));\n                }\n                else {\n                    createPlatform(ReflectiveInjector.resolveAndCreate(providers.concat(extraProviders).concat({ provide: marker, useValue: true })));\n                }\n            }\n            return assertPlatform(marker);\n        };\n    }\n    /**\n     * Checks that there currently is a platform\n     * which contains the given token as a provider.\n     *\n     * @experimental APIs related to application bootstrap are currently under review.\n     */\n    function assertPlatform(requiredToken) {\n        var platform = getPlatform();\n        if (!platform) {\n            throw new Error('No platform exists!');\n        }\n        if (!platform.injector.get(requiredToken, null)) {\n            throw new Error('A platform with a different configuration has been created. Please destroy it first.');\n        }\n        return platform;\n    }\n    /**\n     * Destroy the existing platform.\n     *\n     * @experimental APIs related to application bootstrap are currently under review.\n     */\n    function destroyPlatform() {\n        if (_platform && !_platform.destroyed) {\n            _platform.destroy();\n        }\n    }\n    /**\n     * Returns the current platform.\n     *\n     * @experimental APIs related to application bootstrap are currently under review.\n     */\n    function getPlatform() {\n        return _platform && !_platform.destroyed ? _platform : null;\n    }\n    /**\n     * The Angular platform is the entry point for Angular on a web page. Each page\n     * has exactly one platform, and services (such as reflection) which are common\n     * to every Angular application running on the page are bound in its scope.\n     *\n     * A page's platform is initialized implicitly when {@link bootstrap}() is called, or\n     * explicitly by calling {@link createPlatform}().\n     *\n     * @stable\n     */\n    var PlatformRef = (function () {\n        function PlatformRef() {\n        }\n        /**\n         * Creates an instance of an `@NgModule` for the given platform\n         * for offline compilation.\n         *\n         * ## Simple Example\n         *\n         * ```typescript\n         * my_module.ts:\n         *\n         * @NgModule({\n         *   imports: [BrowserModule]\n         * })\n         * class MyModule {}\n         *\n         * main.ts:\n         * import {MyModuleNgFactory} from './my_module.ngfactory';\n         * import {platformBrowser} from '@angular/platform-browser';\n         *\n         * let moduleRef = platformBrowser().bootstrapModuleFactory(MyModuleNgFactory);\n         * ```\n         *\n         * @experimental APIs related to application bootstrap are currently under review.\n         */\n        PlatformRef.prototype.bootstrapModuleFactory = function (moduleFactory) {\n            throw unimplemented();\n        };\n        /**\n         * Creates an instance of an `@NgModule` for a given platform using the given runtime compiler.\n         *\n         * ## Simple Example\n         *\n         * ```typescript\n         * @NgModule({\n         *   imports: [BrowserModule]\n         * })\n         * class MyModule {}\n         *\n         * let moduleRef = platformBrowser().bootstrapModule(MyModule);\n         * ```\n         * @stable\n         */\n        PlatformRef.prototype.bootstrapModule = function (moduleType, compilerOptions) {\n            if (compilerOptions === void 0) { compilerOptions = []; }\n            throw unimplemented();\n        };\n        Object.defineProperty(PlatformRef.prototype, \"injector\", {\n            /**\n             * Retrieve the platform {@link Injector}, which is the parent injector for\n             * every Angular application on the page and provides singleton providers.\n             */\n            get: function () { throw unimplemented(); },\n            enumerable: true,\n            configurable: true\n        });\n        ;\n        Object.defineProperty(PlatformRef.prototype, \"destroyed\", {\n            get: function () { throw unimplemented(); },\n            enumerable: true,\n            configurable: true\n        });\n        return PlatformRef;\n    }());\n    function _callAndReportToErrorHandler(errorHandler, callback) {\n        try {\n            var result = callback();\n            if (isPromise(result)) {\n                return result.catch(function (e) {\n                    errorHandler.handleError(e);\n                    // rethrow as the exception handler might not do it\n                    throw e;\n                });\n            }\n            return result;\n        }\n        catch (e) {\n            errorHandler.handleError(e);\n            // rethrow as the exception handler might not do it\n            throw e;\n        }\n    }\n    var PlatformRef_ = (function (_super) {\n        __extends$3(PlatformRef_, _super);\n        function PlatformRef_(_injector) {\n            _super.call(this);\n            this._injector = _injector;\n            this._modules = [];\n            this._destroyListeners = [];\n            this._destroyed = false;\n        }\n        PlatformRef_.prototype.onDestroy = function (callback) { this._destroyListeners.push(callback); };\n        Object.defineProperty(PlatformRef_.prototype, \"injector\", {\n            get: function () { return this._injector; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(PlatformRef_.prototype, \"destroyed\", {\n            get: function () { return this._destroyed; },\n            enumerable: true,\n            configurable: true\n        });\n        PlatformRef_.prototype.destroy = function () {\n            if (this._destroyed) {\n                throw new Error('The platform has already been destroyed!');\n            }\n            this._modules.slice().forEach(function (module) { return module.destroy(); });\n            this._destroyListeners.forEach(function (listener) { return listener(); });\n            this._destroyed = true;\n        };\n        PlatformRef_.prototype.bootstrapModuleFactory = function (moduleFactory) {\n            return this._bootstrapModuleFactoryWithZone(moduleFactory, null);\n        };\n        PlatformRef_.prototype._bootstrapModuleFactoryWithZone = function (moduleFactory, ngZone) {\n            var _this = this;\n            // Note: We need to create the NgZone _before_ we instantiate the module,\n            // as instantiating the module creates some providers eagerly.\n            // So we create a mini parent injector that just contains the new NgZone and\n            // pass that as parent to the NgModuleFactory.\n            if (!ngZone)\n                ngZone = new NgZone({ enableLongStackTrace: isDevMode() });\n            // Attention: Don't use ApplicationRef.run here,\n            // as we want to be sure that all possible constructor calls are inside `ngZone.run`!\n            return ngZone.run(function () {\n                var ngZoneInjector = ReflectiveInjector.resolveAndCreate([{ provide: NgZone, useValue: ngZone }], _this.injector);\n                var moduleRef = moduleFactory.create(ngZoneInjector);\n                var exceptionHandler = moduleRef.injector.get(ErrorHandler, null);\n                if (!exceptionHandler) {\n                    throw new Error('No ErrorHandler. Is platform module (BrowserModule) included?');\n                }\n                moduleRef.onDestroy(function () { return ListWrapper.remove(_this._modules, moduleRef); });\n                ngZone.onError.subscribe({ next: function (error) { exceptionHandler.handleError(error); } });\n                return _callAndReportToErrorHandler(exceptionHandler, function () {\n                    var initStatus = moduleRef.injector.get(ApplicationInitStatus);\n                    return initStatus.donePromise.then(function () {\n                        _this._moduleDoBootstrap(moduleRef);\n                        return moduleRef;\n                    });\n                });\n            });\n        };\n        PlatformRef_.prototype.bootstrapModule = function (moduleType, compilerOptions) {\n            if (compilerOptions === void 0) { compilerOptions = []; }\n            return this._bootstrapModuleWithZone(moduleType, compilerOptions, null);\n        };\n        PlatformRef_.prototype._bootstrapModuleWithZone = function (moduleType, compilerOptions, ngZone, componentFactoryCallback) {\n            var _this = this;\n            if (compilerOptions === void 0) { compilerOptions = []; }\n            var compilerFactory = this.injector.get(CompilerFactory);\n            var compiler = compilerFactory.createCompiler(Array.isArray(compilerOptions) ? compilerOptions : [compilerOptions]);\n            // ugly internal api hack: generate host component factories for all declared components and\n            // pass the factories into the callback - this is used by UpdateAdapter to get hold of all\n            // factories.\n            if (componentFactoryCallback) {\n                return compiler.compileModuleAndAllComponentsAsync(moduleType)\n                    .then(function (_a) {\n                    var ngModuleFactory = _a.ngModuleFactory, componentFactories = _a.componentFactories;\n                    componentFactoryCallback(componentFactories);\n                    return _this._bootstrapModuleFactoryWithZone(ngModuleFactory, ngZone);\n                });\n            }\n            return compiler.compileModuleAsync(moduleType)\n                .then(function (moduleFactory) { return _this._bootstrapModuleFactoryWithZone(moduleFactory, ngZone); });\n        };\n        PlatformRef_.prototype._moduleDoBootstrap = function (moduleRef) {\n            var appRef = moduleRef.injector.get(ApplicationRef);\n            if (moduleRef.bootstrapFactories.length > 0) {\n                moduleRef.bootstrapFactories.forEach(function (compFactory) { return appRef.bootstrap(compFactory); });\n            }\n            else if (moduleRef.instance.ngDoBootstrap) {\n                moduleRef.instance.ngDoBootstrap(appRef);\n            }\n            else {\n                throw new Error((\"The module \" + stringify(moduleRef.instance.constructor) + \" was bootstrapped, but it does not declare \\\"@NgModule.bootstrap\\\" components nor a \\\"ngDoBootstrap\\\" method. \") +\n                    \"Please define one of these.\");\n            }\n        };\n        PlatformRef_.decorators = [\n            { type: Injectable },\n        ];\n        /** @nocollapse */\n        PlatformRef_.ctorParameters = [\n            { type: Injector, },\n        ];\n        return PlatformRef_;\n    }(PlatformRef));\n    /**\n     * A reference to an Angular application running on a page.\n     *\n     * For more about Angular applications, see the documentation for {@link bootstrap}.\n     *\n     * @stable\n     */\n    var ApplicationRef = (function () {\n        function ApplicationRef() {\n        }\n        Object.defineProperty(ApplicationRef.prototype, \"componentTypes\", {\n            /**\n             * Get a list of component types registered to this application.\n             * This list is populated even before the component is created.\n             */\n            get: function () { return unimplemented(); },\n            enumerable: true,\n            configurable: true\n        });\n        ;\n        Object.defineProperty(ApplicationRef.prototype, \"components\", {\n            /**\n             * Get a list of components registered to this application.\n             */\n            get: function () { return unimplemented(); },\n            enumerable: true,\n            configurable: true\n        });\n        ;\n        return ApplicationRef;\n    }());\n    var ApplicationRef_ = (function (_super) {\n        __extends$3(ApplicationRef_, _super);\n        function ApplicationRef_(_zone, _console, _injector, _exceptionHandler, _componentFactoryResolver, _initStatus, _testabilityRegistry, _testability) {\n            var _this = this;\n            _super.call(this);\n            this._zone = _zone;\n            this._console = _console;\n            this._injector = _injector;\n            this._exceptionHandler = _exceptionHandler;\n            this._componentFactoryResolver = _componentFactoryResolver;\n            this._initStatus = _initStatus;\n            this._testabilityRegistry = _testabilityRegistry;\n            this._testability = _testability;\n            this._bootstrapListeners = [];\n            this._rootComponents = [];\n            this._rootComponentTypes = [];\n            this._changeDetectorRefs = [];\n            this._runningTick = false;\n            this._enforceNoNewChanges = false;\n            this._enforceNoNewChanges = isDevMode();\n            this._zone.onMicrotaskEmpty.subscribe({ next: function () { _this._zone.run(function () { _this.tick(); }); } });\n        }\n        ApplicationRef_.prototype.registerChangeDetector = function (changeDetector) {\n            this._changeDetectorRefs.push(changeDetector);\n        };\n        ApplicationRef_.prototype.unregisterChangeDetector = function (changeDetector) {\n            ListWrapper.remove(this._changeDetectorRefs, changeDetector);\n        };\n        ApplicationRef_.prototype.bootstrap = function (componentOrFactory) {\n            var _this = this;\n            if (!this._initStatus.done) {\n                throw new Error('Cannot bootstrap as there are still asynchronous initializers running. Bootstrap components in the `ngDoBootstrap` method of the root module.');\n            }\n            var componentFactory;\n            if (componentOrFactory instanceof ComponentFactory) {\n                componentFactory = componentOrFactory;\n            }\n            else {\n                componentFactory = this._componentFactoryResolver.resolveComponentFactory(componentOrFactory);\n            }\n            this._rootComponentTypes.push(componentFactory.componentType);\n            var compRef = componentFactory.create(this._injector, [], componentFactory.selector);\n            compRef.onDestroy(function () { _this._unloadComponent(compRef); });\n            var testability = compRef.injector.get(Testability, null);\n            if (testability) {\n                compRef.injector.get(TestabilityRegistry)\n                    .registerApplication(compRef.location.nativeElement, testability);\n            }\n            this._loadComponent(compRef);\n            if (isDevMode()) {\n                this._console.log(\"Angular 2 is running in the development mode. Call enableProdMode() to enable the production mode.\");\n            }\n            return compRef;\n        };\n        /** @internal */\n        ApplicationRef_.prototype._loadComponent = function (componentRef) {\n            this._changeDetectorRefs.push(componentRef.changeDetectorRef);\n            this.tick();\n            this._rootComponents.push(componentRef);\n            // Get the listeners lazily to prevent DI cycles.\n            var listeners = this._injector.get(APP_BOOTSTRAP_LISTENER, [])\n                .concat(this._bootstrapListeners);\n            listeners.forEach(function (listener) { return listener(componentRef); });\n        };\n        /** @internal */\n        ApplicationRef_.prototype._unloadComponent = function (componentRef) {\n            if (this._rootComponents.indexOf(componentRef) == -1) {\n                return;\n            }\n            this.unregisterChangeDetector(componentRef.changeDetectorRef);\n            ListWrapper.remove(this._rootComponents, componentRef);\n        };\n        ApplicationRef_.prototype.tick = function () {\n            if (this._runningTick) {\n                throw new Error('ApplicationRef.tick is called recursively');\n            }\n            var scope = ApplicationRef_._tickScope();\n            try {\n                this._runningTick = true;\n                this._changeDetectorRefs.forEach(function (detector) { return detector.detectChanges(); });\n                if (this._enforceNoNewChanges) {\n                    this._changeDetectorRefs.forEach(function (detector) { return detector.checkNoChanges(); });\n                }\n            }\n            finally {\n                this._runningTick = false;\n                wtfLeave(scope);\n            }\n        };\n        ApplicationRef_.prototype.ngOnDestroy = function () {\n            // TODO(alxhub): Dispose of the NgZone.\n            this._rootComponents.slice().forEach(function (component) { return component.destroy(); });\n        };\n        Object.defineProperty(ApplicationRef_.prototype, \"componentTypes\", {\n            get: function () { return this._rootComponentTypes; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ApplicationRef_.prototype, \"components\", {\n            get: function () { return this._rootComponents; },\n            enumerable: true,\n            configurable: true\n        });\n        /** @internal */\n        ApplicationRef_._tickScope = wtfCreateScope('ApplicationRef#tick()');\n        ApplicationRef_.decorators = [\n            { type: Injectable },\n        ];\n        /** @nocollapse */\n        ApplicationRef_.ctorParameters = [\n            { type: NgZone, },\n            { type: Console, },\n            { type: Injector, },\n            { type: ErrorHandler, },\n            { type: ComponentFactoryResolver, },\n            { type: ApplicationInitStatus, },\n            { type: TestabilityRegistry, decorators: [{ type: Optional },] },\n            { type: Testability, decorators: [{ type: Optional },] },\n        ];\n        return ApplicationRef_;\n    }(ApplicationRef));\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$9 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    /**\n     * Represents an instance of an NgModule created via a {@link NgModuleFactory}.\n     *\n     * `NgModuleRef` provides access to the NgModule Instance as well other objects related to this\n     * NgModule Instance.\n     *\n     * @stable\n     */\n    var NgModuleRef = (function () {\n        function NgModuleRef() {\n        }\n        Object.defineProperty(NgModuleRef.prototype, \"injector\", {\n            /**\n             * The injector that contains all of the providers of the NgModule.\n             */\n            get: function () { return unimplemented(); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(NgModuleRef.prototype, \"componentFactoryResolver\", {\n            /**\n             * The ComponentFactoryResolver to get hold of the ComponentFactories\n             * declared in the `entryComponents` property of the module.\n             */\n            get: function () { return unimplemented(); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(NgModuleRef.prototype, \"instance\", {\n            /**\n             * The NgModule instance.\n             */\n            get: function () { return unimplemented(); },\n            enumerable: true,\n            configurable: true\n        });\n        return NgModuleRef;\n    }());\n    /**\n     * @experimental\n     */\n    var NgModuleFactory = (function () {\n        function NgModuleFactory(_injectorClass, _moduleType) {\n            this._injectorClass = _injectorClass;\n            this._moduleType = _moduleType;\n        }\n        Object.defineProperty(NgModuleFactory.prototype, \"moduleType\", {\n            get: function () { return this._moduleType; },\n            enumerable: true,\n            configurable: true\n        });\n        NgModuleFactory.prototype.create = function (parentInjector) {\n            if (!parentInjector) {\n                parentInjector = Injector.NULL;\n            }\n            var instance = new this._injectorClass(parentInjector);\n            instance.create();\n            return instance;\n        };\n        return NgModuleFactory;\n    }());\n    var _UNDEFINED = new Object();\n    var NgModuleInjector = (function (_super) {\n        __extends$9(NgModuleInjector, _super);\n        function NgModuleInjector(parent, factories, bootstrapFactories) {\n            _super.call(this, factories, parent.get(ComponentFactoryResolver, ComponentFactoryResolver.NULL));\n            this.parent = parent;\n            this.bootstrapFactories = bootstrapFactories;\n            this._destroyListeners = [];\n            this._destroyed = false;\n        }\n        NgModuleInjector.prototype.create = function () { this.instance = this.createInternal(); };\n        NgModuleInjector.prototype.get = function (token, notFoundValue) {\n            if (notFoundValue === void 0) { notFoundValue = THROW_IF_NOT_FOUND; }\n            if (token === Injector || token === ComponentFactoryResolver) {\n                return this;\n            }\n            var result = this.getInternal(token, _UNDEFINED);\n            return result === _UNDEFINED ? this.parent.get(token, notFoundValue) : result;\n        };\n        Object.defineProperty(NgModuleInjector.prototype, \"injector\", {\n            get: function () { return this; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(NgModuleInjector.prototype, \"componentFactoryResolver\", {\n            get: function () { return this; },\n            enumerable: true,\n            configurable: true\n        });\n        NgModuleInjector.prototype.destroy = function () {\n            if (this._destroyed) {\n                throw new Error(\"The ng module \" + stringify(this.instance.constructor) + \" has already been destroyed.\");\n            }\n            this._destroyed = true;\n            this.destroyInternal();\n            this._destroyListeners.forEach(function (listener) { return listener(); });\n        };\n        NgModuleInjector.prototype.onDestroy = function (callback) { this._destroyListeners.push(callback); };\n        return NgModuleInjector;\n    }(CodegenComponentFactoryResolver));\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * Used to load ng module factories.\n     * @stable\n     */\n    var NgModuleFactoryLoader = (function () {\n        function NgModuleFactoryLoader() {\n        }\n        return NgModuleFactoryLoader;\n    }());\n    var moduleFactories = new Map();\n    /**\n     * Registers a loaded module. Should only be called from generated NgModuleFactory code.\n     * @experimental\n     */\n    function registerModuleFactory(id, factory) {\n        var existing = moduleFactories.get(id);\n        if (existing) {\n            throw new Error(\"Duplicate module registered for \" + id + \" - \" + existing.moduleType.name + \" vs \" + factory.moduleType.name);\n        }\n        moduleFactories.set(id, factory);\n    }\n    /**\n     * Returns the NgModuleFactory with the given id, if it exists and has been loaded.\n     * Factories for modules that do not specify an `id` cannot be retrieved. Throws if the module\n     * cannot be found.\n     * @experimental\n     */\n    function getModuleFactory(id) {\n        var factory = moduleFactories.get(id);\n        if (!factory)\n            throw new Error(\"No module with ID \" + id + \" loaded\");\n        return factory;\n    }\n\n    /**\n     * An unmodifiable list of items that Angular keeps up to date when the state\n     * of the application changes.\n     *\n     * The type of object that {@link Query} and {@link ViewQueryMetadata} provide.\n     *\n     * Implements an iterable interface, therefore it can be used in both ES6\n     * javascript `for (var i of items)` loops as well as in Angular templates with\n     * `*ngFor=\"let i of myList\"`.\n     *\n     * Changes can be observed by subscribing to the changes `Observable`.\n     *\n     * NOTE: In the future this class will implement an `Observable` interface.\n     *\n     * ### Example ([live demo](http://plnkr.co/edit/RX8sJnQYl9FWuSCWme5z?p=preview))\n     * ```typescript\n     * @Component({...})\n     * class Container {\n     *   @ViewChildren(Item) items:QueryList<Item>;\n     * }\n     * ```\n     * @stable\n     */\n    var QueryList = (function () {\n        function QueryList() {\n            this._dirty = true;\n            this._results = [];\n            this._emitter = new EventEmitter();\n        }\n        Object.defineProperty(QueryList.prototype, \"changes\", {\n            get: function () { return this._emitter; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(QueryList.prototype, \"length\", {\n            get: function () { return this._results.length; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(QueryList.prototype, \"first\", {\n            get: function () { return this._results[0]; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(QueryList.prototype, \"last\", {\n            get: function () { return this._results[this.length - 1]; },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * See\n         * [Array.map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)\n         */\n        QueryList.prototype.map = function (fn) { return this._results.map(fn); };\n        /**\n         * See\n         * [Array.filter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)\n         */\n        QueryList.prototype.filter = function (fn) {\n            return this._results.filter(fn);\n        };\n        /**\n         * See\n         * [Array.reduce](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce)\n         */\n        QueryList.prototype.reduce = function (fn, init) {\n            return this._results.reduce(fn, init);\n        };\n        /**\n         * See\n         * [Array.forEach](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach)\n         */\n        QueryList.prototype.forEach = function (fn) { this._results.forEach(fn); };\n        /**\n         * See\n         * [Array.some](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some)\n         */\n        QueryList.prototype.some = function (fn) {\n            return this._results.some(fn);\n        };\n        QueryList.prototype.toArray = function () { return this._results.slice(); };\n        QueryList.prototype[getSymbolIterator()] = function () { return this._results[getSymbolIterator()](); };\n        QueryList.prototype.toString = function () { return this._results.toString(); };\n        QueryList.prototype.reset = function (res) {\n            this._results = ListWrapper.flatten(res);\n            this._dirty = false;\n        };\n        QueryList.prototype.notifyOnChanges = function () { this._emitter.emit(this); };\n        /** internal */\n        QueryList.prototype.setDirty = function () { this._dirty = true; };\n        Object.defineProperty(QueryList.prototype, \"dirty\", {\n            /** internal */\n            get: function () { return this._dirty; },\n            enumerable: true,\n            configurable: true\n        });\n        return QueryList;\n    }());\n\n    var _SEPARATOR = '#';\n    var FACTORY_CLASS_SUFFIX = 'NgFactory';\n    /**\n     * Configuration for SystemJsNgModuleLoader.\n     * token.\n     *\n     * @experimental\n     */\n    var SystemJsNgModuleLoaderConfig = (function () {\n        function SystemJsNgModuleLoaderConfig() {\n        }\n        return SystemJsNgModuleLoaderConfig;\n    }());\n    var DEFAULT_CONFIG = {\n        factoryPathPrefix: '',\n        factoryPathSuffix: '.ngfactory',\n    };\n    /**\n     * NgModuleFactoryLoader that uses SystemJS to load NgModuleFactory\n     * @experimental\n     */\n    var SystemJsNgModuleLoader = (function () {\n        function SystemJsNgModuleLoader(_compiler, config) {\n            this._compiler = _compiler;\n            this._config = config || DEFAULT_CONFIG;\n        }\n        SystemJsNgModuleLoader.prototype.load = function (path) {\n            var offlineMode = this._compiler instanceof Compiler;\n            return offlineMode ? this.loadFactory(path) : this.loadAndCompile(path);\n        };\n        SystemJsNgModuleLoader.prototype.loadAndCompile = function (path) {\n            var _this = this;\n            var _a = path.split(_SEPARATOR), module = _a[0], exportName = _a[1];\n            if (exportName === undefined)\n                exportName = 'default';\n            return System.import(module)\n                .then(function (module) { return module[exportName]; })\n                .then(function (type) { return checkNotEmpty(type, module, exportName); })\n                .then(function (type) { return _this._compiler.compileModuleAsync(type); });\n        };\n        SystemJsNgModuleLoader.prototype.loadFactory = function (path) {\n            var _a = path.split(_SEPARATOR), module = _a[0], exportName = _a[1];\n            var factoryClassSuffix = FACTORY_CLASS_SUFFIX;\n            if (exportName === undefined) {\n                exportName = 'default';\n                factoryClassSuffix = '';\n            }\n            return System.import(this._config.factoryPathPrefix + module + this._config.factoryPathSuffix)\n                .then(function (module) { return module[exportName + factoryClassSuffix]; })\n                .then(function (factory) { return checkNotEmpty(factory, module, exportName); });\n        };\n        SystemJsNgModuleLoader.decorators = [\n            { type: Injectable },\n        ];\n        /** @nocollapse */\n        SystemJsNgModuleLoader.ctorParameters = [\n            { type: Compiler, },\n            { type: SystemJsNgModuleLoaderConfig, decorators: [{ type: Optional },] },\n        ];\n        return SystemJsNgModuleLoader;\n    }());\n    function checkNotEmpty(value, modulePath, exportName) {\n        if (!value) {\n            throw new Error(\"Cannot find '\" + exportName + \"' in '\" + modulePath + \"'\");\n        }\n        return value;\n    }\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$10 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    /**\n     * Represents an Embedded Template that can be used to instantiate Embedded Views.\n     *\n     * You can access a `TemplateRef`, in two ways. Via a directive placed on a `<template>` element (or\n     * directive prefixed with `*`) and have the `TemplateRef` for this Embedded View injected into the\n     * constructor of the directive using the `TemplateRef` Token. Alternatively you can query for the\n     * `TemplateRef` from a Component or a Directive via {@link Query}.\n     *\n     * To instantiate Embedded Views based on a Template, use\n     * {@link ViewContainerRef#createEmbeddedView}, which will create the View and attach it to the\n     * View Container.\n     * @stable\n     */\n    var TemplateRef = (function () {\n        function TemplateRef() {\n        }\n        Object.defineProperty(TemplateRef.prototype, \"elementRef\", {\n            /**\n             * The location in the View where the Embedded View logically belongs to.\n             *\n             * The data-binding and injection contexts of Embedded Views created from this `TemplateRef`\n             * inherit from the contexts of this location.\n             *\n             * Typically new Embedded Views are attached to the View Container of this location, but in\n             * advanced use-cases, the View can be attached to a different container while keeping the\n             * data-binding and injection context from the original location.\n             *\n             */\n            // TODO(i): rename to anchor or location\n            get: function () { return null; },\n            enumerable: true,\n            configurable: true\n        });\n        return TemplateRef;\n    }());\n    var TemplateRef_ = (function (_super) {\n        __extends$10(TemplateRef_, _super);\n        function TemplateRef_(_appElement, _viewFactory) {\n            _super.call(this);\n            this._appElement = _appElement;\n            this._viewFactory = _viewFactory;\n        }\n        TemplateRef_.prototype.createEmbeddedView = function (context) {\n            var view = this._viewFactory(this._appElement.parentView.viewUtils, this._appElement.parentInjector, this._appElement);\n            view.create(context || {}, null, null);\n            return view.ref;\n        };\n        Object.defineProperty(TemplateRef_.prototype, \"elementRef\", {\n            get: function () { return this._appElement.elementRef; },\n            enumerable: true,\n            configurable: true\n        });\n        return TemplateRef_;\n    }(TemplateRef));\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var _queuedAnimations = [];\n    /** @internal */\n    function queueAnimation(player) {\n        _queuedAnimations.push(player);\n    }\n    /** @internal */\n    function triggerQueuedAnimations() {\n        for (var i = 0; i < _queuedAnimations.length; i++) {\n            var player = _queuedAnimations[i];\n            player.play();\n        }\n        _queuedAnimations = [];\n    }\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$11 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    /**\n     * @stable\n     */\n    var ViewRef = (function () {\n        function ViewRef() {\n        }\n        Object.defineProperty(ViewRef.prototype, \"destroyed\", {\n            get: function () { return unimplemented(); },\n            enumerable: true,\n            configurable: true\n        });\n        return ViewRef;\n    }());\n    /**\n     * Represents an Angular View.\n     *\n     * <!-- TODO: move the next two paragraphs to the dev guide -->\n     * A View is a fundamental building block of the application UI. It is the smallest grouping of\n     * Elements which are created and destroyed together.\n     *\n     * Properties of elements in a View can change, but the structure (number and order) of elements in\n     * a View cannot. Changing the structure of Elements can only be done by inserting, moving or\n     * removing nested Views via a {@link ViewContainerRef}. Each View can contain many View Containers.\n     * <!-- /TODO -->\n     *\n     * ### Example\n     *\n     * Given this template...\n     *\n     * ```\n     * Count: {{items.length}}\n     * <ul>\n     *   <li *ngFor=\"let  item of items\">{{item}}</li>\n     * </ul>\n     * ```\n     *\n     * We have two {@link TemplateRef}s:\n     *\n     * Outer {@link TemplateRef}:\n     * ```\n     * Count: {{items.length}}\n     * <ul>\n     *   <template ngFor let-item [ngForOf]=\"items\"></template>\n     * </ul>\n     * ```\n     *\n     * Inner {@link TemplateRef}:\n     * ```\n     *   <li>{{item}}</li>\n     * ```\n     *\n     * Notice that the original template is broken down into two separate {@link TemplateRef}s.\n     *\n     * The outer/inner {@link TemplateRef}s are then assembled into views like so:\n     *\n     * ```\n     * <!-- ViewRef: outer-0 -->\n     * Count: 2\n     * <ul>\n     *   <template view-container-ref></template>\n     *   <!-- ViewRef: inner-1 --><li>first</li><!-- /ViewRef: inner-1 -->\n     *   <!-- ViewRef: inner-2 --><li>second</li><!-- /ViewRef: inner-2 -->\n     * </ul>\n     * <!-- /ViewRef: outer-0 -->\n     * ```\n     * @experimental\n     */\n    var EmbeddedViewRef = (function (_super) {\n        __extends$11(EmbeddedViewRef, _super);\n        function EmbeddedViewRef() {\n            _super.apply(this, arguments);\n        }\n        Object.defineProperty(EmbeddedViewRef.prototype, \"context\", {\n            get: function () { return unimplemented(); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(EmbeddedViewRef.prototype, \"rootNodes\", {\n            get: function () { return unimplemented(); },\n            enumerable: true,\n            configurable: true\n        });\n        ;\n        return EmbeddedViewRef;\n    }(ViewRef));\n    var ViewRef_ = (function () {\n        function ViewRef_(_view) {\n            this._view = _view;\n            this._view = _view;\n            this._originalMode = this._view.cdMode;\n        }\n        Object.defineProperty(ViewRef_.prototype, \"internalView\", {\n            get: function () { return this._view; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ViewRef_.prototype, \"rootNodes\", {\n            get: function () { return this._view.flatRootNodes; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ViewRef_.prototype, \"context\", {\n            get: function () { return this._view.context; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ViewRef_.prototype, \"destroyed\", {\n            get: function () { return this._view.destroyed; },\n            enumerable: true,\n            configurable: true\n        });\n        ViewRef_.prototype.markForCheck = function () { this._view.markPathToRootAsCheckOnce(); };\n        ViewRef_.prototype.detach = function () { this._view.cdMode = ChangeDetectorStatus.Detached; };\n        ViewRef_.prototype.detectChanges = function () {\n            this._view.detectChanges(false);\n            triggerQueuedAnimations();\n        };\n        ViewRef_.prototype.checkNoChanges = function () { this._view.detectChanges(true); };\n        ViewRef_.prototype.reattach = function () {\n            this._view.cdMode = this._originalMode;\n            this.markForCheck();\n        };\n        ViewRef_.prototype.onDestroy = function (callback) { this._view.disposables.push(callback); };\n        ViewRef_.prototype.destroy = function () { this._view.destroy(); };\n        return ViewRef_;\n    }());\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$12 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    var EventListener = (function () {\n        function EventListener(name, callback) {\n            this.name = name;\n            this.callback = callback;\n        }\n        ;\n        return EventListener;\n    }());\n    /**\n     * @experimental All debugging apis are currently experimental.\n     */\n    var DebugNode = (function () {\n        function DebugNode(nativeNode, parent, _debugInfo) {\n            this._debugInfo = _debugInfo;\n            this.nativeNode = nativeNode;\n            if (isPresent(parent) && parent instanceof DebugElement) {\n                parent.addChild(this);\n            }\n            else {\n                this.parent = null;\n            }\n            this.listeners = [];\n        }\n        Object.defineProperty(DebugNode.prototype, \"injector\", {\n            get: function () { return isPresent(this._debugInfo) ? this._debugInfo.injector : null; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(DebugNode.prototype, \"componentInstance\", {\n            get: function () {\n                return isPresent(this._debugInfo) ? this._debugInfo.component : null;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(DebugNode.prototype, \"context\", {\n            get: function () { return isPresent(this._debugInfo) ? this._debugInfo.context : null; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(DebugNode.prototype, \"references\", {\n            get: function () {\n                return isPresent(this._debugInfo) ? this._debugInfo.references : null;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(DebugNode.prototype, \"providerTokens\", {\n            get: function () {\n                return isPresent(this._debugInfo) ? this._debugInfo.providerTokens : null;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(DebugNode.prototype, \"source\", {\n            get: function () { return isPresent(this._debugInfo) ? this._debugInfo.source : null; },\n            enumerable: true,\n            configurable: true\n        });\n        return DebugNode;\n    }());\n    /**\n     * @experimental All debugging apis are currently experimental.\n     */\n    var DebugElement = (function (_super) {\n        __extends$12(DebugElement, _super);\n        function DebugElement(nativeNode, parent, _debugInfo) {\n            _super.call(this, nativeNode, parent, _debugInfo);\n            this.properties = {};\n            this.attributes = {};\n            this.classes = {};\n            this.styles = {};\n            this.childNodes = [];\n            this.nativeElement = nativeNode;\n        }\n        DebugElement.prototype.addChild = function (child) {\n            if (isPresent(child)) {\n                this.childNodes.push(child);\n                child.parent = this;\n            }\n        };\n        DebugElement.prototype.removeChild = function (child) {\n            var childIndex = this.childNodes.indexOf(child);\n            if (childIndex !== -1) {\n                child.parent = null;\n                this.childNodes.splice(childIndex, 1);\n            }\n        };\n        DebugElement.prototype.insertChildrenAfter = function (child, newChildren) {\n            var siblingIndex = this.childNodes.indexOf(child);\n            if (siblingIndex !== -1) {\n                var previousChildren = this.childNodes.slice(0, siblingIndex + 1);\n                var nextChildren = this.childNodes.slice(siblingIndex + 1);\n                this.childNodes =\n                    ListWrapper.concat(ListWrapper.concat(previousChildren, newChildren), nextChildren);\n                for (var i = 0; i < newChildren.length; ++i) {\n                    var newChild = newChildren[i];\n                    if (isPresent(newChild.parent)) {\n                        newChild.parent.removeChild(newChild);\n                    }\n                    newChild.parent = this;\n                }\n            }\n        };\n        DebugElement.prototype.query = function (predicate) {\n            var results = this.queryAll(predicate);\n            return results.length > 0 ? results[0] : null;\n        };\n        DebugElement.prototype.queryAll = function (predicate) {\n            var matches = [];\n            _queryElementChildren(this, predicate, matches);\n            return matches;\n        };\n        DebugElement.prototype.queryAllNodes = function (predicate) {\n            var matches = [];\n            _queryNodeChildren(this, predicate, matches);\n            return matches;\n        };\n        Object.defineProperty(DebugElement.prototype, \"children\", {\n            get: function () {\n                var children = [];\n                this.childNodes.forEach(function (node) {\n                    if (node instanceof DebugElement) {\n                        children.push(node);\n                    }\n                });\n                return children;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        DebugElement.prototype.triggerEventHandler = function (eventName, eventObj) {\n            this.listeners.forEach(function (listener) {\n                if (listener.name == eventName) {\n                    listener.callback(eventObj);\n                }\n            });\n        };\n        return DebugElement;\n    }(DebugNode));\n    /**\n     * @experimental\n     */\n    function asNativeElements(debugEls) {\n        return debugEls.map(function (el) { return el.nativeElement; });\n    }\n    function _queryElementChildren(element, predicate, matches) {\n        element.childNodes.forEach(function (node) {\n            if (node instanceof DebugElement) {\n                if (predicate(node)) {\n                    matches.push(node);\n                }\n                _queryElementChildren(node, predicate, matches);\n            }\n        });\n    }\n    function _queryNodeChildren(parentNode, predicate, matches) {\n        if (parentNode instanceof DebugElement) {\n            parentNode.childNodes.forEach(function (node) {\n                if (predicate(node)) {\n                    matches.push(node);\n                }\n                if (node instanceof DebugElement) {\n                    _queryNodeChildren(node, predicate, matches);\n                }\n            });\n        }\n    }\n    // Need to keep the nodes in a global Map so that multiple angular apps are supported.\n    var _nativeNodeToDebugNode = new Map();\n    /**\n     * @experimental\n     */\n    function getDebugNode(nativeNode) {\n        return _nativeNodeToDebugNode.get(nativeNode);\n    }\n    function indexDebugNode(node) {\n        _nativeNodeToDebugNode.set(node.nativeNode, node);\n    }\n    function removeDebugNodeFromIndex(node) {\n        _nativeNodeToDebugNode.delete(node.nativeNode);\n    }\n\n    function _reflector() {\n        return reflector;\n    }\n    var _CORE_PLATFORM_PROVIDERS = [\n        PlatformRef_,\n        { provide: PlatformRef, useExisting: PlatformRef_ },\n        { provide: Reflector, useFactory: _reflector, deps: [] },\n        { provide: ReflectorReader, useExisting: Reflector },\n        TestabilityRegistry,\n        Console,\n    ];\n    /**\n     * This platform has to be included in any other platform\n     *\n     * @experimental\n     */\n    var platformCore = createPlatformFactory(null, 'core', _CORE_PLATFORM_PROVIDERS);\n\n    /**\n     * @experimental i18n support is experimental.\n     */\n    var LOCALE_ID = new OpaqueToken('LocaleId');\n    /**\n     * @experimental i18n support is experimental.\n     */\n    var TRANSLATIONS = new OpaqueToken('Translations');\n    /**\n     * @experimental i18n support is experimental.\n     */\n    var TRANSLATIONS_FORMAT = new OpaqueToken('TranslationsFormat');\n\n    function _iterableDiffersFactory() {\n        return defaultIterableDiffers;\n    }\n    function _keyValueDiffersFactory() {\n        return defaultKeyValueDiffers;\n    }\n    /**\n     * This module includes the providers of @angular/core that are needed\n     * to bootstrap components via `ApplicationRef`.\n     *\n     * @experimental\n     */\n    var ApplicationModule = (function () {\n        function ApplicationModule() {\n        }\n        ApplicationModule.decorators = [\n            { type: NgModule, args: [{\n                        providers: [\n                            ApplicationRef_,\n                            { provide: ApplicationRef, useExisting: ApplicationRef_ },\n                            ApplicationInitStatus,\n                            Compiler,\n                            APP_ID_RANDOM_PROVIDER,\n                            ViewUtils,\n                            { provide: IterableDiffers, useFactory: _iterableDiffersFactory },\n                            { provide: KeyValueDiffers, useFactory: _keyValueDiffersFactory },\n                            { provide: LOCALE_ID, useValue: 'en-US' },\n                        ]\n                    },] },\n        ];\n        /** @nocollapse */\n        ApplicationModule.ctorParameters = [];\n        return ApplicationModule;\n    }());\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var FILL_STYLE_FLAG = 'true'; // TODO (matsko): change to boolean\n    var ANY_STATE = '*';\n    var DEFAULT_STATE = '*';\n    var EMPTY_STATE = 'void';\n\n    var Math$1 = global$1.Math;\n\n    var AnimationGroupPlayer = (function () {\n        function AnimationGroupPlayer(_players) {\n            var _this = this;\n            this._players = _players;\n            this._onDoneFns = [];\n            this._onStartFns = [];\n            this._finished = false;\n            this._started = false;\n            this.parentPlayer = null;\n            var count = 0;\n            var total = this._players.length;\n            if (total == 0) {\n                scheduleMicroTask(function () { return _this._onFinish(); });\n            }\n            else {\n                this._players.forEach(function (player) {\n                    player.parentPlayer = _this;\n                    player.onDone(function () {\n                        if (++count >= total) {\n                            _this._onFinish();\n                        }\n                    });\n                });\n            }\n        }\n        AnimationGroupPlayer.prototype._onFinish = function () {\n            if (!this._finished) {\n                this._finished = true;\n                if (!isPresent(this.parentPlayer)) {\n                    this.destroy();\n                }\n                this._onDoneFns.forEach(function (fn) { return fn(); });\n                this._onDoneFns = [];\n            }\n        };\n        AnimationGroupPlayer.prototype.init = function () { this._players.forEach(function (player) { return player.init(); }); };\n        AnimationGroupPlayer.prototype.onStart = function (fn) { this._onStartFns.push(fn); };\n        AnimationGroupPlayer.prototype.onDone = function (fn) { this._onDoneFns.push(fn); };\n        AnimationGroupPlayer.prototype.hasStarted = function () { return this._started; };\n        AnimationGroupPlayer.prototype.play = function () {\n            if (!isPresent(this.parentPlayer)) {\n                this.init();\n            }\n            if (!this.hasStarted()) {\n                this._onStartFns.forEach(function (fn) { return fn(); });\n                this._onStartFns = [];\n                this._started = true;\n            }\n            this._players.forEach(function (player) { return player.play(); });\n        };\n        AnimationGroupPlayer.prototype.pause = function () { this._players.forEach(function (player) { return player.pause(); }); };\n        AnimationGroupPlayer.prototype.restart = function () { this._players.forEach(function (player) { return player.restart(); }); };\n        AnimationGroupPlayer.prototype.finish = function () {\n            this._onFinish();\n            this._players.forEach(function (player) { return player.finish(); });\n        };\n        AnimationGroupPlayer.prototype.destroy = function () {\n            this._onFinish();\n            this._players.forEach(function (player) { return player.destroy(); });\n        };\n        AnimationGroupPlayer.prototype.reset = function () { this._players.forEach(function (player) { return player.reset(); }); };\n        AnimationGroupPlayer.prototype.setPosition = function (p /** TODO #9100 */) {\n            this._players.forEach(function (player) { player.setPosition(p); });\n        };\n        AnimationGroupPlayer.prototype.getPosition = function () {\n            var min = 0;\n            this._players.forEach(function (player) {\n                var p = player.getPosition();\n                min = Math$1.min(p, min);\n            });\n            return min;\n        };\n        return AnimationGroupPlayer;\n    }());\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var AnimationKeyframe = (function () {\n        function AnimationKeyframe(offset, styles) {\n            this.offset = offset;\n            this.styles = styles;\n        }\n        return AnimationKeyframe;\n    }());\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var AnimationOutput = (function () {\n        function AnimationOutput(name, phase, fullPropertyName) {\n            this.name = name;\n            this.phase = phase;\n            this.fullPropertyName = fullPropertyName;\n        }\n        return AnimationOutput;\n    }());\n\n    /**\n     * @experimental Animation support is experimental.\n     */\n    var AnimationPlayer = (function () {\n        function AnimationPlayer() {\n        }\n        Object.defineProperty(AnimationPlayer.prototype, \"parentPlayer\", {\n            get: function () { throw new Error('NOT IMPLEMENTED: Base Class'); },\n            set: function (player) { throw new Error('NOT IMPLEMENTED: Base Class'); },\n            enumerable: true,\n            configurable: true\n        });\n        return AnimationPlayer;\n    }());\n    var NoOpAnimationPlayer = (function () {\n        function NoOpAnimationPlayer() {\n            var _this = this;\n            this._onDoneFns = [];\n            this._onStartFns = [];\n            this._started = false;\n            this.parentPlayer = null;\n            scheduleMicroTask(function () { return _this._onFinish(); });\n        }\n        /** @internal */\n        NoOpAnimationPlayer.prototype._onFinish = function () {\n            this._onDoneFns.forEach(function (fn) { return fn(); });\n            this._onDoneFns = [];\n        };\n        NoOpAnimationPlayer.prototype.onStart = function (fn) { this._onStartFns.push(fn); };\n        NoOpAnimationPlayer.prototype.onDone = function (fn) { this._onDoneFns.push(fn); };\n        NoOpAnimationPlayer.prototype.hasStarted = function () { return this._started; };\n        NoOpAnimationPlayer.prototype.init = function () { };\n        NoOpAnimationPlayer.prototype.play = function () {\n            if (!this.hasStarted()) {\n                this._onStartFns.forEach(function (fn) { return fn(); });\n                this._onStartFns = [];\n            }\n            this._started = true;\n        };\n        NoOpAnimationPlayer.prototype.pause = function () { };\n        NoOpAnimationPlayer.prototype.restart = function () { };\n        NoOpAnimationPlayer.prototype.finish = function () { this._onFinish(); };\n        NoOpAnimationPlayer.prototype.destroy = function () { };\n        NoOpAnimationPlayer.prototype.reset = function () { };\n        NoOpAnimationPlayer.prototype.setPosition = function (p /** TODO #9100 */) { };\n        NoOpAnimationPlayer.prototype.getPosition = function () { return 0; };\n        return NoOpAnimationPlayer;\n    }());\n\n    var AnimationSequencePlayer = (function () {\n        function AnimationSequencePlayer(_players) {\n            var _this = this;\n            this._players = _players;\n            this._currentIndex = 0;\n            this._onDoneFns = [];\n            this._onStartFns = [];\n            this._finished = false;\n            this._started = false;\n            this.parentPlayer = null;\n            this._players.forEach(function (player) { player.parentPlayer = _this; });\n            this._onNext(false);\n        }\n        AnimationSequencePlayer.prototype._onNext = function (start) {\n            var _this = this;\n            if (this._finished)\n                return;\n            if (this._players.length == 0) {\n                this._activePlayer = new NoOpAnimationPlayer();\n                scheduleMicroTask(function () { return _this._onFinish(); });\n            }\n            else if (this._currentIndex >= this._players.length) {\n                this._activePlayer = new NoOpAnimationPlayer();\n                this._onFinish();\n            }\n            else {\n                var player = this._players[this._currentIndex++];\n                player.onDone(function () { return _this._onNext(true); });\n                this._activePlayer = player;\n                if (start) {\n                    player.play();\n                }\n            }\n        };\n        AnimationSequencePlayer.prototype._onFinish = function () {\n            if (!this._finished) {\n                this._finished = true;\n                if (!isPresent(this.parentPlayer)) {\n                    this.destroy();\n                }\n                this._onDoneFns.forEach(function (fn) { return fn(); });\n                this._onDoneFns = [];\n            }\n        };\n        AnimationSequencePlayer.prototype.init = function () { this._players.forEach(function (player) { return player.init(); }); };\n        AnimationSequencePlayer.prototype.onStart = function (fn) { this._onStartFns.push(fn); };\n        AnimationSequencePlayer.prototype.onDone = function (fn) { this._onDoneFns.push(fn); };\n        AnimationSequencePlayer.prototype.hasStarted = function () { return this._started; };\n        AnimationSequencePlayer.prototype.play = function () {\n            if (!isPresent(this.parentPlayer)) {\n                this.init();\n            }\n            if (!this.hasStarted()) {\n                this._onStartFns.forEach(function (fn) { return fn(); });\n                this._onStartFns = [];\n                this._started = true;\n            }\n            this._activePlayer.play();\n        };\n        AnimationSequencePlayer.prototype.pause = function () { this._activePlayer.pause(); };\n        AnimationSequencePlayer.prototype.restart = function () {\n            if (this._players.length > 0) {\n                this.reset();\n                this._players[0].restart();\n            }\n        };\n        AnimationSequencePlayer.prototype.reset = function () { this._players.forEach(function (player) { return player.reset(); }); };\n        AnimationSequencePlayer.prototype.finish = function () {\n            this._onFinish();\n            this._players.forEach(function (player) { return player.finish(); });\n        };\n        AnimationSequencePlayer.prototype.destroy = function () {\n            this._onFinish();\n            this._players.forEach(function (player) { return player.destroy(); });\n        };\n        AnimationSequencePlayer.prototype.setPosition = function (p /** TODO #9100 */) { this._players[0].setPosition(p); };\n        AnimationSequencePlayer.prototype.getPosition = function () { return this._players[0].getPosition(); };\n        return AnimationSequencePlayer;\n    }());\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$13 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    /**\n     * @experimental Animation support is experimental.\n     */\n    var AUTO_STYLE = '*';\n    /**\n     * Metadata representing the entry of animations.\n     * Instances of this class are provided via the animation DSL when the {@link trigger trigger\n     * animation function} is called.\n     *\n     * @experimental Animation support is experimental.\n     */\n    var AnimationEntryMetadata = (function () {\n        function AnimationEntryMetadata(name, definitions) {\n            this.name = name;\n            this.definitions = definitions;\n        }\n        return AnimationEntryMetadata;\n    }());\n    /**\n     * @experimental Animation support is experimental.\n     */\n    var AnimationStateMetadata = (function () {\n        function AnimationStateMetadata() {\n        }\n        return AnimationStateMetadata;\n    }());\n    /**\n     * Metadata representing the entry of animations.\n     * Instances of this class are provided via the animation DSL when the {@link state state animation\n     * function} is called.\n     *\n     * @experimental Animation support is experimental.\n     */\n    var AnimationStateDeclarationMetadata = (function (_super) {\n        __extends$13(AnimationStateDeclarationMetadata, _super);\n        function AnimationStateDeclarationMetadata(stateNameExpr, styles) {\n            _super.call(this);\n            this.stateNameExpr = stateNameExpr;\n            this.styles = styles;\n        }\n        return AnimationStateDeclarationMetadata;\n    }(AnimationStateMetadata));\n    /**\n     * Metadata representing the entry of animations.\n     * Instances of this class are provided via the animation DSL when the\n     * {@link transition transition animation function} is called.\n     *\n     * @experimental Animation support is experimental.\n     */\n    var AnimationStateTransitionMetadata = (function (_super) {\n        __extends$13(AnimationStateTransitionMetadata, _super);\n        function AnimationStateTransitionMetadata(stateChangeExpr, steps) {\n            _super.call(this);\n            this.stateChangeExpr = stateChangeExpr;\n            this.steps = steps;\n        }\n        return AnimationStateTransitionMetadata;\n    }(AnimationStateMetadata));\n    /**\n     * @experimental Animation support is experimental.\n     */\n    var AnimationMetadata = (function () {\n        function AnimationMetadata() {\n        }\n        return AnimationMetadata;\n    }());\n    /**\n     * Metadata representing the entry of animations.\n     * Instances of this class are provided via the animation DSL when the {@link keyframes keyframes\n     * animation function} is called.\n     *\n     * @experimental Animation support is experimental.\n     */\n    var AnimationKeyframesSequenceMetadata = (function (_super) {\n        __extends$13(AnimationKeyframesSequenceMetadata, _super);\n        function AnimationKeyframesSequenceMetadata(steps) {\n            _super.call(this);\n            this.steps = steps;\n        }\n        return AnimationKeyframesSequenceMetadata;\n    }(AnimationMetadata));\n    /**\n     * Metadata representing the entry of animations.\n     * Instances of this class are provided via the animation DSL when the {@link style style animation\n     * function} is called.\n     *\n     * @experimental Animation support is experimental.\n     */\n    var AnimationStyleMetadata = (function (_super) {\n        __extends$13(AnimationStyleMetadata, _super);\n        function AnimationStyleMetadata(styles, offset) {\n            if (offset === void 0) { offset = null; }\n            _super.call(this);\n            this.styles = styles;\n            this.offset = offset;\n        }\n        return AnimationStyleMetadata;\n    }(AnimationMetadata));\n    /**\n     * Metadata representing the entry of animations.\n     * Instances of this class are provided via the animation DSL when the {@link animate animate\n     * animation function} is called.\n     *\n     * @experimental Animation support is experimental.\n     */\n    var AnimationAnimateMetadata = (function (_super) {\n        __extends$13(AnimationAnimateMetadata, _super);\n        function AnimationAnimateMetadata(timings, styles) {\n            _super.call(this);\n            this.timings = timings;\n            this.styles = styles;\n        }\n        return AnimationAnimateMetadata;\n    }(AnimationMetadata));\n    /**\n     * @experimental Animation support is experimental.\n     */\n    var AnimationWithStepsMetadata = (function (_super) {\n        __extends$13(AnimationWithStepsMetadata, _super);\n        function AnimationWithStepsMetadata() {\n            _super.call(this);\n        }\n        Object.defineProperty(AnimationWithStepsMetadata.prototype, \"steps\", {\n            get: function () { throw new Error('NOT IMPLEMENTED: Base Class'); },\n            enumerable: true,\n            configurable: true\n        });\n        return AnimationWithStepsMetadata;\n    }(AnimationMetadata));\n    /**\n     * Metadata representing the entry of animations.\n     * Instances of this class are provided via the animation DSL when the {@link sequence sequence\n     * animation function} is called.\n     *\n     * @experimental Animation support is experimental.\n     */\n    var AnimationSequenceMetadata = (function (_super) {\n        __extends$13(AnimationSequenceMetadata, _super);\n        function AnimationSequenceMetadata(_steps) {\n            _super.call(this);\n            this._steps = _steps;\n        }\n        Object.defineProperty(AnimationSequenceMetadata.prototype, \"steps\", {\n            get: function () { return this._steps; },\n            enumerable: true,\n            configurable: true\n        });\n        return AnimationSequenceMetadata;\n    }(AnimationWithStepsMetadata));\n    /**\n     * Metadata representing the entry of animations.\n     * Instances of this class are provided via the animation DSL when the {@link group group animation\n     * function} is called.\n     *\n     * @experimental Animation support is experimental.\n     */\n    var AnimationGroupMetadata = (function (_super) {\n        __extends$13(AnimationGroupMetadata, _super);\n        function AnimationGroupMetadata(_steps) {\n            _super.call(this);\n            this._steps = _steps;\n        }\n        Object.defineProperty(AnimationGroupMetadata.prototype, \"steps\", {\n            get: function () { return this._steps; },\n            enumerable: true,\n            configurable: true\n        });\n        return AnimationGroupMetadata;\n    }(AnimationWithStepsMetadata));\n    /**\n     * `animate` is an animation-specific function that is designed to be used inside of Angular2's\n     * animation\n     * DSL language. If this information is new, please navigate to the\n     * {@link Component#animations-anchor component animations metadata\n     * page} to gain a better understanding of how animations in Angular2 are used.\n     *\n     * `animate` specifies an animation step that will apply the provided `styles` data for a given\n     * amount of\n     * time based on the provided `timing` expression value. Calls to `animate` are expected to be\n     * used within {@link sequence an animation sequence}, {@link group group}, or {@link transition\n     * transition}.\n     *\n     * ### Usage\n     *\n     * The `animate` function accepts two input parameters: `timing` and `styles`:\n     *\n     * - `timing` is a string based value that can be a combination of a duration with optional\n     * delay and easing values. The format for the expression breaks down to `duration delay easing`\n     * (therefore a value such as `1s 100ms ease-out` will be parse itself into `duration=1000,\n     * delay=100, easing=ease-out`.\n     * If a numeric value is provided then that will be used as the `duration` value in millisecond\n     * form.\n     * - `styles` is the style input data which can either be a call to {@link style style} or {@link\n     * keyframes keyframes}.\n     * If left empty then the styles from the destination state will be collected and used (this is\n     * useful when\n     * describing an animation step that will complete an animation by {@link\n     * transition#the-final-animate-call animating to the final state}).\n     *\n     * ```typescript\n     * // various functions for specifying timing data\n     * animate(500, style(...))\n     * animate(\"1s\", style(...))\n     * animate(\"100ms 0.5s\", style(...))\n     * animate(\"5s ease\", style(...))\n     * animate(\"5s 10ms cubic-bezier(.17,.67,.88,.1)\", style(...))\n     *\n     * // either style() of keyframes() can be used\n     * animate(500, style({ background: \"red\" }))\n     * animate(500, keyframes([\n     *   style({ background: \"blue\" })),\n     *   style({ background: \"red\" }))\n     * ])\n     * ```\n     *\n     * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))\n     *\n     * {@example core/animation/ts/dsl/animation_example.ts region='Component'}\n     *\n     * @experimental Animation support is experimental.\n     */\n    function animate(timing, styles) {\n        if (styles === void 0) { styles = null; }\n        var stylesEntry = styles;\n        if (!isPresent(stylesEntry)) {\n            var EMPTY_STYLE = {};\n            stylesEntry = new AnimationStyleMetadata([EMPTY_STYLE], 1);\n        }\n        return new AnimationAnimateMetadata(timing, stylesEntry);\n    }\n    /**\n     * `group` is an animation-specific function that is designed to be used inside of Angular2's\n     * animation\n     * DSL language. If this information is new, please navigate to the\n     * {@link Component#animations-anchor component animations metadata\n     * page} to gain a better understanding of how animations in Angular2 are used.\n     *\n     * `group` specifies a list of animation steps that are all run in parallel. Grouped animations\n     * are useful when a series of styles must be animated/closed off\n     * at different statrting/ending times.\n     *\n     * The `group` function can either be used within a {@link sequence sequence} or a {@link transition\n     * transition}\n     * and it will only continue to the next instruction once all of the inner animation steps\n     * have completed.\n     *\n     * ### Usage\n     *\n     * The `steps` data that is passed into the `group` animation function can either consist\n     * of {@link style style} or {@link animate animate} function calls. Each call to `style()` or\n     * `animate()`\n     * within a group will be executed instantly (use {@link keyframes keyframes} or a\n     * {@link animate#usage animate() with a delay value} to offset styles to be applied at a later\n     * time).\n     *\n     * ```typescript\n     * group([\n     *   animate(\"1s\", { background: \"black\" }))\n     *   animate(\"2s\", { color: \"white\" }))\n     * ])\n     * ```\n     *\n     * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))\n     *\n     * {@example core/animation/ts/dsl/animation_example.ts region='Component'}\n     *\n     * @experimental Animation support is experimental.\n     */\n    function group(steps) {\n        return new AnimationGroupMetadata(steps);\n    }\n    /**\n     * `sequence` is an animation-specific function that is designed to be used inside of Angular2's\n     * animation\n     * DSL language. If this information is new, please navigate to the\n     * {@link Component#animations-anchor component animations metadata\n     * page} to gain a better understanding of how animations in Angular2 are used.\n     *\n     * `sequence` Specifies a list of animation steps that are run one by one. (`sequence` is used\n     * by default when an array is passed as animation data into {@link transition transition}.)\n     *\n     * The `sequence` function can either be used within a {@link group group} or a {@link transition\n     * transition}\n     * and it will only continue to the next instruction once each of the inner animation steps\n     * have completed.\n     *\n     * To perform animation styling in parallel with other animation steps then\n     * have a look at the {@link group group} animation function.\n     *\n     * ### Usage\n     *\n     * The `steps` data that is passed into the `sequence` animation function can either consist\n     * of {@link style style} or {@link animate animate} function calls. A call to `style()` will apply\n     * the\n     * provided styling data immediately while a call to `animate()` will apply its styling\n     * data over a given time depending on its timing data.\n     *\n     * ```typescript\n     * sequence([\n     *   style({ opacity: 0 })),\n     *   animate(\"1s\", { opacity: 1 }))\n     * ])\n     * ```\n     *\n     * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))\n     *\n     * {@example core/animation/ts/dsl/animation_example.ts region='Component'}\n     *\n     * @experimental Animation support is experimental.\n     */\n    function sequence(steps) {\n        return new AnimationSequenceMetadata(steps);\n    }\n    /**\n     * `style` is an animation-specific function that is designed to be used inside of Angular2's\n     * animation\n     * DSL language. If this information is new, please navigate to the\n     * {@link Component#animations-anchor component animations metadata\n     * page} to gain a better understanding of how animations in Angular2 are used.\n     *\n     * `style` declares a key/value object containing CSS properties/styles that can then\n     * be used for {@link state animation states}, within an {@link sequence animation sequence}, or as\n     * styling data for both {@link animate animate} and {@link keyframes keyframes}.\n     *\n     * ### Usage\n     *\n     * `style` takes in a key/value string map as data and expects one or more CSS property/value\n     * pairs to be defined.\n     *\n     * ```typescript\n     * // string values are used for css properties\n     * style({ background: \"red\", color: \"blue\" })\n     *\n     * // numerical (pixel) values are also supported\n     * style({ width: 100, height: 0 })\n     * ```\n     *\n     * #### Auto-styles (using `*`)\n     *\n     * When an asterix (`*`) character is used as a value then it will be detected from the element\n     * being animated\n     * and applied as animation data when the animation starts.\n     *\n     * This feature proves useful for a state depending on layout and/or environment factors; in such\n     * cases\n     * the styles are calculated just before the animation starts.\n     *\n     * ```typescript\n     * // the steps below will animate from 0 to the\n     * // actual height of the element\n     * style({ height: 0 }),\n     * animate(\"1s\", style({ height: \"*\" }))\n     * ```\n     *\n     * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))\n     *\n     * {@example core/animation/ts/dsl/animation_example.ts region='Component'}\n     *\n     * @experimental Animation support is experimental.\n     */\n    function style(tokens) {\n        var input;\n        var offset = null;\n        if (isString(tokens)) {\n            input = [tokens];\n        }\n        else {\n            if (isArray(tokens)) {\n                input = tokens;\n            }\n            else {\n                input = [tokens];\n            }\n            input.forEach(function (entry) {\n                var entryOffset = entry['offset'];\n                if (isPresent(entryOffset)) {\n                    offset = offset == null ? parseFloat(entryOffset) : offset;\n                }\n            });\n        }\n        return new AnimationStyleMetadata(input, offset);\n    }\n    /**\n     * `state` is an animation-specific function that is designed to be used inside of Angular2's\n     * animation\n     * DSL language. If this information is new, please navigate to the\n     * {@link Component#animations-anchor component animations metadata\n     * page} to gain a better understanding of how animations in Angular2 are used.\n     *\n     * `state` declares an animation state within the given trigger. When a state is\n     * active within a component then its associated styles will persist on\n     * the element that the trigger is attached to (even when the animation ends).\n     *\n     * To animate between states, have a look at the animation {@link transition transition}\n     * DSL function. To register states to an animation trigger please have a look\n     * at the {@link trigger trigger} function.\n     *\n     * #### The `void` state\n     *\n     * The `void` state value is a reserved word that angular uses to determine when the element is not\n     * apart\n     * of the application anymore (e.g. when an `ngIf` evaluates to false then the state of the\n     * associated element\n     * is void).\n     *\n     * #### The `*` (default) state\n     *\n     * The `*` state (when styled) is a fallback state that will be used if\n     * the state that is being animated is not declared within the trigger.\n     *\n     * ### Usage\n     *\n     * `state` will declare an animation state with its associated styles\n     * within the given trigger.\n     *\n     * - `stateNameExpr` can be one or more state names separated by commas.\n     * - `styles` refers to the {@link style styling data} that will be persisted on the element once\n     * the state\n     * has been reached.\n     *\n     * ```typescript\n     * // \"void\" is a reserved name for a state and is used to represent\n     * // the state in which an element is detached from from the application.\n     * state(\"void\", style({ height: 0 }))\n     *\n     * // user-defined states\n     * state(\"closed\", style({ height: 0 }))\n     * state(\"open, visible\", style({ height: \"*\" }))\n     * ```\n     *\n     * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))\n     *\n     * {@example core/animation/ts/dsl/animation_example.ts region='Component'}\n     *\n     * @experimental Animation support is experimental.\n     */\n    function state(stateNameExpr, styles) {\n        return new AnimationStateDeclarationMetadata(stateNameExpr, styles);\n    }\n    /**\n     * `keyframes` is an animation-specific function that is designed to be used inside of Angular2's\n     * animation\n     * DSL language. If this information is new, please navigate to the\n     * {@link Component#animations-anchor component animations metadata\n     * page} to gain a better understanding of how animations in Angular2 are used.\n     *\n     * `keyframes` specifies a collection of {@link style style} entries each optionally characterized\n     * by an `offset` value.\n     *\n     * ### Usage\n     *\n     * The `keyframes` animation function is designed to be used alongside the {@link animate animate}\n     * animation function. Instead of applying animations from where they are\n     * currently to their destination, keyframes can describe how each style entry is applied\n     * and at what point within the animation arc (much like CSS Keyframe Animations do).\n     *\n     * For each `style()` entry an `offset` value can be set. Doing so allows to specifiy at\n     * what percentage of the animate time the styles will be applied.\n     *\n     * ```typescript\n     * // the provided offset values describe when each backgroundColor value is applied.\n     * animate(\"5s\", keyframes([\n     *   style({ backgroundColor: \"red\", offset: 0 }),\n     *   style({ backgroundColor: \"blue\", offset: 0.2 }),\n     *   style({ backgroundColor: \"orange\", offset: 0.3 }),\n     *   style({ backgroundColor: \"black\", offset: 1 })\n     * ]))\n     * ```\n     *\n     * Alternatively, if there are no `offset` values used within the style entries then the offsets\n     * will\n     * be calculated automatically.\n     *\n     * ```typescript\n     * animate(\"5s\", keyframes([\n     *   style({ backgroundColor: \"red\" }) // offset = 0\n     *   style({ backgroundColor: \"blue\" }) // offset = 0.33\n     *   style({ backgroundColor: \"orange\" }) // offset = 0.66\n     *   style({ backgroundColor: \"black\" }) // offset = 1\n     * ]))\n     * ```\n     *\n     * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))\n     *\n     * {@example core/animation/ts/dsl/animation_example.ts region='Component'}\n     *\n     * @experimental Animation support is experimental.\n     */\n    function keyframes(steps) {\n        return new AnimationKeyframesSequenceMetadata(steps);\n    }\n    /**\n     * `transition` is an animation-specific function that is designed to be used inside of Angular2's\n     * animation\n     * DSL language. If this information is new, please navigate to the\n     * {@link Component#animations-anchor component animations metadata\n     * page} to gain a better understanding of how animations in Angular2 are used.\n     *\n     * `transition` declares the {@link sequence sequence of animation steps} that will be run when the\n     * provided\n     * `stateChangeExpr` value is satisfied. The `stateChangeExpr` consists of a `state1 => state2`\n     * which consists\n     * of two known states (use an asterix (`*`) to refer to a dynamic starting and/or ending state).\n     *\n     * Animation transitions are placed within an {@link trigger animation trigger}. For an transition\n     * to animate to\n     * a state value and persist its styles then one or more {@link state animation states} is expected\n     * to be defined.\n     *\n     * ### Usage\n     *\n     * An animation transition is kicked off the `stateChangeExpr` predicate evaluates to true based on\n     * what the\n     * previous state is and what the current state has become. In other words, if a transition is\n     * defined that\n     * matches the old/current state criteria then the associated animation will be triggered.\n     *\n     * ```typescript\n     * // all transition/state changes are defined within an animation trigger\n     * trigger(\"myAnimationTrigger\", [\n     *   // if a state is defined then its styles will be persisted when the\n     *   // animation has fully completed itself\n     *   state(\"on\", style({ background: \"green\" })),\n     *   state(\"off\", style({ background: \"grey\" })),\n     *\n     *   // a transition animation that will be kicked off when the state value\n     *   // bound to \"myAnimationTrigger\" changes from \"on\" to \"off\"\n     *   transition(\"on => off\", animate(500)),\n     *\n     *   // it is also possible to do run the same animation for both directions\n     *   transition(\"on <=> off\", animate(500)),\n     *\n     *   // or to define multiple states pairs separated by commas\n     *   transition(\"on => off, off => void\", animate(500)),\n     *\n     *   // this is a catch-all state change for when an element is inserted into\n     *   // the page and the destination state is unknown\n     *   transition(\"void => *\", [\n     *     style({ opacity: 0 }),\n     *     animate(500)\n     *   ]),\n     *\n     *   // this will capture a state change between any states\n     *   transition(\"* => *\", animate(\"1s 0s\")),\n     * ])\n     * ```\n     *\n     * The template associated with this component will make use of the `myAnimationTrigger`\n     * animation trigger by binding to an element within its template code.\n     *\n     * ```html\n     * <!-- somewhere inside of my-component-tpl.html -->\n     * <div [@myAnimationTrigger]=\"myStatusExp\">...</div>\n     * ```\n     *\n     * #### The final `animate` call\n     *\n     * If the final step within the transition steps is a call to `animate()` that **only**\n     * uses a timing value with **no style data** then it will be automatically used as the final\n     * animation\n     * arc for the element to animate itself to the final state. This involves an automatic mix of\n     * adding/removing CSS styles so that the element will be in the exact state it should be for the\n     * applied state to be presented correctly.\n     *\n     * ```\n     * // start off by hiding the element, but make sure that it animates properly to whatever state\n     * // is currently active for \"myAnimationTrigger\"\n     * transition(\"void => *\", [\n     *   style({ opacity: 0 }),\n     *   animate(500)\n     * ])\n     * ```\n     *\n     * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))\n     *\n     * {@example core/animation/ts/dsl/animation_example.ts region='Component'}\n     *\n     * @experimental Animation support is experimental.\n     */\n    function transition(stateChangeExpr, steps) {\n        var animationData = isArray(steps) ? new AnimationSequenceMetadata(steps) :\n            steps;\n        return new AnimationStateTransitionMetadata(stateChangeExpr, animationData);\n    }\n    /**\n     * `trigger` is an animation-specific function that is designed to be used inside of Angular2's\n     * animation\n     * DSL language. If this information is new, please navigate to the\n     * {@link Component#animations-anchor component animations metadata\n     * page} to gain a better understanding of how animations in Angular2 are used.\n     *\n     * `trigger` Creates an animation trigger which will a list of {@link state state} and {@link\n     * transition transition}\n     * entries that will be evaluated when the expression bound to the trigger changes.\n     *\n     * Triggers are registered within the component annotation data under the\n     * {@link Component#animations-anchor animations section}. An animation trigger can\n     * be placed on an element within a template by referencing the name of the\n     * trigger followed by the expression value that the trigger is bound to\n     * (in the form of `[@triggerName]=\"expression\"`.\n     *\n     * ### Usage\n     *\n     * `trigger` will create an animation trigger reference based on the provided `name` value.\n     * The provided `animation` value is expected to be an array consisting of {@link state state} and\n     * {@link transition transition}\n     * declarations.\n     *\n     * ```typescript\n     * @Component({\n     *   selector: 'my-component',\n     *   templateUrl: 'my-component-tpl.html',\n     *   animations: [\n     *     trigger(\"myAnimationTrigger\", [\n     *       state(...),\n     *       state(...),\n     *       transition(...),\n     *       transition(...)\n     *     ])\n     *   ]\n     * })\n     * class MyComponent {\n     *   myStatusExp = \"something\";\n     * }\n     * ```\n     *\n     * The template associated with this component will make use of the `myAnimationTrigger`\n     * animation trigger by binding to an element within its template code.\n     *\n     * ```html\n     * <!-- somewhere inside of my-component-tpl.html -->\n     * <div [@myAnimationTrigger]=\"myStatusExp\">...</div>\n     * ```\n     *\n     * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))\n     *\n     * {@example core/animation/ts/dsl/animation_example.ts region='Component'}\n     *\n     * @experimental Animation support is experimental.\n     */\n    function trigger(name, animation) {\n        return new AnimationEntryMetadata(name, animation);\n    }\n\n    function prepareFinalAnimationStyles(previousStyles, newStyles, nullValue) {\n        if (nullValue === void 0) { nullValue = null; }\n        var finalStyles = {};\n        StringMapWrapper.forEach(newStyles, function (value, prop) {\n            finalStyles[prop] = value == AUTO_STYLE ? nullValue : value.toString();\n        });\n        StringMapWrapper.forEach(previousStyles, function (value, prop) {\n            if (!isPresent(finalStyles[prop])) {\n                finalStyles[prop] = nullValue;\n            }\n        });\n        return finalStyles;\n    }\n    function balanceAnimationKeyframes(collectedStyles, finalStateStyles, keyframes) {\n        var limit = keyframes.length - 1;\n        var firstKeyframe = keyframes[0];\n        // phase 1: copy all the styles from the first keyframe into the lookup map\n        var flatenedFirstKeyframeStyles = flattenStyles(firstKeyframe.styles.styles);\n        var extraFirstKeyframeStyles = {};\n        var hasExtraFirstStyles = false;\n        StringMapWrapper.forEach(collectedStyles, function (value, prop) {\n            // if the style is already defined in the first keyframe then\n            // we do not replace it.\n            if (!flatenedFirstKeyframeStyles[prop]) {\n                flatenedFirstKeyframeStyles[prop] = value;\n                extraFirstKeyframeStyles[prop] = value;\n                hasExtraFirstStyles = true;\n            }\n        });\n        var keyframeCollectedStyles = StringMapWrapper.merge({}, flatenedFirstKeyframeStyles);\n        // phase 2: normalize the final keyframe\n        var finalKeyframe = keyframes[limit];\n        ListWrapper.insert(finalKeyframe.styles.styles, 0, finalStateStyles);\n        var flatenedFinalKeyframeStyles = flattenStyles(finalKeyframe.styles.styles);\n        var extraFinalKeyframeStyles = {};\n        var hasExtraFinalStyles = false;\n        StringMapWrapper.forEach(keyframeCollectedStyles, function (value, prop) {\n            if (!isPresent(flatenedFinalKeyframeStyles[prop])) {\n                extraFinalKeyframeStyles[prop] = AUTO_STYLE;\n                hasExtraFinalStyles = true;\n            }\n        });\n        if (hasExtraFinalStyles) {\n            finalKeyframe.styles.styles.push(extraFinalKeyframeStyles);\n        }\n        StringMapWrapper.forEach(flatenedFinalKeyframeStyles, function (value, prop) {\n            if (!isPresent(flatenedFirstKeyframeStyles[prop])) {\n                extraFirstKeyframeStyles[prop] = AUTO_STYLE;\n                hasExtraFirstStyles = true;\n            }\n        });\n        if (hasExtraFirstStyles) {\n            firstKeyframe.styles.styles.push(extraFirstKeyframeStyles);\n        }\n        return keyframes;\n    }\n    function clearStyles(styles) {\n        var finalStyles = {};\n        StringMapWrapper.keys(styles).forEach(function (key) { finalStyles[key] = null; });\n        return finalStyles;\n    }\n    function collectAndResolveStyles(collection, styles) {\n        return styles.map(function (entry) {\n            var stylesObj = {};\n            StringMapWrapper.forEach(entry, function (value, prop) {\n                if (value == FILL_STYLE_FLAG) {\n                    value = collection[prop];\n                    if (!isPresent(value)) {\n                        value = AUTO_STYLE;\n                    }\n                }\n                collection[prop] = value;\n                stylesObj[prop] = value;\n            });\n            return stylesObj;\n        });\n    }\n    function renderStyles(element, renderer, styles) {\n        StringMapWrapper.forEach(styles, function (value, prop) { renderer.setElementStyle(element, prop, value); });\n    }\n    function flattenStyles(styles) {\n        var finalStyles = {};\n        styles.forEach(function (entry) {\n            StringMapWrapper.forEach(entry, function (value, prop) { finalStyles[prop] = value; });\n        });\n        return finalStyles;\n    }\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var AnimationStyles = (function () {\n        function AnimationStyles(styles) {\n            this.styles = styles;\n        }\n        return AnimationStyles;\n    }());\n\n    var DebugDomRootRenderer = (function () {\n        function DebugDomRootRenderer(_delegate) {\n            this._delegate = _delegate;\n        }\n        DebugDomRootRenderer.prototype.renderComponent = function (componentProto) {\n            return new DebugDomRenderer(this._delegate.renderComponent(componentProto));\n        };\n        return DebugDomRootRenderer;\n    }());\n    var DebugDomRenderer = (function () {\n        function DebugDomRenderer(_delegate) {\n            this._delegate = _delegate;\n        }\n        DebugDomRenderer.prototype.selectRootElement = function (selectorOrNode, debugInfo) {\n            var nativeEl = this._delegate.selectRootElement(selectorOrNode, debugInfo);\n            var debugEl = new DebugElement(nativeEl, null, debugInfo);\n            indexDebugNode(debugEl);\n            return nativeEl;\n        };\n        DebugDomRenderer.prototype.createElement = function (parentElement, name, debugInfo) {\n            var nativeEl = this._delegate.createElement(parentElement, name, debugInfo);\n            var debugEl = new DebugElement(nativeEl, getDebugNode(parentElement), debugInfo);\n            debugEl.name = name;\n            indexDebugNode(debugEl);\n            return nativeEl;\n        };\n        DebugDomRenderer.prototype.createViewRoot = function (hostElement) { return this._delegate.createViewRoot(hostElement); };\n        DebugDomRenderer.prototype.createTemplateAnchor = function (parentElement, debugInfo) {\n            var comment = this._delegate.createTemplateAnchor(parentElement, debugInfo);\n            var debugEl = new DebugNode(comment, getDebugNode(parentElement), debugInfo);\n            indexDebugNode(debugEl);\n            return comment;\n        };\n        DebugDomRenderer.prototype.createText = function (parentElement, value, debugInfo) {\n            var text = this._delegate.createText(parentElement, value, debugInfo);\n            var debugEl = new DebugNode(text, getDebugNode(parentElement), debugInfo);\n            indexDebugNode(debugEl);\n            return text;\n        };\n        DebugDomRenderer.prototype.projectNodes = function (parentElement, nodes) {\n            var debugParent = getDebugNode(parentElement);\n            if (isPresent(debugParent) && debugParent instanceof DebugElement) {\n                var debugElement_1 = debugParent;\n                nodes.forEach(function (node) { debugElement_1.addChild(getDebugNode(node)); });\n            }\n            this._delegate.projectNodes(parentElement, nodes);\n        };\n        DebugDomRenderer.prototype.attachViewAfter = function (node, viewRootNodes) {\n            var debugNode = getDebugNode(node);\n            if (isPresent(debugNode)) {\n                var debugParent = debugNode.parent;\n                if (viewRootNodes.length > 0 && isPresent(debugParent)) {\n                    var debugViewRootNodes = [];\n                    viewRootNodes.forEach(function (rootNode) { return debugViewRootNodes.push(getDebugNode(rootNode)); });\n                    debugParent.insertChildrenAfter(debugNode, debugViewRootNodes);\n                }\n            }\n            this._delegate.attachViewAfter(node, viewRootNodes);\n        };\n        DebugDomRenderer.prototype.detachView = function (viewRootNodes) {\n            viewRootNodes.forEach(function (node) {\n                var debugNode = getDebugNode(node);\n                if (isPresent(debugNode) && isPresent(debugNode.parent)) {\n                    debugNode.parent.removeChild(debugNode);\n                }\n            });\n            this._delegate.detachView(viewRootNodes);\n        };\n        DebugDomRenderer.prototype.destroyView = function (hostElement, viewAllNodes) {\n            viewAllNodes.forEach(function (node) { removeDebugNodeFromIndex(getDebugNode(node)); });\n            this._delegate.destroyView(hostElement, viewAllNodes);\n        };\n        DebugDomRenderer.prototype.listen = function (renderElement, name, callback) {\n            var debugEl = getDebugNode(renderElement);\n            if (isPresent(debugEl)) {\n                debugEl.listeners.push(new EventListener(name, callback));\n            }\n            return this._delegate.listen(renderElement, name, callback);\n        };\n        DebugDomRenderer.prototype.listenGlobal = function (target, name, callback) {\n            return this._delegate.listenGlobal(target, name, callback);\n        };\n        DebugDomRenderer.prototype.setElementProperty = function (renderElement, propertyName, propertyValue) {\n            var debugEl = getDebugNode(renderElement);\n            if (isPresent(debugEl) && debugEl instanceof DebugElement) {\n                debugEl.properties[propertyName] = propertyValue;\n            }\n            this._delegate.setElementProperty(renderElement, propertyName, propertyValue);\n        };\n        DebugDomRenderer.prototype.setElementAttribute = function (renderElement, attributeName, attributeValue) {\n            var debugEl = getDebugNode(renderElement);\n            if (isPresent(debugEl) && debugEl instanceof DebugElement) {\n                debugEl.attributes[attributeName] = attributeValue;\n            }\n            this._delegate.setElementAttribute(renderElement, attributeName, attributeValue);\n        };\n        DebugDomRenderer.prototype.setBindingDebugInfo = function (renderElement, propertyName, propertyValue) {\n            this._delegate.setBindingDebugInfo(renderElement, propertyName, propertyValue);\n        };\n        DebugDomRenderer.prototype.setElementClass = function (renderElement, className, isAdd) {\n            var debugEl = getDebugNode(renderElement);\n            if (isPresent(debugEl) && debugEl instanceof DebugElement) {\n                debugEl.classes[className] = isAdd;\n            }\n            this._delegate.setElementClass(renderElement, className, isAdd);\n        };\n        DebugDomRenderer.prototype.setElementStyle = function (renderElement, styleName, styleValue) {\n            var debugEl = getDebugNode(renderElement);\n            if (isPresent(debugEl) && debugEl instanceof DebugElement) {\n                debugEl.styles[styleName] = styleValue;\n            }\n            this._delegate.setElementStyle(renderElement, styleName, styleValue);\n        };\n        DebugDomRenderer.prototype.invokeElementMethod = function (renderElement, methodName, args) {\n            this._delegate.invokeElementMethod(renderElement, methodName, args);\n        };\n        DebugDomRenderer.prototype.setText = function (renderNode, text) { this._delegate.setText(renderNode, text); };\n        DebugDomRenderer.prototype.animate = function (element, startingStyles, keyframes, duration, delay, easing) {\n            return this._delegate.animate(element, startingStyles, keyframes, duration, delay, easing);\n        };\n        return DebugDomRenderer;\n    }());\n\n    var StaticNodeDebugInfo = (function () {\n        function StaticNodeDebugInfo(providerTokens, componentToken, refTokens) {\n            this.providerTokens = providerTokens;\n            this.componentToken = componentToken;\n            this.refTokens = refTokens;\n        }\n        return StaticNodeDebugInfo;\n    }());\n    var DebugContext = (function () {\n        function DebugContext(_view, _nodeIndex, _tplRow, _tplCol) {\n            this._view = _view;\n            this._nodeIndex = _nodeIndex;\n            this._tplRow = _tplRow;\n            this._tplCol = _tplCol;\n        }\n        Object.defineProperty(DebugContext.prototype, \"_staticNodeInfo\", {\n            get: function () {\n                return isPresent(this._nodeIndex) ? this._view.staticNodeDebugInfos[this._nodeIndex] : null;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(DebugContext.prototype, \"context\", {\n            get: function () { return this._view.context; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(DebugContext.prototype, \"component\", {\n            get: function () {\n                var staticNodeInfo = this._staticNodeInfo;\n                if (isPresent(staticNodeInfo) && isPresent(staticNodeInfo.componentToken)) {\n                    return this.injector.get(staticNodeInfo.componentToken);\n                }\n                return null;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(DebugContext.prototype, \"componentRenderElement\", {\n            get: function () {\n                var componentView = this._view;\n                while (isPresent(componentView.declarationAppElement) &&\n                    componentView.type !== ViewType.COMPONENT) {\n                    componentView = componentView.declarationAppElement.parentView;\n                }\n                return isPresent(componentView.declarationAppElement) ?\n                    componentView.declarationAppElement.nativeElement :\n                    null;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(DebugContext.prototype, \"injector\", {\n            get: function () { return this._view.injector(this._nodeIndex); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(DebugContext.prototype, \"renderNode\", {\n            get: function () {\n                if (isPresent(this._nodeIndex) && this._view.allNodes) {\n                    return this._view.allNodes[this._nodeIndex];\n                }\n                else {\n                    return null;\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(DebugContext.prototype, \"providerTokens\", {\n            get: function () {\n                var staticNodeInfo = this._staticNodeInfo;\n                return isPresent(staticNodeInfo) ? staticNodeInfo.providerTokens : null;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(DebugContext.prototype, \"source\", {\n            get: function () {\n                return this._view.componentType.templateUrl + \":\" + this._tplRow + \":\" + this._tplCol;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(DebugContext.prototype, \"references\", {\n            get: function () {\n                var _this = this;\n                var varValues = {};\n                var staticNodeInfo = this._staticNodeInfo;\n                if (isPresent(staticNodeInfo)) {\n                    var refs = staticNodeInfo.refTokens;\n                    StringMapWrapper.forEach(refs, function (refToken, refName) {\n                        var varValue;\n                        if (isBlank(refToken)) {\n                            varValue = _this._view.allNodes ? _this._view.allNodes[_this._nodeIndex] : null;\n                        }\n                        else {\n                            varValue = _this._view.injectorGet(refToken, _this._nodeIndex, null);\n                        }\n                        varValues[refName] = varValue;\n                    });\n                }\n                return varValues;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        return DebugContext;\n    }());\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * An instance of this class is returned as an event parameter when an animation\n     * callback is captured for an animation either during the start or done phase.\n     *\n     * ```typescript\n     * @Component({\n     *   host: {\n     *     '[@myAnimationTrigger]': 'someExpression',\n     *     '(@myAnimationTrigger.start)': 'captureStartEvent($event)',\n     *     '(@myAnimationTrigger.done)': 'captureDoneEvent($event)',\n     *   },\n     *   animations: [\n     *     trigger(\"myAnimationTrigger\", [\n     *        // ...\n     *     ])\n     *   ]\n     * })\n     * class MyComponent {\n     *   someExpression: any = false;\n     *   captureStartEvent(event: AnimationTransitionEvent) {\n     *     // the toState, fromState and totalTime data is accessible from the event variable\n     *   }\n     *\n     *   captureDoneEvent(event: AnimationTransitionEvent) {\n     *     // the toState, fromState and totalTime data is accessible from the event variable\n     *   }\n     * }\n     * ```\n     *\n     * @experimental Animation support is experimental.\n     */\n    var AnimationTransitionEvent = (function () {\n        function AnimationTransitionEvent(_a) {\n            var fromState = _a.fromState, toState = _a.toState, totalTime = _a.totalTime;\n            this.fromState = fromState;\n            this.toState = toState;\n            this.totalTime = totalTime;\n        }\n        return AnimationTransitionEvent;\n    }());\n\n    var ViewAnimationMap = (function () {\n        function ViewAnimationMap() {\n            this._map = new Map();\n            this._allPlayers = [];\n        }\n        Object.defineProperty(ViewAnimationMap.prototype, \"length\", {\n            get: function () { return this.getAllPlayers().length; },\n            enumerable: true,\n            configurable: true\n        });\n        ViewAnimationMap.prototype.find = function (element, animationName) {\n            var playersByAnimation = this._map.get(element);\n            if (isPresent(playersByAnimation)) {\n                return playersByAnimation[animationName];\n            }\n        };\n        ViewAnimationMap.prototype.findAllPlayersByElement = function (element) {\n            var el = this._map.get(element);\n            return el ? StringMapWrapper.values(el) : [];\n        };\n        ViewAnimationMap.prototype.set = function (element, animationName, player) {\n            var playersByAnimation = this._map.get(element);\n            if (!isPresent(playersByAnimation)) {\n                playersByAnimation = {};\n            }\n            var existingEntry = playersByAnimation[animationName];\n            if (isPresent(existingEntry)) {\n                this.remove(element, animationName);\n            }\n            playersByAnimation[animationName] = player;\n            this._allPlayers.push(player);\n            this._map.set(element, playersByAnimation);\n        };\n        ViewAnimationMap.prototype.getAllPlayers = function () { return this._allPlayers; };\n        ViewAnimationMap.prototype.remove = function (element, animationName) {\n            var playersByAnimation = this._map.get(element);\n            if (playersByAnimation) {\n                var player = playersByAnimation[animationName];\n                delete playersByAnimation[animationName];\n                var index = this._allPlayers.indexOf(player);\n                this._allPlayers.splice(index, 1);\n                if (StringMapWrapper.isEmpty(playersByAnimation)) {\n                    this._map.delete(element);\n                }\n            }\n        };\n        return ViewAnimationMap;\n    }());\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$15 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    var _UNDEFINED$1 = new Object();\n    var ElementInjector = (function (_super) {\n        __extends$15(ElementInjector, _super);\n        function ElementInjector(_view, _nodeIndex) {\n            _super.call(this);\n            this._view = _view;\n            this._nodeIndex = _nodeIndex;\n        }\n        ElementInjector.prototype.get = function (token, notFoundValue) {\n            if (notFoundValue === void 0) { notFoundValue = THROW_IF_NOT_FOUND; }\n            var result = _UNDEFINED$1;\n            if (result === _UNDEFINED$1) {\n                result = this._view.injectorGet(token, this._nodeIndex, _UNDEFINED$1);\n            }\n            if (result === _UNDEFINED$1) {\n                result = this._view.parentInjector.get(token, notFoundValue);\n            }\n            return result;\n        };\n        return ElementInjector;\n    }(Injector));\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$14 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    var _scope_check = wtfCreateScope(\"AppView#check(ascii id)\");\n    /**\n     * Cost of making objects: http://jsperf.com/instantiate-size-of-object\n     *\n     */\n    var AppView = (function () {\n        function AppView(clazz, componentType, type, viewUtils, parentInjector, declarationAppElement, cdMode) {\n            this.clazz = clazz;\n            this.componentType = componentType;\n            this.type = type;\n            this.viewUtils = viewUtils;\n            this.parentInjector = parentInjector;\n            this.declarationAppElement = declarationAppElement;\n            this.cdMode = cdMode;\n            this.contentChildren = [];\n            this.viewChildren = [];\n            this.viewContainerElement = null;\n            this.numberOfChecks = 0;\n            this.animationPlayers = new ViewAnimationMap();\n            this._animationListeners = new Map();\n            this.ref = new ViewRef_(this);\n            if (type === ViewType.COMPONENT || type === ViewType.HOST) {\n                this.renderer = viewUtils.renderComponent(componentType);\n            }\n            else {\n                this.renderer = declarationAppElement.parentView.renderer;\n            }\n        }\n        Object.defineProperty(AppView.prototype, \"destroyed\", {\n            get: function () { return this.cdMode === ChangeDetectorStatus.Destroyed; },\n            enumerable: true,\n            configurable: true\n        });\n        AppView.prototype.cancelActiveAnimation = function (element, animationName, removeAllAnimations) {\n            if (removeAllAnimations === void 0) { removeAllAnimations = false; }\n            if (removeAllAnimations) {\n                this.animationPlayers.findAllPlayersByElement(element).forEach(function (player) { return player.destroy(); });\n            }\n            else {\n                var player = this.animationPlayers.find(element, animationName);\n                if (isPresent(player)) {\n                    player.destroy();\n                }\n            }\n        };\n        AppView.prototype.queueAnimation = function (element, animationName, player, totalTime, fromState, toState) {\n            var _this = this;\n            queueAnimation(player);\n            var event = new AnimationTransitionEvent({ 'fromState': fromState, 'toState': toState, 'totalTime': totalTime });\n            this.animationPlayers.set(element, animationName, player);\n            player.onDone(function () {\n                // TODO: make this into a datastructure for done|start\n                _this.triggerAnimationOutput(element, animationName, 'done', event);\n                _this.animationPlayers.remove(element, animationName);\n            });\n            player.onStart(function () { _this.triggerAnimationOutput(element, animationName, 'start', event); });\n        };\n        AppView.prototype.triggerAnimationOutput = function (element, animationName, phase, event) {\n            var listeners = this._animationListeners.get(element);\n            if (isPresent(listeners) && listeners.length) {\n                for (var i = 0; i < listeners.length; i++) {\n                    var listener = listeners[i];\n                    // we check for both the name in addition to the phase in the event\n                    // that there may be more than one @trigger on the same element\n                    if (listener.output.name == animationName && listener.output.phase == phase) {\n                        listener.handler(event);\n                        break;\n                    }\n                }\n            }\n        };\n        AppView.prototype.registerAnimationOutput = function (element, outputEvent, eventHandler) {\n            var entry = new _AnimationOutputWithHandler(outputEvent, eventHandler);\n            var animations = this._animationListeners.get(element);\n            if (!isPresent(animations)) {\n                this._animationListeners.set(element, animations = []);\n            }\n            animations.push(entry);\n        };\n        AppView.prototype.create = function (context, givenProjectableNodes, rootSelectorOrNode) {\n            this.context = context;\n            var projectableNodes;\n            switch (this.type) {\n                case ViewType.COMPONENT:\n                    projectableNodes = ensureSlotCount(givenProjectableNodes, this.componentType.slotCount);\n                    break;\n                case ViewType.EMBEDDED:\n                    projectableNodes = this.declarationAppElement.parentView.projectableNodes;\n                    break;\n                case ViewType.HOST:\n                    // Note: Don't ensure the slot count for the projectableNodes as we store\n                    // them only for the contained component view (which will later check the slot count...)\n                    projectableNodes = givenProjectableNodes;\n                    break;\n            }\n            this._hasExternalHostElement = isPresent(rootSelectorOrNode);\n            this.projectableNodes = projectableNodes;\n            return this.createInternal(rootSelectorOrNode);\n        };\n        /**\n         * Overwritten by implementations.\n         * Returns the AppElement for the host element for ViewType.HOST.\n         */\n        AppView.prototype.createInternal = function (rootSelectorOrNode) { return null; };\n        AppView.prototype.init = function (rootNodesOrAppElements, allNodes, disposables, subscriptions) {\n            this.rootNodesOrAppElements = rootNodesOrAppElements;\n            this.allNodes = allNodes;\n            this.disposables = disposables;\n            this.subscriptions = subscriptions;\n            if (this.type === ViewType.COMPONENT) {\n                // Note: the render nodes have been attached to their host element\n                // in the ViewFactory already.\n                this.declarationAppElement.parentView.viewChildren.push(this);\n                this.dirtyParentQueriesInternal();\n            }\n        };\n        AppView.prototype.selectOrCreateHostElement = function (elementName, rootSelectorOrNode, debugInfo) {\n            var hostElement;\n            if (isPresent(rootSelectorOrNode)) {\n                hostElement = this.renderer.selectRootElement(rootSelectorOrNode, debugInfo);\n            }\n            else {\n                hostElement = this.renderer.createElement(null, elementName, debugInfo);\n            }\n            return hostElement;\n        };\n        AppView.prototype.injectorGet = function (token, nodeIndex, notFoundResult) {\n            return this.injectorGetInternal(token, nodeIndex, notFoundResult);\n        };\n        /**\n         * Overwritten by implementations\n         */\n        AppView.prototype.injectorGetInternal = function (token, nodeIndex, notFoundResult) {\n            return notFoundResult;\n        };\n        AppView.prototype.injector = function (nodeIndex) {\n            if (isPresent(nodeIndex)) {\n                return new ElementInjector(this, nodeIndex);\n            }\n            else {\n                return this.parentInjector;\n            }\n        };\n        AppView.prototype.destroy = function () {\n            if (this._hasExternalHostElement) {\n                this.renderer.detachView(this.flatRootNodes);\n            }\n            else if (isPresent(this.viewContainerElement)) {\n                this.viewContainerElement.detachView(this.viewContainerElement.nestedViews.indexOf(this));\n            }\n            this._destroyRecurse();\n        };\n        AppView.prototype._destroyRecurse = function () {\n            if (this.cdMode === ChangeDetectorStatus.Destroyed) {\n                return;\n            }\n            var children = this.contentChildren;\n            for (var i = 0; i < children.length; i++) {\n                children[i]._destroyRecurse();\n            }\n            children = this.viewChildren;\n            for (var i = 0; i < children.length; i++) {\n                children[i]._destroyRecurse();\n            }\n            this.destroyLocal();\n            this.cdMode = ChangeDetectorStatus.Destroyed;\n        };\n        AppView.prototype.destroyLocal = function () {\n            var _this = this;\n            var hostElement = this.type === ViewType.COMPONENT ? this.declarationAppElement.nativeElement : null;\n            for (var i = 0; i < this.disposables.length; i++) {\n                this.disposables[i]();\n            }\n            for (var i = 0; i < this.subscriptions.length; i++) {\n                this.subscriptions[i].unsubscribe();\n            }\n            this.destroyInternal();\n            this.dirtyParentQueriesInternal();\n            if (this.animationPlayers.length == 0) {\n                this.renderer.destroyView(hostElement, this.allNodes);\n            }\n            else {\n                var player = new AnimationGroupPlayer(this.animationPlayers.getAllPlayers());\n                player.onDone(function () { _this.renderer.destroyView(hostElement, _this.allNodes); });\n            }\n        };\n        /**\n         * Overwritten by implementations\n         */\n        AppView.prototype.destroyInternal = function () { };\n        /**\n         * Overwritten by implementations\n         */\n        AppView.prototype.detachInternal = function () { };\n        AppView.prototype.detach = function () {\n            var _this = this;\n            this.detachInternal();\n            if (this.animationPlayers.length == 0) {\n                this.renderer.detachView(this.flatRootNodes);\n            }\n            else {\n                var player = new AnimationGroupPlayer(this.animationPlayers.getAllPlayers());\n                player.onDone(function () { _this.renderer.detachView(_this.flatRootNodes); });\n            }\n        };\n        Object.defineProperty(AppView.prototype, \"changeDetectorRef\", {\n            get: function () { return this.ref; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AppView.prototype, \"parent\", {\n            get: function () {\n                return isPresent(this.declarationAppElement) ? this.declarationAppElement.parentView : null;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AppView.prototype, \"flatRootNodes\", {\n            get: function () { return flattenNestedViewRenderNodes(this.rootNodesOrAppElements); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AppView.prototype, \"lastRootNode\", {\n            get: function () {\n                var lastNode = this.rootNodesOrAppElements.length > 0 ?\n                    this.rootNodesOrAppElements[this.rootNodesOrAppElements.length - 1] :\n                    null;\n                return _findLastRenderNode(lastNode);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * Overwritten by implementations\n         */\n        AppView.prototype.dirtyParentQueriesInternal = function () { };\n        AppView.prototype.detectChanges = function (throwOnChange) {\n            var s = _scope_check(this.clazz);\n            if (this.cdMode === ChangeDetectorStatus.Checked ||\n                this.cdMode === ChangeDetectorStatus.Errored)\n                return;\n            if (this.cdMode === ChangeDetectorStatus.Destroyed) {\n                this.throwDestroyedError('detectChanges');\n            }\n            this.detectChangesInternal(throwOnChange);\n            if (this.cdMode === ChangeDetectorStatus.CheckOnce)\n                this.cdMode = ChangeDetectorStatus.Checked;\n            this.numberOfChecks++;\n            wtfLeave(s);\n        };\n        /**\n         * Overwritten by implementations\n         */\n        AppView.prototype.detectChangesInternal = function (throwOnChange) {\n            this.detectContentChildrenChanges(throwOnChange);\n            this.detectViewChildrenChanges(throwOnChange);\n        };\n        AppView.prototype.detectContentChildrenChanges = function (throwOnChange) {\n            for (var i = 0; i < this.contentChildren.length; ++i) {\n                var child = this.contentChildren[i];\n                if (child.cdMode === ChangeDetectorStatus.Detached)\n                    continue;\n                child.detectChanges(throwOnChange);\n            }\n        };\n        AppView.prototype.detectViewChildrenChanges = function (throwOnChange) {\n            for (var i = 0; i < this.viewChildren.length; ++i) {\n                var child = this.viewChildren[i];\n                if (child.cdMode === ChangeDetectorStatus.Detached)\n                    continue;\n                child.detectChanges(throwOnChange);\n            }\n        };\n        AppView.prototype.markContentChildAsMoved = function (renderAppElement) { this.dirtyParentQueriesInternal(); };\n        AppView.prototype.addToContentChildren = function (renderAppElement) {\n            renderAppElement.parentView.contentChildren.push(this);\n            this.viewContainerElement = renderAppElement;\n            this.dirtyParentQueriesInternal();\n        };\n        AppView.prototype.removeFromContentChildren = function (renderAppElement) {\n            ListWrapper.remove(renderAppElement.parentView.contentChildren, this);\n            this.dirtyParentQueriesInternal();\n            this.viewContainerElement = null;\n        };\n        AppView.prototype.markAsCheckOnce = function () { this.cdMode = ChangeDetectorStatus.CheckOnce; };\n        AppView.prototype.markPathToRootAsCheckOnce = function () {\n            var c = this;\n            while (isPresent(c) && c.cdMode !== ChangeDetectorStatus.Detached) {\n                if (c.cdMode === ChangeDetectorStatus.Checked) {\n                    c.cdMode = ChangeDetectorStatus.CheckOnce;\n                }\n                var parentEl = c.type === ViewType.COMPONENT ? c.declarationAppElement : c.viewContainerElement;\n                c = isPresent(parentEl) ? parentEl.parentView : null;\n            }\n        };\n        AppView.prototype.eventHandler = function (cb) { return cb; };\n        AppView.prototype.throwDestroyedError = function (details) { throw new ViewDestroyedError(details); };\n        return AppView;\n    }());\n    var DebugAppView = (function (_super) {\n        __extends$14(DebugAppView, _super);\n        function DebugAppView(clazz, componentType, type, viewUtils, parentInjector, declarationAppElement, cdMode, staticNodeDebugInfos) {\n            _super.call(this, clazz, componentType, type, viewUtils, parentInjector, declarationAppElement, cdMode);\n            this.staticNodeDebugInfos = staticNodeDebugInfos;\n            this._currentDebugContext = null;\n        }\n        DebugAppView.prototype.create = function (context, givenProjectableNodes, rootSelectorOrNode) {\n            this._resetDebug();\n            try {\n                return _super.prototype.create.call(this, context, givenProjectableNodes, rootSelectorOrNode);\n            }\n            catch (e) {\n                this._rethrowWithContext(e);\n                throw e;\n            }\n        };\n        DebugAppView.prototype.injectorGet = function (token, nodeIndex, notFoundResult) {\n            this._resetDebug();\n            try {\n                return _super.prototype.injectorGet.call(this, token, nodeIndex, notFoundResult);\n            }\n            catch (e) {\n                this._rethrowWithContext(e);\n                throw e;\n            }\n        };\n        DebugAppView.prototype.detach = function () {\n            this._resetDebug();\n            try {\n                _super.prototype.detach.call(this);\n            }\n            catch (e) {\n                this._rethrowWithContext(e);\n                throw e;\n            }\n        };\n        DebugAppView.prototype.destroyLocal = function () {\n            this._resetDebug();\n            try {\n                _super.prototype.destroyLocal.call(this);\n            }\n            catch (e) {\n                this._rethrowWithContext(e);\n                throw e;\n            }\n        };\n        DebugAppView.prototype.detectChanges = function (throwOnChange) {\n            this._resetDebug();\n            try {\n                _super.prototype.detectChanges.call(this, throwOnChange);\n            }\n            catch (e) {\n                this._rethrowWithContext(e);\n                throw e;\n            }\n        };\n        DebugAppView.prototype._resetDebug = function () { this._currentDebugContext = null; };\n        DebugAppView.prototype.debug = function (nodeIndex, rowNum, colNum) {\n            return this._currentDebugContext = new DebugContext(this, nodeIndex, rowNum, colNum);\n        };\n        DebugAppView.prototype._rethrowWithContext = function (e) {\n            if (!(e instanceof ViewWrappedError)) {\n                if (!(e instanceof ExpressionChangedAfterItHasBeenCheckedError)) {\n                    this.cdMode = ChangeDetectorStatus.Errored;\n                }\n                if (isPresent(this._currentDebugContext)) {\n                    throw new ViewWrappedError(e, this._currentDebugContext);\n                }\n            }\n        };\n        DebugAppView.prototype.eventHandler = function (cb) {\n            var _this = this;\n            var superHandler = _super.prototype.eventHandler.call(this, cb);\n            return function (event) {\n                _this._resetDebug();\n                try {\n                    return superHandler(event);\n                }\n                catch (e) {\n                    _this._rethrowWithContext(e);\n                    throw e;\n                }\n            };\n        };\n        return DebugAppView;\n    }(AppView));\n    function _findLastRenderNode(node) {\n        var lastNode;\n        if (node instanceof AppElement) {\n            var appEl = node;\n            lastNode = appEl.nativeElement;\n            if (isPresent(appEl.nestedViews)) {\n                // Note: Views might have no root nodes at all!\n                for (var i = appEl.nestedViews.length - 1; i >= 0; i--) {\n                    var nestedView = appEl.nestedViews[i];\n                    if (nestedView.rootNodesOrAppElements.length > 0) {\n                        lastNode = _findLastRenderNode(nestedView.rootNodesOrAppElements[nestedView.rootNodesOrAppElements.length - 1]);\n                    }\n                }\n            }\n        }\n        else {\n            lastNode = node;\n        }\n        return lastNode;\n    }\n    var _AnimationOutputWithHandler = (function () {\n        function _AnimationOutputWithHandler(output, handler) {\n            this.output = output;\n            this.handler = handler;\n        }\n        return _AnimationOutputWithHandler;\n    }());\n\n    var __core_private__ = {\n        isDefaultChangeDetectionStrategy: isDefaultChangeDetectionStrategy,\n        ChangeDetectorStatus: ChangeDetectorStatus,\n        CHANGE_DETECTION_STRATEGY_VALUES: CHANGE_DETECTION_STRATEGY_VALUES,\n        constructDependencies: constructDependencies,\n        LifecycleHooks: LifecycleHooks,\n        LIFECYCLE_HOOKS_VALUES: LIFECYCLE_HOOKS_VALUES,\n        ReflectorReader: ReflectorReader,\n        CodegenComponentFactoryResolver: CodegenComponentFactoryResolver,\n        AppElement: AppElement,\n        AppView: AppView,\n        DebugAppView: DebugAppView,\n        NgModuleInjector: NgModuleInjector,\n        registerModuleFactory: registerModuleFactory,\n        ViewType: ViewType,\n        MAX_INTERPOLATION_VALUES: MAX_INTERPOLATION_VALUES,\n        checkBinding: checkBinding,\n        flattenNestedViewRenderNodes: flattenNestedViewRenderNodes,\n        interpolate: interpolate,\n        ViewUtils: ViewUtils,\n        VIEW_ENCAPSULATION_VALUES: VIEW_ENCAPSULATION_VALUES,\n        ViewMetadata: ViewMetadata,\n        DebugContext: DebugContext,\n        StaticNodeDebugInfo: StaticNodeDebugInfo,\n        devModeEqual: devModeEqual,\n        UNINITIALIZED: UNINITIALIZED,\n        ValueUnwrapper: ValueUnwrapper,\n        RenderDebugInfo: RenderDebugInfo,\n        TemplateRef_: TemplateRef_,\n        ReflectionCapabilities: ReflectionCapabilities,\n        makeDecorator: makeDecorator,\n        DebugDomRootRenderer: DebugDomRootRenderer,\n        EMPTY_ARRAY: EMPTY_ARRAY,\n        EMPTY_MAP: EMPTY_MAP,\n        pureProxy1: pureProxy1,\n        pureProxy2: pureProxy2,\n        pureProxy3: pureProxy3,\n        pureProxy4: pureProxy4,\n        pureProxy5: pureProxy5,\n        pureProxy6: pureProxy6,\n        pureProxy7: pureProxy7,\n        pureProxy8: pureProxy8,\n        pureProxy9: pureProxy9,\n        pureProxy10: pureProxy10,\n        castByValue: castByValue,\n        Console: Console,\n        reflector: reflector,\n        Reflector: Reflector,\n        NoOpAnimationPlayer: NoOpAnimationPlayer,\n        AnimationPlayer: AnimationPlayer,\n        AnimationSequencePlayer: AnimationSequencePlayer,\n        AnimationGroupPlayer: AnimationGroupPlayer,\n        AnimationKeyframe: AnimationKeyframe,\n        prepareFinalAnimationStyles: prepareFinalAnimationStyles,\n        balanceAnimationKeyframes: balanceAnimationKeyframes,\n        flattenStyles: flattenStyles,\n        clearStyles: clearStyles,\n        renderStyles: renderStyles,\n        collectAndResolveStyles: collectAndResolveStyles,\n        AnimationStyles: AnimationStyles,\n        AnimationOutput: AnimationOutput,\n        ANY_STATE: ANY_STATE,\n        DEFAULT_STATE: DEFAULT_STATE,\n        EMPTY_STATE: EMPTY_STATE,\n        FILL_STYLE_FLAG: FILL_STYLE_FLAG,\n        ComponentStillLoadingError: ComponentStillLoadingError,\n        isPromise: isPromise\n    };\n\n    exports.createPlatform = createPlatform;\n    exports.assertPlatform = assertPlatform;\n    exports.destroyPlatform = destroyPlatform;\n    exports.getPlatform = getPlatform;\n    exports.PlatformRef = PlatformRef;\n    exports.ApplicationRef = ApplicationRef;\n    exports.enableProdMode = enableProdMode;\n    exports.isDevMode = isDevMode;\n    exports.createPlatformFactory = createPlatformFactory;\n    exports.APP_ID = APP_ID;\n    exports.PACKAGE_ROOT_URL = PACKAGE_ROOT_URL;\n    exports.PLATFORM_INITIALIZER = PLATFORM_INITIALIZER;\n    exports.APP_BOOTSTRAP_LISTENER = APP_BOOTSTRAP_LISTENER;\n    exports.APP_INITIALIZER = APP_INITIALIZER;\n    exports.ApplicationInitStatus = ApplicationInitStatus;\n    exports.DebugElement = DebugElement;\n    exports.DebugNode = DebugNode;\n    exports.asNativeElements = asNativeElements;\n    exports.getDebugNode = getDebugNode;\n    exports.Testability = Testability;\n    exports.TestabilityRegistry = TestabilityRegistry;\n    exports.setTestabilityGetter = setTestabilityGetter;\n    exports.TRANSLATIONS = TRANSLATIONS;\n    exports.TRANSLATIONS_FORMAT = TRANSLATIONS_FORMAT;\n    exports.LOCALE_ID = LOCALE_ID;\n    exports.ApplicationModule = ApplicationModule;\n    exports.wtfCreateScope = wtfCreateScope;\n    exports.wtfLeave = wtfLeave;\n    exports.wtfStartTimeRange = wtfStartTimeRange;\n    exports.wtfEndTimeRange = wtfEndTimeRange;\n    exports.Type = Type;\n    exports.EventEmitter = EventEmitter;\n    exports.ErrorHandler = ErrorHandler;\n    exports.AnimationTransitionEvent = AnimationTransitionEvent;\n    exports.AnimationPlayer = AnimationPlayer;\n    exports.Sanitizer = Sanitizer;\n    exports.ANALYZE_FOR_ENTRY_COMPONENTS = ANALYZE_FOR_ENTRY_COMPONENTS;\n    exports.Attribute = Attribute;\n    exports.ContentChild = ContentChild;\n    exports.ContentChildren = ContentChildren;\n    exports.Query = Query;\n    exports.ViewChild = ViewChild;\n    exports.ViewChildren = ViewChildren;\n    exports.Component = Component;\n    exports.Directive = Directive;\n    exports.HostBinding = HostBinding;\n    exports.HostListener = HostListener;\n    exports.Input = Input;\n    exports.Output = Output;\n    exports.Pipe = Pipe;\n    exports.AfterContentChecked = AfterContentChecked;\n    exports.AfterContentInit = AfterContentInit;\n    exports.AfterViewChecked = AfterViewChecked;\n    exports.AfterViewInit = AfterViewInit;\n    exports.DoCheck = DoCheck;\n    exports.OnChanges = OnChanges;\n    exports.OnDestroy = OnDestroy;\n    exports.OnInit = OnInit;\n    exports.CUSTOM_ELEMENTS_SCHEMA = CUSTOM_ELEMENTS_SCHEMA;\n    exports.NO_ERRORS_SCHEMA = NO_ERRORS_SCHEMA;\n    exports.NgModule = NgModule;\n    exports.Class = Class;\n    exports.forwardRef = forwardRef;\n    exports.resolveForwardRef = resolveForwardRef;\n    exports.Injector = Injector;\n    exports.ReflectiveInjector = ReflectiveInjector;\n    exports.ResolvedReflectiveFactory = ResolvedReflectiveFactory;\n    exports.ReflectiveKey = ReflectiveKey;\n    exports.OpaqueToken = OpaqueToken;\n    exports.Inject = Inject;\n    exports.Optional = Optional;\n    exports.Injectable = Injectable;\n    exports.Self = Self;\n    exports.SkipSelf = SkipSelf;\n    exports.Host = Host;\n    exports.NgZone = NgZone;\n    exports.RenderComponentType = RenderComponentType;\n    exports.Renderer = Renderer;\n    exports.RootRenderer = RootRenderer;\n    exports.COMPILER_OPTIONS = COMPILER_OPTIONS;\n    exports.Compiler = Compiler;\n    exports.CompilerFactory = CompilerFactory;\n    exports.ModuleWithComponentFactories = ModuleWithComponentFactories;\n    exports.ComponentFactory = ComponentFactory;\n    exports.ComponentRef = ComponentRef;\n    exports.ComponentFactoryResolver = ComponentFactoryResolver;\n    exports.ElementRef = ElementRef;\n    exports.NgModuleFactory = NgModuleFactory;\n    exports.NgModuleRef = NgModuleRef;\n    exports.NgModuleFactoryLoader = NgModuleFactoryLoader;\n    exports.getModuleFactory = getModuleFactory;\n    exports.QueryList = QueryList;\n    exports.SystemJsNgModuleLoader = SystemJsNgModuleLoader;\n    exports.SystemJsNgModuleLoaderConfig = SystemJsNgModuleLoaderConfig;\n    exports.TemplateRef = TemplateRef;\n    exports.ViewContainerRef = ViewContainerRef;\n    exports.EmbeddedViewRef = EmbeddedViewRef;\n    exports.ViewRef = ViewRef;\n    exports.ChangeDetectorRef = ChangeDetectorRef;\n    exports.CollectionChangeRecord = CollectionChangeRecord;\n    exports.DefaultIterableDiffer = DefaultIterableDiffer;\n    exports.IterableDiffers = IterableDiffers;\n    exports.KeyValueChangeRecord = KeyValueChangeRecord;\n    exports.KeyValueDiffers = KeyValueDiffers;\n    exports.SimpleChange = SimpleChange;\n    exports.WrappedValue = WrappedValue;\n    exports.platformCore = platformCore;\n    exports.__core_private__ = __core_private__;\n    exports.AUTO_STYLE = AUTO_STYLE;\n    exports.AnimationEntryMetadata = AnimationEntryMetadata;\n    exports.AnimationStateMetadata = AnimationStateMetadata;\n    exports.AnimationStateDeclarationMetadata = AnimationStateDeclarationMetadata;\n    exports.AnimationStateTransitionMetadata = AnimationStateTransitionMetadata;\n    exports.AnimationMetadata = AnimationMetadata;\n    exports.AnimationKeyframesSequenceMetadata = AnimationKeyframesSequenceMetadata;\n    exports.AnimationStyleMetadata = AnimationStyleMetadata;\n    exports.AnimationAnimateMetadata = AnimationAnimateMetadata;\n    exports.AnimationWithStepsMetadata = AnimationWithStepsMetadata;\n    exports.AnimationSequenceMetadata = AnimationSequenceMetadata;\n    exports.AnimationGroupMetadata = AnimationGroupMetadata;\n    exports.animate = animate;\n    exports.group = group;\n    exports.sequence = sequence;\n    exports.style = style;\n    exports.state = state;\n    exports.keyframes = keyframes;\n    exports.transition = transition;\n    exports.trigger = trigger;\n\n}));\n\n/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/@angular/core/bundles/core.umd.js\n ** module id = 3\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/@angular/core/bundles/core.umd.js?");

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = __webpack_require__(5);\nvar Subscriber_1 = __webpack_require__(8);\nvar Subscription_1 = __webpack_require__(10);\nvar ObjectUnsubscribedError_1 = __webpack_require__(19);\nvar SubjectSubscription_1 = __webpack_require__(20);\nvar rxSubscriber_1 = __webpack_require__(17);\n/**\n * @class SubjectSubscriber<T>\n */\nvar SubjectSubscriber = (function (_super) {\n    __extends(SubjectSubscriber, _super);\n    function SubjectSubscriber(destination) {\n        _super.call(this, destination);\n        this.destination = destination;\n    }\n    return SubjectSubscriber;\n}(Subscriber_1.Subscriber));\nexports.SubjectSubscriber = SubjectSubscriber;\n/**\n * @class Subject<T>\n */\nvar Subject = (function (_super) {\n    __extends(Subject, _super);\n    function Subject() {\n        _super.call(this);\n        this.observers = [];\n        this.closed = false;\n        this.isStopped = false;\n        this.hasError = false;\n        this.thrownError = null;\n    }\n    Subject.prototype[rxSubscriber_1.$$rxSubscriber] = function () {\n        return new SubjectSubscriber(this);\n    };\n    Subject.prototype.lift = function (operator) {\n        var subject = new AnonymousSubject(this, this);\n        subject.operator = operator;\n        return subject;\n    };\n    Subject.prototype.next = function (value) {\n        if (this.closed) {\n            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n        }\n        if (!this.isStopped) {\n            var observers = this.observers;\n            var len = observers.length;\n            var copy = observers.slice();\n            for (var i = 0; i < len; i++) {\n                copy[i].next(value);\n            }\n        }\n    };\n    Subject.prototype.error = function (err) {\n        if (this.closed) {\n            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n        }\n        this.hasError = true;\n        this.thrownError = err;\n        this.isStopped = true;\n        var observers = this.observers;\n        var len = observers.length;\n        var copy = observers.slice();\n        for (var i = 0; i < len; i++) {\n            copy[i].error(err);\n        }\n        this.observers.length = 0;\n    };\n    Subject.prototype.complete = function () {\n        if (this.closed) {\n            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n        }\n        this.isStopped = true;\n        var observers = this.observers;\n        var len = observers.length;\n        var copy = observers.slice();\n        for (var i = 0; i < len; i++) {\n            copy[i].complete();\n        }\n        this.observers.length = 0;\n    };\n    Subject.prototype.unsubscribe = function () {\n        this.isStopped = true;\n        this.closed = true;\n        this.observers = null;\n    };\n    Subject.prototype._subscribe = function (subscriber) {\n        if (this.closed) {\n            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n        }\n        else if (this.hasError) {\n            subscriber.error(this.thrownError);\n            return Subscription_1.Subscription.EMPTY;\n        }\n        else if (this.isStopped) {\n            subscriber.complete();\n            return Subscription_1.Subscription.EMPTY;\n        }\n        else {\n            this.observers.push(subscriber);\n            return new SubjectSubscription_1.SubjectSubscription(this, subscriber);\n        }\n    };\n    Subject.prototype.asObservable = function () {\n        var observable = new Observable_1.Observable();\n        observable.source = this;\n        return observable;\n    };\n    Subject.create = function (destination, source) {\n        return new AnonymousSubject(destination, source);\n    };\n    return Subject;\n}(Observable_1.Observable));\nexports.Subject = Subject;\n/**\n * @class AnonymousSubject<T>\n */\nvar AnonymousSubject = (function (_super) {\n    __extends(AnonymousSubject, _super);\n    function AnonymousSubject(destination, source) {\n        _super.call(this);\n        this.destination = destination;\n        this.source = source;\n    }\n    AnonymousSubject.prototype.next = function (value) {\n        var destination = this.destination;\n        if (destination && destination.next) {\n            destination.next(value);\n        }\n    };\n    AnonymousSubject.prototype.error = function (err) {\n        var destination = this.destination;\n        if (destination && destination.error) {\n            this.destination.error(err);\n        }\n    };\n    AnonymousSubject.prototype.complete = function () {\n        var destination = this.destination;\n        if (destination && destination.complete) {\n            this.destination.complete();\n        }\n    };\n    AnonymousSubject.prototype._subscribe = function (subscriber) {\n        var source = this.source;\n        if (source) {\n            return this.source.subscribe(subscriber);\n        }\n        else {\n            return Subscription_1.Subscription.EMPTY;\n        }\n    };\n    return AnonymousSubject;\n}(Subject));\nexports.AnonymousSubject = AnonymousSubject;\n//# sourceMappingURL=Subject.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/Subject.js\n ** module id = 4\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/Subject.js?");

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar root_1 = __webpack_require__(6);\nvar toSubscriber_1 = __webpack_require__(7);\nvar observable_1 = __webpack_require__(18);\n/**\n * A representation of any set of values over any amount of time. This the most basic building block\n * of RxJS.\n *\n * @class Observable<T>\n */\nvar Observable = (function () {\n    /**\n     * @constructor\n     * @param {Function} subscribe the function that is  called when the Observable is\n     * initially subscribed to. This function is given a Subscriber, to which new values\n     * can be `next`ed, or an `error` method can be called to raise an error, or\n     * `complete` can be called to notify of a successful completion.\n     */\n    function Observable(subscribe) {\n        this._isScalar = false;\n        if (subscribe) {\n            this._subscribe = subscribe;\n        }\n    }\n    /**\n     * Creates a new Observable, with this Observable as the source, and the passed\n     * operator defined as the new observable's operator.\n     * @method lift\n     * @param {Operator} operator the operator defining the operation to take on the observable\n     * @return {Observable} a new observable with the Operator applied\n     */\n    Observable.prototype.lift = function (operator) {\n        var observable = new Observable();\n        observable.source = this;\n        observable.operator = operator;\n        return observable;\n    };\n    /**\n     * Registers handlers for handling emitted values, error and completions from the observable, and\n     *  executes the observable's subscriber function, which will take action to set up the underlying data stream\n     * @method subscribe\n     * @param {PartialObserver|Function} observerOrNext (optional) either an observer defining all functions to be called,\n     *  or the first of three possible handlers, which is the handler for each value emitted from the observable.\n     * @param {Function} error (optional) a handler for a terminal event resulting from an error. If no error handler is provided,\n     *  the error will be thrown as unhandled\n     * @param {Function} complete (optional) a handler for a terminal event resulting from successful completion.\n     * @return {ISubscription} a subscription reference to the registered handlers\n     */\n    Observable.prototype.subscribe = function (observerOrNext, error, complete) {\n        var operator = this.operator;\n        var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);\n        if (operator) {\n            operator.call(sink, this);\n        }\n        else {\n            sink.add(this._subscribe(sink));\n        }\n        if (sink.syncErrorThrowable) {\n            sink.syncErrorThrowable = false;\n            if (sink.syncErrorThrown) {\n                throw sink.syncErrorValue;\n            }\n        }\n        return sink;\n    };\n    /**\n     * @method forEach\n     * @param {Function} next a handler for each value emitted by the observable\n     * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise\n     * @return {Promise} a promise that either resolves on observable completion or\n     *  rejects with the handled error\n     */\n    Observable.prototype.forEach = function (next, PromiseCtor) {\n        var _this = this;\n        if (!PromiseCtor) {\n            if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {\n                PromiseCtor = root_1.root.Rx.config.Promise;\n            }\n            else if (root_1.root.Promise) {\n                PromiseCtor = root_1.root.Promise;\n            }\n        }\n        if (!PromiseCtor) {\n            throw new Error('no Promise impl found');\n        }\n        return new PromiseCtor(function (resolve, reject) {\n            var subscription = _this.subscribe(function (value) {\n                if (subscription) {\n                    // if there is a subscription, then we can surmise\n                    // the next handling is asynchronous. Any errors thrown\n                    // need to be rejected explicitly and unsubscribe must be\n                    // called manually\n                    try {\n                        next(value);\n                    }\n                    catch (err) {\n                        reject(err);\n                        subscription.unsubscribe();\n                    }\n                }\n                else {\n                    // if there is NO subscription, then we're getting a nexted\n                    // value synchronously during subscription. We can just call it.\n                    // If it errors, Observable's `subscribe` will ensure the\n                    // unsubscription logic is called, then synchronously rethrow the error.\n                    // After that, Promise will trap the error and send it\n                    // down the rejection path.\n                    next(value);\n                }\n            }, reject, resolve);\n        });\n    };\n    Observable.prototype._subscribe = function (subscriber) {\n        return this.source.subscribe(subscriber);\n    };\n    /**\n     * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable\n     * @method Symbol.observable\n     * @return {Observable} this instance of the observable\n     */\n    Observable.prototype[observable_1.$$observable] = function () {\n        return this;\n    };\n    // HACK: Since TypeScript inherits static properties too, we have to\n    // fight against TypeScript here so Subject can have a different static create signature\n    /**\n     * Creates a new cold Observable by calling the Observable constructor\n     * @static true\n     * @owner Observable\n     * @method create\n     * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor\n     * @return {Observable} a new cold observable\n     */\n    Observable.create = function (subscribe) {\n        return new Observable(subscribe);\n    };\n    return Observable;\n}());\nexports.Observable = Observable;\n//# sourceMappingURL=Observable.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/Observable.js\n ** module id = 5\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/Observable.js?");

/***/ },
/* 6 */
/***/ function(module, exports) {

	eval("/* WEBPACK VAR INJECTION */(function(global) {\"use strict\";\nvar objectTypes = {\n    'boolean': false,\n    'function': true,\n    'object': true,\n    'number': false,\n    'string': false,\n    'undefined': false\n};\nexports.root = (objectTypes[typeof self] && self) || (objectTypes[typeof window] && window);\nvar freeGlobal = objectTypes[typeof global] && global;\nif (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {\n    exports.root = freeGlobal;\n}\n//# sourceMappingURL=root.js.map\n/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/util/root.js\n ** module id = 6\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/util/root.js?");

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Subscriber_1 = __webpack_require__(8);\nvar rxSubscriber_1 = __webpack_require__(17);\nfunction toSubscriber(nextOrObserver, error, complete) {\n    if (nextOrObserver) {\n        if (nextOrObserver instanceof Subscriber_1.Subscriber) {\n            return nextOrObserver;\n        }\n        if (nextOrObserver[rxSubscriber_1.$$rxSubscriber]) {\n            return nextOrObserver[rxSubscriber_1.$$rxSubscriber]();\n        }\n    }\n    if (!nextOrObserver && !error && !complete) {\n        return new Subscriber_1.Subscriber();\n    }\n    return new Subscriber_1.Subscriber(nextOrObserver, error, complete);\n}\nexports.toSubscriber = toSubscriber;\n//# sourceMappingURL=toSubscriber.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/util/toSubscriber.js\n ** module id = 7\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/util/toSubscriber.js?");

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar isFunction_1 = __webpack_require__(9);\nvar Subscription_1 = __webpack_require__(10);\nvar Observer_1 = __webpack_require__(16);\nvar rxSubscriber_1 = __webpack_require__(17);\n/**\n * Implements the {@link Observer} interface and extends the\n * {@link Subscription} class. While the {@link Observer} is the public API for\n * consuming the values of an {@link Observable}, all Observers get converted to\n * a Subscriber, in order to provide Subscription-like capabilities such as\n * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for\n * implementing operators, but it is rarely used as a public API.\n *\n * @class Subscriber<T>\n */\nvar Subscriber = (function (_super) {\n    __extends(Subscriber, _super);\n    /**\n     * @param {Observer|function(value: T): void} [destinationOrNext] A partially\n     * defined Observer or a `next` callback function.\n     * @param {function(e: ?any): void} [error] The `error` callback of an\n     * Observer.\n     * @param {function(): void} [complete] The `complete` callback of an\n     * Observer.\n     */\n    function Subscriber(destinationOrNext, error, complete) {\n        _super.call(this);\n        this.syncErrorValue = null;\n        this.syncErrorThrown = false;\n        this.syncErrorThrowable = false;\n        this.isStopped = false;\n        switch (arguments.length) {\n            case 0:\n                this.destination = Observer_1.empty;\n                break;\n            case 1:\n                if (!destinationOrNext) {\n                    this.destination = Observer_1.empty;\n                    break;\n                }\n                if (typeof destinationOrNext === 'object') {\n                    if (destinationOrNext instanceof Subscriber) {\n                        this.destination = destinationOrNext;\n                        this.destination.add(this);\n                    }\n                    else {\n                        this.syncErrorThrowable = true;\n                        this.destination = new SafeSubscriber(this, destinationOrNext);\n                    }\n                    break;\n                }\n            default:\n                this.syncErrorThrowable = true;\n                this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);\n                break;\n        }\n    }\n    Subscriber.prototype[rxSubscriber_1.$$rxSubscriber] = function () { return this; };\n    /**\n     * A static factory for a Subscriber, given a (potentially partial) definition\n     * of an Observer.\n     * @param {function(x: ?T): void} [next] The `next` callback of an Observer.\n     * @param {function(e: ?any): void} [error] The `error` callback of an\n     * Observer.\n     * @param {function(): void} [complete] The `complete` callback of an\n     * Observer.\n     * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)\n     * Observer represented by the given arguments.\n     */\n    Subscriber.create = function (next, error, complete) {\n        var subscriber = new Subscriber(next, error, complete);\n        subscriber.syncErrorThrowable = false;\n        return subscriber;\n    };\n    /**\n     * The {@link Observer} callback to receive notifications of type `next` from\n     * the Observable, with a value. The Observable may call this method 0 or more\n     * times.\n     * @param {T} [value] The `next` value.\n     * @return {void}\n     */\n    Subscriber.prototype.next = function (value) {\n        if (!this.isStopped) {\n            this._next(value);\n        }\n    };\n    /**\n     * The {@link Observer} callback to receive notifications of type `error` from\n     * the Observable, with an attached {@link Error}. Notifies the Observer that\n     * the Observable has experienced an error condition.\n     * @param {any} [err] The `error` exception.\n     * @return {void}\n     */\n    Subscriber.prototype.error = function (err) {\n        if (!this.isStopped) {\n            this.isStopped = true;\n            this._error(err);\n        }\n    };\n    /**\n     * The {@link Observer} callback to receive a valueless notification of type\n     * `complete` from the Observable. Notifies the Observer that the Observable\n     * has finished sending push-based notifications.\n     * @return {void}\n     */\n    Subscriber.prototype.complete = function () {\n        if (!this.isStopped) {\n            this.isStopped = true;\n            this._complete();\n        }\n    };\n    Subscriber.prototype.unsubscribe = function () {\n        if (this.closed) {\n            return;\n        }\n        this.isStopped = true;\n        _super.prototype.unsubscribe.call(this);\n    };\n    Subscriber.prototype._next = function (value) {\n        this.destination.next(value);\n    };\n    Subscriber.prototype._error = function (err) {\n        this.destination.error(err);\n        this.unsubscribe();\n    };\n    Subscriber.prototype._complete = function () {\n        this.destination.complete();\n        this.unsubscribe();\n    };\n    return Subscriber;\n}(Subscription_1.Subscription));\nexports.Subscriber = Subscriber;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SafeSubscriber = (function (_super) {\n    __extends(SafeSubscriber, _super);\n    function SafeSubscriber(_parent, observerOrNext, error, complete) {\n        _super.call(this);\n        this._parent = _parent;\n        var next;\n        var context = this;\n        if (isFunction_1.isFunction(observerOrNext)) {\n            next = observerOrNext;\n        }\n        else if (observerOrNext) {\n            context = observerOrNext;\n            next = observerOrNext.next;\n            error = observerOrNext.error;\n            complete = observerOrNext.complete;\n            if (isFunction_1.isFunction(context.unsubscribe)) {\n                this.add(context.unsubscribe.bind(context));\n            }\n            context.unsubscribe = this.unsubscribe.bind(this);\n        }\n        this._context = context;\n        this._next = next;\n        this._error = error;\n        this._complete = complete;\n    }\n    SafeSubscriber.prototype.next = function (value) {\n        if (!this.isStopped && this._next) {\n            var _parent = this._parent;\n            if (!_parent.syncErrorThrowable) {\n                this.__tryOrUnsub(this._next, value);\n            }\n            else if (this.__tryOrSetError(_parent, this._next, value)) {\n                this.unsubscribe();\n            }\n        }\n    };\n    SafeSubscriber.prototype.error = function (err) {\n        if (!this.isStopped) {\n            var _parent = this._parent;\n            if (this._error) {\n                if (!_parent.syncErrorThrowable) {\n                    this.__tryOrUnsub(this._error, err);\n                    this.unsubscribe();\n                }\n                else {\n                    this.__tryOrSetError(_parent, this._error, err);\n                    this.unsubscribe();\n                }\n            }\n            else if (!_parent.syncErrorThrowable) {\n                this.unsubscribe();\n                throw err;\n            }\n            else {\n                _parent.syncErrorValue = err;\n                _parent.syncErrorThrown = true;\n                this.unsubscribe();\n            }\n        }\n    };\n    SafeSubscriber.prototype.complete = function () {\n        if (!this.isStopped) {\n            var _parent = this._parent;\n            if (this._complete) {\n                if (!_parent.syncErrorThrowable) {\n                    this.__tryOrUnsub(this._complete);\n                    this.unsubscribe();\n                }\n                else {\n                    this.__tryOrSetError(_parent, this._complete);\n                    this.unsubscribe();\n                }\n            }\n            else {\n                this.unsubscribe();\n            }\n        }\n    };\n    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {\n        try {\n            fn.call(this._context, value);\n        }\n        catch (err) {\n            this.unsubscribe();\n            throw err;\n        }\n    };\n    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {\n        try {\n            fn.call(this._context, value);\n        }\n        catch (err) {\n            parent.syncErrorValue = err;\n            parent.syncErrorThrown = true;\n            return true;\n        }\n        return false;\n    };\n    SafeSubscriber.prototype._unsubscribe = function () {\n        var _parent = this._parent;\n        this._context = null;\n        this._parent = null;\n        _parent.unsubscribe();\n    };\n    return SafeSubscriber;\n}(Subscriber));\n//# sourceMappingURL=Subscriber.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/Subscriber.js\n ** module id = 8\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/Subscriber.js?");

/***/ },
/* 9 */
/***/ function(module, exports) {

	eval("\"use strict\";\nfunction isFunction(x) {\n    return typeof x === 'function';\n}\nexports.isFunction = isFunction;\n//# sourceMappingURL=isFunction.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/util/isFunction.js\n ** module id = 9\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/util/isFunction.js?");

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar isArray_1 = __webpack_require__(11);\nvar isObject_1 = __webpack_require__(12);\nvar isFunction_1 = __webpack_require__(9);\nvar tryCatch_1 = __webpack_require__(13);\nvar errorObject_1 = __webpack_require__(14);\nvar UnsubscriptionError_1 = __webpack_require__(15);\n/**\n * Represents a disposable resource, such as the execution of an Observable. A\n * Subscription has one important method, `unsubscribe`, that takes no argument\n * and just disposes the resource held by the subscription.\n *\n * Additionally, subscriptions may be grouped together through the `add()`\n * method, which will attach a child Subscription to the current Subscription.\n * When a Subscription is unsubscribed, all its children (and its grandchildren)\n * will be unsubscribed as well.\n *\n * @class Subscription\n */\nvar Subscription = (function () {\n    /**\n     * @param {function(): void} [unsubscribe] A function describing how to\n     * perform the disposal of resources when the `unsubscribe` method is called.\n     */\n    function Subscription(unsubscribe) {\n        /**\n         * A flag to indicate whether this Subscription has already been unsubscribed.\n         * @type {boolean}\n         */\n        this.closed = false;\n        if (unsubscribe) {\n            this._unsubscribe = unsubscribe;\n        }\n    }\n    /**\n     * Disposes the resources held by the subscription. May, for instance, cancel\n     * an ongoing Observable execution or cancel any other type of work that\n     * started when the Subscription was created.\n     * @return {void}\n     */\n    Subscription.prototype.unsubscribe = function () {\n        var hasErrors = false;\n        var errors;\n        if (this.closed) {\n            return;\n        }\n        this.closed = true;\n        var _a = this, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;\n        this._subscriptions = null;\n        if (isFunction_1.isFunction(_unsubscribe)) {\n            var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);\n            if (trial === errorObject_1.errorObject) {\n                hasErrors = true;\n                (errors = errors || []).push(errorObject_1.errorObject.e);\n            }\n        }\n        if (isArray_1.isArray(_subscriptions)) {\n            var index = -1;\n            var len = _subscriptions.length;\n            while (++index < len) {\n                var sub = _subscriptions[index];\n                if (isObject_1.isObject(sub)) {\n                    var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);\n                    if (trial === errorObject_1.errorObject) {\n                        hasErrors = true;\n                        errors = errors || [];\n                        var err = errorObject_1.errorObject.e;\n                        if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {\n                            errors = errors.concat(err.errors);\n                        }\n                        else {\n                            errors.push(err);\n                        }\n                    }\n                }\n            }\n        }\n        if (hasErrors) {\n            throw new UnsubscriptionError_1.UnsubscriptionError(errors);\n        }\n    };\n    /**\n     * Adds a tear down to be called during the unsubscribe() of this\n     * Subscription.\n     *\n     * If the tear down being added is a subscription that is already\n     * unsubscribed, is the same reference `add` is being called on, or is\n     * `Subscription.EMPTY`, it will not be added.\n     *\n     * If this subscription is already in an `closed` state, the passed\n     * tear down logic will be executed immediately.\n     *\n     * @param {TeardownLogic} teardown The additional logic to execute on\n     * teardown.\n     * @return {Subscription} Returns the Subscription used or created to be\n     * added to the inner subscriptions list. This Subscription can be used with\n     * `remove()` to remove the passed teardown logic from the inner subscriptions\n     * list.\n     */\n    Subscription.prototype.add = function (teardown) {\n        if (!teardown || (teardown === Subscription.EMPTY)) {\n            return Subscription.EMPTY;\n        }\n        if (teardown === this) {\n            return this;\n        }\n        var sub = teardown;\n        switch (typeof teardown) {\n            case 'function':\n                sub = new Subscription(teardown);\n            case 'object':\n                if (sub.closed || typeof sub.unsubscribe !== 'function') {\n                    break;\n                }\n                else if (this.closed) {\n                    sub.unsubscribe();\n                }\n                else {\n                    (this._subscriptions || (this._subscriptions = [])).push(sub);\n                }\n                break;\n            default:\n                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');\n        }\n        return sub;\n    };\n    /**\n     * Removes a Subscription from the internal list of subscriptions that will\n     * unsubscribe during the unsubscribe process of this Subscription.\n     * @param {Subscription} subscription The subscription to remove.\n     * @return {void}\n     */\n    Subscription.prototype.remove = function (subscription) {\n        // HACK: This might be redundant because of the logic in `add()`\n        if (subscription == null || (subscription === this) || (subscription === Subscription.EMPTY)) {\n            return;\n        }\n        var subscriptions = this._subscriptions;\n        if (subscriptions) {\n            var subscriptionIndex = subscriptions.indexOf(subscription);\n            if (subscriptionIndex !== -1) {\n                subscriptions.splice(subscriptionIndex, 1);\n            }\n        }\n    };\n    Subscription.EMPTY = (function (empty) {\n        empty.closed = true;\n        return empty;\n    }(new Subscription()));\n    return Subscription;\n}());\nexports.Subscription = Subscription;\n//# sourceMappingURL=Subscription.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/Subscription.js\n ** module id = 10\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/Subscription.js?");

/***/ },
/* 11 */
/***/ function(module, exports) {

	eval("\"use strict\";\nexports.isArray = Array.isArray || (function (x) { return x && typeof x.length === 'number'; });\n//# sourceMappingURL=isArray.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/util/isArray.js\n ** module id = 11\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/util/isArray.js?");

/***/ },
/* 12 */
/***/ function(module, exports) {

	eval("\"use strict\";\nfunction isObject(x) {\n    return x != null && typeof x === 'object';\n}\nexports.isObject = isObject;\n//# sourceMappingURL=isObject.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/util/isObject.js\n ** module id = 12\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/util/isObject.js?");

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar errorObject_1 = __webpack_require__(14);\nvar tryCatchTarget;\nfunction tryCatcher() {\n    try {\n        return tryCatchTarget.apply(this, arguments);\n    }\n    catch (e) {\n        errorObject_1.errorObject.e = e;\n        return errorObject_1.errorObject;\n    }\n}\nfunction tryCatch(fn) {\n    tryCatchTarget = fn;\n    return tryCatcher;\n}\nexports.tryCatch = tryCatch;\n;\n//# sourceMappingURL=tryCatch.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/util/tryCatch.js\n ** module id = 13\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/util/tryCatch.js?");

/***/ },
/* 14 */
/***/ function(module, exports) {

	eval("\"use strict\";\n// typeof any so that it we don't have to cast when comparing a result to the error object\nexports.errorObject = { e: {} };\n//# sourceMappingURL=errorObject.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/util/errorObject.js\n ** module id = 14\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/util/errorObject.js?");

/***/ },
/* 15 */
/***/ function(module, exports) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/**\n * An error thrown when one or more errors have occurred during the\n * `unsubscribe` of a {@link Subscription}.\n */\nvar UnsubscriptionError = (function (_super) {\n    __extends(UnsubscriptionError, _super);\n    function UnsubscriptionError(errors) {\n        _super.call(this);\n        this.errors = errors;\n        var err = Error.call(this, errors ?\n            errors.length + \" errors occurred during unsubscription:\\n  \" + errors.map(function (err, i) { return ((i + 1) + \") \" + err.toString()); }).join('\\n  ') : '');\n        this.name = err.name = 'UnsubscriptionError';\n        this.stack = err.stack;\n        this.message = err.message;\n    }\n    return UnsubscriptionError;\n}(Error));\nexports.UnsubscriptionError = UnsubscriptionError;\n//# sourceMappingURL=UnsubscriptionError.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/util/UnsubscriptionError.js\n ** module id = 15\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/util/UnsubscriptionError.js?");

/***/ },
/* 16 */
/***/ function(module, exports) {

	eval("\"use strict\";\nexports.empty = {\n    closed: true,\n    next: function (value) { },\n    error: function (err) { throw err; },\n    complete: function () { }\n};\n//# sourceMappingURL=Observer.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/Observer.js\n ** module id = 16\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/Observer.js?");

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar root_1 = __webpack_require__(6);\nvar Symbol = root_1.root.Symbol;\nexports.$$rxSubscriber = (typeof Symbol === 'function' && typeof Symbol.for === 'function') ?\n    Symbol.for('rxSubscriber') : '@@rxSubscriber';\n//# sourceMappingURL=rxSubscriber.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/symbol/rxSubscriber.js\n ** module id = 17\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/symbol/rxSubscriber.js?");

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar root_1 = __webpack_require__(6);\nfunction getSymbolObservable(context) {\n    var $$observable;\n    var Symbol = context.Symbol;\n    if (typeof Symbol === 'function') {\n        if (Symbol.observable) {\n            $$observable = Symbol.observable;\n        }\n        else {\n            $$observable = Symbol('observable');\n            Symbol.observable = $$observable;\n        }\n    }\n    else {\n        $$observable = '@@observable';\n    }\n    return $$observable;\n}\nexports.getSymbolObservable = getSymbolObservable;\nexports.$$observable = getSymbolObservable(root_1.root);\n//# sourceMappingURL=observable.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/symbol/observable.js\n ** module id = 18\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/symbol/observable.js?");

/***/ },
/* 19 */
/***/ function(module, exports) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/**\n * An error thrown when an action is invalid because the object has been\n * unsubscribed.\n *\n * @see {@link Subject}\n * @see {@link BehaviorSubject}\n *\n * @class ObjectUnsubscribedError\n */\nvar ObjectUnsubscribedError = (function (_super) {\n    __extends(ObjectUnsubscribedError, _super);\n    function ObjectUnsubscribedError() {\n        var err = _super.call(this, 'object unsubscribed');\n        this.name = err.name = 'ObjectUnsubscribedError';\n        this.stack = err.stack;\n        this.message = err.message;\n    }\n    return ObjectUnsubscribedError;\n}(Error));\nexports.ObjectUnsubscribedError = ObjectUnsubscribedError;\n//# sourceMappingURL=ObjectUnsubscribedError.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/util/ObjectUnsubscribedError.js\n ** module id = 19\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/util/ObjectUnsubscribedError.js?");

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscription_1 = __webpack_require__(10);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SubjectSubscription = (function (_super) {\n    __extends(SubjectSubscription, _super);\n    function SubjectSubscription(subject, subscriber) {\n        _super.call(this);\n        this.subject = subject;\n        this.subscriber = subscriber;\n        this.closed = false;\n    }\n    SubjectSubscription.prototype.unsubscribe = function () {\n        if (this.closed) {\n            return;\n        }\n        this.closed = true;\n        var subject = this.subject;\n        var observers = subject.observers;\n        this.subject = null;\n        if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {\n            return;\n        }\n        var subscriberIndex = observers.indexOf(this.subscriber);\n        if (subscriberIndex !== -1) {\n            observers.splice(subscriberIndex, 1);\n        }\n    };\n    return SubjectSubscription;\n}(Subscription_1.Subscription));\nexports.SubjectSubscription = SubjectSubscription;\n//# sourceMappingURL=SubjectSubscription.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/SubjectSubscription.js\n ** module id = 20\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/SubjectSubscription.js?");

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(global) {/**\n * @license Angular v2.0.1\n * (c) 2010-2016 Google, Inc. https://angular.io/\n * License: MIT\n */\n(function (global, factory) {\n     true ? factory(exports, __webpack_require__(22), __webpack_require__(3)) :\n    typeof define === 'function' && define.amd ? define(['exports', '@angular/common', '@angular/core'], factory) :\n    (factory((global.ng = global.ng || {}, global.ng.platformBrowser = global.ng.platformBrowser || {}),global.ng.common,global.ng.core));\n}(this, function (exports,_angular_common,_angular_core) { 'use strict';\n\n    var DebugDomRootRenderer = _angular_core.__core_private__.DebugDomRootRenderer;\n    var NoOpAnimationPlayer = _angular_core.__core_private__.NoOpAnimationPlayer;\n\n    var _NoOpAnimationDriver = (function () {\n        function _NoOpAnimationDriver() {\n        }\n        _NoOpAnimationDriver.prototype.animate = function (element, startingStyles, keyframes, duration, delay, easing) {\n            return new NoOpAnimationPlayer();\n        };\n        return _NoOpAnimationDriver;\n    }());\n    /**\n     * @experimental\n     */\n    var AnimationDriver = (function () {\n        function AnimationDriver() {\n        }\n        AnimationDriver.NOOP = new _NoOpAnimationDriver();\n        return AnimationDriver;\n    }());\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var globalScope;\n    if (typeof window === 'undefined') {\n        if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {\n            // TODO: Replace any with WorkerGlobalScope from lib.webworker.d.ts #3492\n            globalScope = self;\n        }\n        else {\n            globalScope = global;\n        }\n    }\n    else {\n        globalScope = window;\n    }\n    // Need to declare a new variable for global here since TypeScript\n    // exports the original value of the symbol.\n    var global$1 = globalScope;\n    var Date = global$1.Date;\n    // TODO: remove calls to assert in production environment\n    // Note: Can't just export this and import in in other files\n    // as `assert` is a reserved keyword in Dart\n    global$1.assert = function assert(condition) {\n        // TODO: to be fixed properly via #2830, noop for now\n    };\n    function isPresent(obj) {\n        return obj !== undefined && obj !== null;\n    }\n    function isBlank(obj) {\n        return obj === undefined || obj === null;\n    }\n    function isNumber(obj) {\n        return typeof obj === 'number';\n    }\n    function isString(obj) {\n        return typeof obj === 'string';\n    }\n    function isFunction(obj) {\n        return typeof obj === 'function';\n    }\n    function isArray(obj) {\n        return Array.isArray(obj);\n    }\n    function stringify(token) {\n        if (typeof token === 'string') {\n            return token;\n        }\n        if (token === undefined || token === null) {\n            return '' + token;\n        }\n        if (token.overriddenName) {\n            return token.overriddenName;\n        }\n        if (token.name) {\n            return token.name;\n        }\n        var res = token.toString();\n        var newLineIndex = res.indexOf('\\n');\n        return (newLineIndex === -1) ? res : res.substring(0, newLineIndex);\n    }\n    var StringWrapper = (function () {\n        function StringWrapper() {\n        }\n        StringWrapper.fromCharCode = function (code) { return String.fromCharCode(code); };\n        StringWrapper.charCodeAt = function (s, index) { return s.charCodeAt(index); };\n        StringWrapper.split = function (s, regExp) { return s.split(regExp); };\n        StringWrapper.equals = function (s, s2) { return s === s2; };\n        StringWrapper.stripLeft = function (s, charVal) {\n            if (s && s.length) {\n                var pos = 0;\n                for (var i = 0; i < s.length; i++) {\n                    if (s[i] != charVal)\n                        break;\n                    pos++;\n                }\n                s = s.substring(pos);\n            }\n            return s;\n        };\n        StringWrapper.stripRight = function (s, charVal) {\n            if (s && s.length) {\n                var pos = s.length;\n                for (var i = s.length - 1; i >= 0; i--) {\n                    if (s[i] != charVal)\n                        break;\n                    pos--;\n                }\n                s = s.substring(0, pos);\n            }\n            return s;\n        };\n        StringWrapper.replace = function (s, from, replace) {\n            return s.replace(from, replace);\n        };\n        StringWrapper.replaceAll = function (s, from, replace) {\n            return s.replace(from, replace);\n        };\n        StringWrapper.slice = function (s, from, to) {\n            if (from === void 0) { from = 0; }\n            if (to === void 0) { to = null; }\n            return s.slice(from, to === null ? undefined : to);\n        };\n        StringWrapper.replaceAllMapped = function (s, from, cb) {\n            return s.replace(from, function () {\n                var matches = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    matches[_i - 0] = arguments[_i];\n                }\n                // Remove offset & string from the result array\n                matches.splice(-2, 2);\n                // The callback receives match, p1, ..., pn\n                return cb(matches);\n            });\n        };\n        StringWrapper.contains = function (s, substr) { return s.indexOf(substr) != -1; };\n        StringWrapper.compare = function (a, b) {\n            if (a < b) {\n                return -1;\n            }\n            else if (a > b) {\n                return 1;\n            }\n            else {\n                return 0;\n            }\n        };\n        return StringWrapper;\n    }());\n    var NumberWrapper = (function () {\n        function NumberWrapper() {\n        }\n        NumberWrapper.toFixed = function (n, fractionDigits) { return n.toFixed(fractionDigits); };\n        NumberWrapper.equal = function (a, b) { return a === b; };\n        NumberWrapper.parseIntAutoRadix = function (text) {\n            var result = parseInt(text);\n            if (isNaN(result)) {\n                throw new Error('Invalid integer literal when parsing ' + text);\n            }\n            return result;\n        };\n        NumberWrapper.parseInt = function (text, radix) {\n            if (radix == 10) {\n                if (/^(\\-|\\+)?[0-9]+$/.test(text)) {\n                    return parseInt(text, radix);\n                }\n            }\n            else if (radix == 16) {\n                if (/^(\\-|\\+)?[0-9ABCDEFabcdef]+$/.test(text)) {\n                    return parseInt(text, radix);\n                }\n            }\n            else {\n                var result = parseInt(text, radix);\n                if (!isNaN(result)) {\n                    return result;\n                }\n            }\n            throw new Error('Invalid integer literal when parsing ' + text + ' in base ' + radix);\n        };\n        Object.defineProperty(NumberWrapper, \"NaN\", {\n            get: function () { return NaN; },\n            enumerable: true,\n            configurable: true\n        });\n        NumberWrapper.isNumeric = function (value) { return !isNaN(value - parseFloat(value)); };\n        NumberWrapper.isNaN = function (value) { return isNaN(value); };\n        NumberWrapper.isInteger = function (value) { return Number.isInteger(value); };\n        return NumberWrapper;\n    }());\n    // Can't be all uppercase as our transpiler would think it is a special directive...\n    var Json = (function () {\n        function Json() {\n        }\n        Json.parse = function (s) { return global$1.JSON.parse(s); };\n        Json.stringify = function (data) {\n            // Dart doesn't take 3 arguments\n            return global$1.JSON.stringify(data, null, 2);\n        };\n        return Json;\n    }());\n    var DateWrapper = (function () {\n        function DateWrapper() {\n        }\n        DateWrapper.create = function (year, month, day, hour, minutes, seconds, milliseconds) {\n            if (month === void 0) { month = 1; }\n            if (day === void 0) { day = 1; }\n            if (hour === void 0) { hour = 0; }\n            if (minutes === void 0) { minutes = 0; }\n            if (seconds === void 0) { seconds = 0; }\n            if (milliseconds === void 0) { milliseconds = 0; }\n            return new Date(year, month - 1, day, hour, minutes, seconds, milliseconds);\n        };\n        DateWrapper.fromISOString = function (str) { return new Date(str); };\n        DateWrapper.fromMillis = function (ms) { return new Date(ms); };\n        DateWrapper.toMillis = function (date) { return date.getTime(); };\n        DateWrapper.now = function () { return new Date(); };\n        DateWrapper.toJson = function (date) { return date.toJSON(); };\n        return DateWrapper;\n    }());\n    function setValueOnPath(global, path, value) {\n        var parts = path.split('.');\n        var obj = global;\n        while (parts.length > 1) {\n            var name = parts.shift();\n            if (obj.hasOwnProperty(name) && isPresent(obj[name])) {\n                obj = obj[name];\n            }\n            else {\n                obj = obj[name] = {};\n            }\n        }\n        if (obj === undefined || obj === null) {\n            obj = {};\n        }\n        obj[parts.shift()] = value;\n    }\n\n    var _clearValues = (function () {\n        if ((new Map()).keys().next) {\n            return function _clearValues(m) {\n                var keyIterator = m.keys();\n                var k;\n                while (!((k = keyIterator.next()).done)) {\n                    m.set(k.value, null);\n                }\n            };\n        }\n        else {\n            return function _clearValuesWithForeEach(m) {\n                m.forEach(function (v, k) { m.set(k, null); });\n            };\n        }\n    })();\n    // Safari doesn't implement MapIterator.next(), which is used is Traceur's polyfill of Array.from\n    // TODO(mlaval): remove the work around once we have a working polyfill of Array.from\n    var _arrayFromMap = (function () {\n        try {\n            if ((new Map()).values().next) {\n                return function createArrayFromMap(m, getValues) {\n                    return getValues ? Array.from(m.values()) : Array.from(m.keys());\n                };\n            }\n        }\n        catch (e) {\n        }\n        return function createArrayFromMapWithForeach(m, getValues) {\n            var res = new Array(m.size), i = 0;\n            m.forEach(function (v, k) {\n                res[i] = getValues ? v : k;\n                i++;\n            });\n            return res;\n        };\n    })();\n    /**\n     * Wraps Javascript Objects\n     */\n    var StringMapWrapper = (function () {\n        function StringMapWrapper() {\n        }\n        StringMapWrapper.get = function (map, key) {\n            return map.hasOwnProperty(key) ? map[key] : undefined;\n        };\n        StringMapWrapper.set = function (map, key, value) { map[key] = value; };\n        StringMapWrapper.keys = function (map) { return Object.keys(map); };\n        StringMapWrapper.values = function (map) {\n            return Object.keys(map).map(function (k) { return map[k]; });\n        };\n        StringMapWrapper.isEmpty = function (map) {\n            for (var prop in map) {\n                return false;\n            }\n            return true;\n        };\n        StringMapWrapper.forEach = function (map, callback) {\n            for (var _i = 0, _a = Object.keys(map); _i < _a.length; _i++) {\n                var k = _a[_i];\n                callback(map[k], k);\n            }\n        };\n        StringMapWrapper.merge = function (m1, m2) {\n            var m = {};\n            for (var _i = 0, _a = Object.keys(m1); _i < _a.length; _i++) {\n                var k = _a[_i];\n                m[k] = m1[k];\n            }\n            for (var _b = 0, _c = Object.keys(m2); _b < _c.length; _b++) {\n                var k = _c[_b];\n                m[k] = m2[k];\n            }\n            return m;\n        };\n        StringMapWrapper.equals = function (m1, m2) {\n            var k1 = Object.keys(m1);\n            var k2 = Object.keys(m2);\n            if (k1.length != k2.length) {\n                return false;\n            }\n            for (var i = 0; i < k1.length; i++) {\n                var key = k1[i];\n                if (m1[key] !== m2[key]) {\n                    return false;\n                }\n            }\n            return true;\n        };\n        return StringMapWrapper;\n    }());\n    var ListWrapper = (function () {\n        function ListWrapper() {\n        }\n        // JS has no way to express a statically fixed size list, but dart does so we\n        // keep both methods.\n        ListWrapper.createFixedSize = function (size) { return new Array(size); };\n        ListWrapper.createGrowableSize = function (size) { return new Array(size); };\n        ListWrapper.clone = function (array) { return array.slice(0); };\n        ListWrapper.forEachWithIndex = function (array, fn) {\n            for (var i = 0; i < array.length; i++) {\n                fn(array[i], i);\n            }\n        };\n        ListWrapper.first = function (array) {\n            if (!array)\n                return null;\n            return array[0];\n        };\n        ListWrapper.last = function (array) {\n            if (!array || array.length == 0)\n                return null;\n            return array[array.length - 1];\n        };\n        ListWrapper.indexOf = function (array, value, startIndex) {\n            if (startIndex === void 0) { startIndex = 0; }\n            return array.indexOf(value, startIndex);\n        };\n        ListWrapper.contains = function (list, el) { return list.indexOf(el) !== -1; };\n        ListWrapper.reversed = function (array) {\n            var a = ListWrapper.clone(array);\n            return a.reverse();\n        };\n        ListWrapper.concat = function (a, b) { return a.concat(b); };\n        ListWrapper.insert = function (list, index, value) { list.splice(index, 0, value); };\n        ListWrapper.removeAt = function (list, index) {\n            var res = list[index];\n            list.splice(index, 1);\n            return res;\n        };\n        ListWrapper.removeAll = function (list, items) {\n            for (var i = 0; i < items.length; ++i) {\n                var index = list.indexOf(items[i]);\n                list.splice(index, 1);\n            }\n        };\n        ListWrapper.remove = function (list, el) {\n            var index = list.indexOf(el);\n            if (index > -1) {\n                list.splice(index, 1);\n                return true;\n            }\n            return false;\n        };\n        ListWrapper.clear = function (list) { list.length = 0; };\n        ListWrapper.isEmpty = function (list) { return list.length == 0; };\n        ListWrapper.fill = function (list, value, start, end) {\n            if (start === void 0) { start = 0; }\n            if (end === void 0) { end = null; }\n            list.fill(value, start, end === null ? list.length : end);\n        };\n        ListWrapper.equals = function (a, b) {\n            if (a.length != b.length)\n                return false;\n            for (var i = 0; i < a.length; ++i) {\n                if (a[i] !== b[i])\n                    return false;\n            }\n            return true;\n        };\n        ListWrapper.slice = function (l, from, to) {\n            if (from === void 0) { from = 0; }\n            if (to === void 0) { to = null; }\n            return l.slice(from, to === null ? undefined : to);\n        };\n        ListWrapper.splice = function (l, from, length) { return l.splice(from, length); };\n        ListWrapper.sort = function (l, compareFn) {\n            if (isPresent(compareFn)) {\n                l.sort(compareFn);\n            }\n            else {\n                l.sort();\n            }\n        };\n        ListWrapper.toString = function (l) { return l.toString(); };\n        ListWrapper.toJSON = function (l) { return JSON.stringify(l); };\n        ListWrapper.maximum = function (list, predicate) {\n            if (list.length == 0) {\n                return null;\n            }\n            var solution = null;\n            var maxValue = -Infinity;\n            for (var index = 0; index < list.length; index++) {\n                var candidate = list[index];\n                if (isBlank(candidate)) {\n                    continue;\n                }\n                var candidateValue = predicate(candidate);\n                if (candidateValue > maxValue) {\n                    solution = candidate;\n                    maxValue = candidateValue;\n                }\n            }\n            return solution;\n        };\n        ListWrapper.flatten = function (list) {\n            var target = [];\n            _flattenArray(list, target);\n            return target;\n        };\n        ListWrapper.addAll = function (list, source) {\n            for (var i = 0; i < source.length; i++) {\n                list.push(source[i]);\n            }\n        };\n        return ListWrapper;\n    }());\n    function _flattenArray(source, target) {\n        if (isPresent(source)) {\n            for (var i = 0; i < source.length; i++) {\n                var item = source[i];\n                if (isArray(item)) {\n                    _flattenArray(item, target);\n                }\n                else {\n                    target.push(item);\n                }\n            }\n        }\n        return target;\n    }\n\n    var CAMEL_CASE_REGEXP = /([A-Z])/g;\n    var DASH_CASE_REGEXP = /-([a-z])/g;\n    function camelCaseToDashCase(input) {\n        return StringWrapper.replaceAllMapped(input, CAMEL_CASE_REGEXP, function (m /** TODO #9100 */) { return '-' + m[1].toLowerCase(); });\n    }\n    function dashCaseToCamelCase(input) {\n        return StringWrapper.replaceAllMapped(input, DASH_CASE_REGEXP, function (m /** TODO #9100 */) { return m[1].toUpperCase(); });\n    }\n\n    var _DOM = null;\n    function getDOM() {\n        return _DOM;\n    }\n    function setRootDomAdapter(adapter) {\n        if (isBlank(_DOM)) {\n            _DOM = adapter;\n        }\n    }\n    /* tslint:disable:requireParameterType */\n    /**\n     * Provides DOM operations in an environment-agnostic way.\n     *\n     * @security Tread carefully! Interacting with the DOM directly is dangerous and\n     * can introduce XSS risks.\n     */\n    var DomAdapter = (function () {\n        function DomAdapter() {\n            this.resourceLoaderType = null;\n        }\n        Object.defineProperty(DomAdapter.prototype, \"attrToPropMap\", {\n            /**\n             * Maps attribute names to their corresponding property names for cases\n             * where attribute name doesn't match property name.\n             */\n            get: function () { return this._attrToPropMap; },\n            set: function (value) { this._attrToPropMap = value; },\n            enumerable: true,\n            configurable: true\n        });\n        ;\n        ;\n        return DomAdapter;\n    }());\n\n    var WebAnimationsPlayer = (function () {\n        function WebAnimationsPlayer(element, keyframes, options) {\n            this.element = element;\n            this.keyframes = keyframes;\n            this.options = options;\n            this._onDoneFns = [];\n            this._onStartFns = [];\n            this._finished = false;\n            this._initialized = false;\n            this._started = false;\n            this.parentPlayer = null;\n            this._duration = options['duration'];\n        }\n        WebAnimationsPlayer.prototype._onFinish = function () {\n            if (!this._finished) {\n                this._finished = true;\n                if (!isPresent(this.parentPlayer)) {\n                    this.destroy();\n                }\n                this._onDoneFns.forEach(function (fn) { return fn(); });\n                this._onDoneFns = [];\n            }\n        };\n        WebAnimationsPlayer.prototype.init = function () {\n            var _this = this;\n            if (this._initialized)\n                return;\n            this._initialized = true;\n            var keyframes = this.keyframes.map(function (styles) {\n                var formattedKeyframe = {};\n                StringMapWrapper.forEach(styles, function (value, prop) {\n                    formattedKeyframe[prop] = value == _angular_core.AUTO_STYLE ? _computeStyle(_this.element, prop) : value;\n                });\n                return formattedKeyframe;\n            });\n            this._player = this._triggerWebAnimation(this.element, keyframes, this.options);\n            // this is required so that the player doesn't start to animate right away\n            this.reset();\n            this._player.onfinish = function () { return _this._onFinish(); };\n        };\n        /** @internal */\n        WebAnimationsPlayer.prototype._triggerWebAnimation = function (element, keyframes, options) {\n            return element.animate(keyframes, options);\n        };\n        WebAnimationsPlayer.prototype.onStart = function (fn) { this._onStartFns.push(fn); };\n        WebAnimationsPlayer.prototype.onDone = function (fn) { this._onDoneFns.push(fn); };\n        WebAnimationsPlayer.prototype.play = function () {\n            this.init();\n            if (!this.hasStarted()) {\n                this._onStartFns.forEach(function (fn) { return fn(); });\n                this._onStartFns = [];\n                this._started = true;\n            }\n            this._player.play();\n        };\n        WebAnimationsPlayer.prototype.pause = function () {\n            this.init();\n            this._player.pause();\n        };\n        WebAnimationsPlayer.prototype.finish = function () {\n            this.init();\n            this._onFinish();\n            this._player.finish();\n        };\n        WebAnimationsPlayer.prototype.reset = function () { this._player.cancel(); };\n        WebAnimationsPlayer.prototype.restart = function () {\n            this.reset();\n            this.play();\n        };\n        WebAnimationsPlayer.prototype.hasStarted = function () { return this._started; };\n        WebAnimationsPlayer.prototype.destroy = function () {\n            this.reset();\n            this._onFinish();\n        };\n        Object.defineProperty(WebAnimationsPlayer.prototype, \"totalTime\", {\n            get: function () { return this._duration; },\n            enumerable: true,\n            configurable: true\n        });\n        WebAnimationsPlayer.prototype.setPosition = function (p) { this._player.currentTime = p * this.totalTime; };\n        WebAnimationsPlayer.prototype.getPosition = function () { return this._player.currentTime / this.totalTime; };\n        return WebAnimationsPlayer;\n    }());\n    function _computeStyle(element, prop) {\n        return getDOM().getComputedStyle(element)[prop];\n    }\n\n    var WebAnimationsDriver = (function () {\n        function WebAnimationsDriver() {\n        }\n        WebAnimationsDriver.prototype.animate = function (element, startingStyles, keyframes, duration, delay, easing) {\n            var formattedSteps = [];\n            var startingStyleLookup = {};\n            if (isPresent(startingStyles) && startingStyles.styles.length > 0) {\n                startingStyleLookup = _populateStyles(element, startingStyles, {});\n                startingStyleLookup['offset'] = 0;\n                formattedSteps.push(startingStyleLookup);\n            }\n            keyframes.forEach(function (keyframe) {\n                var data = _populateStyles(element, keyframe.styles, startingStyleLookup);\n                data['offset'] = keyframe.offset;\n                formattedSteps.push(data);\n            });\n            // this is a special case when only styles are applied as an\n            // animation. When this occurs we want to animate from start to\n            // end with the same values. Removing the offset and having only\n            // start/end values is suitable enough for the web-animations API\n            if (formattedSteps.length == 1) {\n                var start = formattedSteps[0];\n                start['offset'] = null;\n                formattedSteps = [start, start];\n            }\n            var playerOptions = {\n                'duration': duration,\n                'delay': delay,\n                'fill': 'both' // we use `both` because it allows for styling at 0% to work with `delay`\n            };\n            // we check for this to avoid having a null|undefined value be present\n            // for the easing (which results in an error for certain browsers #9752)\n            if (easing) {\n                playerOptions['easing'] = easing;\n            }\n            return new WebAnimationsPlayer(element, formattedSteps, playerOptions);\n        };\n        return WebAnimationsDriver;\n    }());\n    function _populateStyles(element, styles, defaultStyles) {\n        var data = {};\n        styles.styles.forEach(function (entry) {\n            StringMapWrapper.forEach(entry, function (val, prop) {\n                var formattedProp = dashCaseToCamelCase(prop);\n                data[formattedProp] =\n                    val == _angular_core.AUTO_STYLE ? val : val.toString() + _resolveStyleUnit(val, prop, formattedProp);\n            });\n        });\n        StringMapWrapper.forEach(defaultStyles, function (value, prop) {\n            if (!isPresent(data[prop])) {\n                data[prop] = value;\n            }\n        });\n        return data;\n    }\n    function _resolveStyleUnit(val, userProvidedProp, formattedProp) {\n        var unit = '';\n        if (_isPixelDimensionStyle(formattedProp) && val != 0 && val != '0') {\n            if (isNumber(val)) {\n                unit = 'px';\n            }\n            else if (_findDimensionalSuffix(val.toString()).length == 0) {\n                throw new Error('Please provide a CSS unit value for ' + userProvidedProp + ':' + val);\n            }\n        }\n        return unit;\n    }\n    var _$0 = 48;\n    var _$9 = 57;\n    var _$PERIOD = 46;\n    function _findDimensionalSuffix(value) {\n        for (var i = 0; i < value.length; i++) {\n            var c = StringWrapper.charCodeAt(value, i);\n            if ((c >= _$0 && c <= _$9) || c == _$PERIOD)\n                continue;\n            return value.substring(i, value.length);\n        }\n        return '';\n    }\n    function _isPixelDimensionStyle(prop) {\n        switch (prop) {\n            case 'width':\n            case 'height':\n            case 'minWidth':\n            case 'minHeight':\n            case 'maxWidth':\n            case 'maxHeight':\n            case 'left':\n            case 'top':\n            case 'bottom':\n            case 'right':\n            case 'fontSize':\n            case 'outlineWidth':\n            case 'outlineOffset':\n            case 'paddingTop':\n            case 'paddingLeft':\n            case 'paddingBottom':\n            case 'paddingRight':\n            case 'marginTop':\n            case 'marginLeft':\n            case 'marginBottom':\n            case 'marginRight':\n            case 'borderRadius':\n            case 'borderWidth':\n            case 'borderTopWidth':\n            case 'borderLeftWidth':\n            case 'borderRightWidth':\n            case 'borderBottomWidth':\n            case 'textIndent':\n                return true;\n            default:\n                return false;\n        }\n    }\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$1 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    /**\n     * Provides DOM operations in any browser environment.\n     *\n     * @security Tread carefully! Interacting with the DOM directly is dangerous and\n     * can introduce XSS risks.\n     */\n    var GenericBrowserDomAdapter = (function (_super) {\n        __extends$1(GenericBrowserDomAdapter, _super);\n        function GenericBrowserDomAdapter() {\n            var _this = this;\n            _super.call(this);\n            this._animationPrefix = null;\n            this._transitionEnd = null;\n            try {\n                var element = this.createElement('div', this.defaultDoc());\n                if (isPresent(this.getStyle(element, 'animationName'))) {\n                    this._animationPrefix = '';\n                }\n                else {\n                    var domPrefixes = ['Webkit', 'Moz', 'O', 'ms'];\n                    for (var i = 0; i < domPrefixes.length; i++) {\n                        if (isPresent(this.getStyle(element, domPrefixes[i] + 'AnimationName'))) {\n                            this._animationPrefix = '-' + domPrefixes[i].toLowerCase() + '-';\n                            break;\n                        }\n                    }\n                }\n                var transEndEventNames = {\n                    WebkitTransition: 'webkitTransitionEnd',\n                    MozTransition: 'transitionend',\n                    OTransition: 'oTransitionEnd otransitionend',\n                    transition: 'transitionend'\n                };\n                StringMapWrapper.forEach(transEndEventNames, function (value, key) {\n                    if (isPresent(_this.getStyle(element, key))) {\n                        _this._transitionEnd = value;\n                    }\n                });\n            }\n            catch (e) {\n                this._animationPrefix = null;\n                this._transitionEnd = null;\n            }\n        }\n        GenericBrowserDomAdapter.prototype.getDistributedNodes = function (el) { return el.getDistributedNodes(); };\n        GenericBrowserDomAdapter.prototype.resolveAndSetHref = function (el, baseUrl, href) {\n            el.href = href == null ? baseUrl : baseUrl + '/../' + href;\n        };\n        GenericBrowserDomAdapter.prototype.supportsDOMEvents = function () { return true; };\n        GenericBrowserDomAdapter.prototype.supportsNativeShadowDOM = function () {\n            return isFunction(this.defaultDoc().body.createShadowRoot);\n        };\n        GenericBrowserDomAdapter.prototype.getAnimationPrefix = function () {\n            return isPresent(this._animationPrefix) ? this._animationPrefix : '';\n        };\n        GenericBrowserDomAdapter.prototype.getTransitionEnd = function () { return isPresent(this._transitionEnd) ? this._transitionEnd : ''; };\n        GenericBrowserDomAdapter.prototype.supportsAnimation = function () {\n            return isPresent(this._animationPrefix) && isPresent(this._transitionEnd);\n        };\n        return GenericBrowserDomAdapter;\n    }(DomAdapter));\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    var _attrToPropMap = {\n        'class': 'className',\n        'innerHtml': 'innerHTML',\n        'readonly': 'readOnly',\n        'tabindex': 'tabIndex'\n    };\n    var DOM_KEY_LOCATION_NUMPAD = 3;\n    // Map to convert some key or keyIdentifier values to what will be returned by getEventKey\n    var _keyMap = {\n        // The following values are here for cross-browser compatibility and to match the W3C standard\n        // cf http://www.w3.org/TR/DOM-Level-3-Events-key/\n        '\\b': 'Backspace',\n        '\\t': 'Tab',\n        '\\x7F': 'Delete',\n        '\\x1B': 'Escape',\n        'Del': 'Delete',\n        'Esc': 'Escape',\n        'Left': 'ArrowLeft',\n        'Right': 'ArrowRight',\n        'Up': 'ArrowUp',\n        'Down': 'ArrowDown',\n        'Menu': 'ContextMenu',\n        'Scroll': 'ScrollLock',\n        'Win': 'OS'\n    };\n    // There is a bug in Chrome for numeric keypad keys:\n    // https://code.google.com/p/chromium/issues/detail?id=155654\n    // 1, 2, 3 ... are reported as A, B, C ...\n    var _chromeNumKeyPadMap = {\n        'A': '1',\n        'B': '2',\n        'C': '3',\n        'D': '4',\n        'E': '5',\n        'F': '6',\n        'G': '7',\n        'H': '8',\n        'I': '9',\n        'J': '*',\n        'K': '+',\n        'M': '-',\n        'N': '.',\n        'O': '/',\n        '\\x60': '0',\n        '\\x90': 'NumLock'\n    };\n    /**\n     * A `DomAdapter` powered by full browser DOM APIs.\n     *\n     * @security Tread carefully! Interacting with the DOM directly is dangerous and\n     * can introduce XSS risks.\n     */\n    /* tslint:disable:requireParameterType */\n    var BrowserDomAdapter = (function (_super) {\n        __extends(BrowserDomAdapter, _super);\n        function BrowserDomAdapter() {\n            _super.apply(this, arguments);\n        }\n        BrowserDomAdapter.prototype.parse = function (templateHtml) { throw new Error('parse not implemented'); };\n        BrowserDomAdapter.makeCurrent = function () { setRootDomAdapter(new BrowserDomAdapter()); };\n        BrowserDomAdapter.prototype.hasProperty = function (element /** TODO #9100 */, name) { return name in element; };\n        BrowserDomAdapter.prototype.setProperty = function (el, name, value) { el[name] = value; };\n        BrowserDomAdapter.prototype.getProperty = function (el, name) { return el[name]; };\n        BrowserDomAdapter.prototype.invoke = function (el, methodName, args) {\n            el[methodName].apply(el, args);\n        };\n        // TODO(tbosch): move this into a separate environment class once we have it\n        BrowserDomAdapter.prototype.logError = function (error /** TODO #9100 */) {\n            if (window.console.error) {\n                window.console.error(error);\n            }\n            else {\n                window.console.log(error);\n            }\n        };\n        BrowserDomAdapter.prototype.log = function (error /** TODO #9100 */) { window.console.log(error); };\n        BrowserDomAdapter.prototype.logGroup = function (error /** TODO #9100 */) {\n            if (window.console.group) {\n                window.console.group(error);\n                this.logError(error);\n            }\n            else {\n                window.console.log(error);\n            }\n        };\n        BrowserDomAdapter.prototype.logGroupEnd = function () {\n            if (window.console.groupEnd) {\n                window.console.groupEnd();\n            }\n        };\n        Object.defineProperty(BrowserDomAdapter.prototype, \"attrToPropMap\", {\n            get: function () { return _attrToPropMap; },\n            enumerable: true,\n            configurable: true\n        });\n        BrowserDomAdapter.prototype.query = function (selector) { return document.querySelector(selector); };\n        BrowserDomAdapter.prototype.querySelector = function (el /** TODO #9100 */, selector) {\n            return el.querySelector(selector);\n        };\n        BrowserDomAdapter.prototype.querySelectorAll = function (el /** TODO #9100 */, selector) {\n            return el.querySelectorAll(selector);\n        };\n        BrowserDomAdapter.prototype.on = function (el /** TODO #9100 */, evt /** TODO #9100 */, listener /** TODO #9100 */) {\n            el.addEventListener(evt, listener, false);\n        };\n        BrowserDomAdapter.prototype.onAndCancel = function (el /** TODO #9100 */, evt /** TODO #9100 */, listener /** TODO #9100 */) {\n            el.addEventListener(evt, listener, false);\n            // Needed to follow Dart's subscription semantic, until fix of\n            // https://code.google.com/p/dart/issues/detail?id=17406\n            return function () { el.removeEventListener(evt, listener, false); };\n        };\n        BrowserDomAdapter.prototype.dispatchEvent = function (el /** TODO #9100 */, evt /** TODO #9100 */) { el.dispatchEvent(evt); };\n        BrowserDomAdapter.prototype.createMouseEvent = function (eventType) {\n            var evt = document.createEvent('MouseEvent');\n            evt.initEvent(eventType, true, true);\n            return evt;\n        };\n        BrowserDomAdapter.prototype.createEvent = function (eventType /** TODO #9100 */) {\n            var evt = document.createEvent('Event');\n            evt.initEvent(eventType, true, true);\n            return evt;\n        };\n        BrowserDomAdapter.prototype.preventDefault = function (evt) {\n            evt.preventDefault();\n            evt.returnValue = false;\n        };\n        BrowserDomAdapter.prototype.isPrevented = function (evt) {\n            return evt.defaultPrevented || isPresent(evt.returnValue) && !evt.returnValue;\n        };\n        BrowserDomAdapter.prototype.getInnerHTML = function (el /** TODO #9100 */) { return el.innerHTML; };\n        BrowserDomAdapter.prototype.getTemplateContent = function (el /** TODO #9100 */) {\n            return 'content' in el && el instanceof HTMLTemplateElement ? el.content : null;\n        };\n        BrowserDomAdapter.prototype.getOuterHTML = function (el /** TODO #9100 */) { return el.outerHTML; };\n        BrowserDomAdapter.prototype.nodeName = function (node) { return node.nodeName; };\n        BrowserDomAdapter.prototype.nodeValue = function (node) { return node.nodeValue; };\n        BrowserDomAdapter.prototype.type = function (node) { return node.type; };\n        BrowserDomAdapter.prototype.content = function (node) {\n            if (this.hasProperty(node, 'content')) {\n                return node.content;\n            }\n            else {\n                return node;\n            }\n        };\n        BrowserDomAdapter.prototype.firstChild = function (el /** TODO #9100 */) { return el.firstChild; };\n        BrowserDomAdapter.prototype.nextSibling = function (el /** TODO #9100 */) { return el.nextSibling; };\n        BrowserDomAdapter.prototype.parentElement = function (el /** TODO #9100 */) { return el.parentNode; };\n        BrowserDomAdapter.prototype.childNodes = function (el /** TODO #9100 */) { return el.childNodes; };\n        BrowserDomAdapter.prototype.childNodesAsList = function (el /** TODO #9100 */) {\n            var childNodes = el.childNodes;\n            var res = new Array(childNodes.length);\n            for (var i = 0; i < childNodes.length; i++) {\n                res[i] = childNodes[i];\n            }\n            return res;\n        };\n        BrowserDomAdapter.prototype.clearNodes = function (el /** TODO #9100 */) {\n            while (el.firstChild) {\n                el.removeChild(el.firstChild);\n            }\n        };\n        BrowserDomAdapter.prototype.appendChild = function (el /** TODO #9100 */, node /** TODO #9100 */) { el.appendChild(node); };\n        BrowserDomAdapter.prototype.removeChild = function (el /** TODO #9100 */, node /** TODO #9100 */) { el.removeChild(node); };\n        BrowserDomAdapter.prototype.replaceChild = function (el, newChild /** TODO #9100 */, oldChild /** TODO #9100 */) {\n            el.replaceChild(newChild, oldChild);\n        };\n        BrowserDomAdapter.prototype.remove = function (node /** TODO #9100 */) {\n            if (node.parentNode) {\n                node.parentNode.removeChild(node);\n            }\n            return node;\n        };\n        BrowserDomAdapter.prototype.insertBefore = function (el /** TODO #9100 */, node /** TODO #9100 */) {\n            el.parentNode.insertBefore(node, el);\n        };\n        BrowserDomAdapter.prototype.insertAllBefore = function (el /** TODO #9100 */, nodes /** TODO #9100 */) {\n            nodes.forEach(function (n /** TODO #9100 */) { return el.parentNode.insertBefore(n, el); });\n        };\n        BrowserDomAdapter.prototype.insertAfter = function (el /** TODO #9100 */, node /** TODO #9100 */) {\n            el.parentNode.insertBefore(node, el.nextSibling);\n        };\n        BrowserDomAdapter.prototype.setInnerHTML = function (el /** TODO #9100 */, value /** TODO #9100 */) { el.innerHTML = value; };\n        BrowserDomAdapter.prototype.getText = function (el /** TODO #9100 */) { return el.textContent; };\n        // TODO(vicb): removed Element type because it does not support StyleElement\n        BrowserDomAdapter.prototype.setText = function (el /** TODO #9100 */, value) { el.textContent = value; };\n        BrowserDomAdapter.prototype.getValue = function (el /** TODO #9100 */) { return el.value; };\n        BrowserDomAdapter.prototype.setValue = function (el /** TODO #9100 */, value) { el.value = value; };\n        BrowserDomAdapter.prototype.getChecked = function (el /** TODO #9100 */) { return el.checked; };\n        BrowserDomAdapter.prototype.setChecked = function (el /** TODO #9100 */, value) { el.checked = value; };\n        BrowserDomAdapter.prototype.createComment = function (text) { return document.createComment(text); };\n        BrowserDomAdapter.prototype.createTemplate = function (html /** TODO #9100 */) {\n            var t = document.createElement('template');\n            t.innerHTML = html;\n            return t;\n        };\n        BrowserDomAdapter.prototype.createElement = function (tagName /* TODO #9100 */, doc) {\n            if (doc === void 0) { doc = document; }\n            return doc.createElement(tagName);\n        };\n        BrowserDomAdapter.prototype.createElementNS = function (ns /* TODO #9100 */, tagName /* TODO #9100 */, doc) {\n            if (doc === void 0) { doc = document; }\n            return doc.createElementNS(ns, tagName);\n        };\n        BrowserDomAdapter.prototype.createTextNode = function (text, doc) {\n            if (doc === void 0) { doc = document; }\n            return doc.createTextNode(text);\n        };\n        BrowserDomAdapter.prototype.createScriptTag = function (attrName, attrValue, doc) {\n            if (doc === void 0) { doc = document; }\n            var el = doc.createElement('SCRIPT');\n            el.setAttribute(attrName, attrValue);\n            return el;\n        };\n        BrowserDomAdapter.prototype.createStyleElement = function (css, doc) {\n            if (doc === void 0) { doc = document; }\n            var style = doc.createElement('style');\n            this.appendChild(style, this.createTextNode(css));\n            return style;\n        };\n        BrowserDomAdapter.prototype.createShadowRoot = function (el) { return el.createShadowRoot(); };\n        BrowserDomAdapter.prototype.getShadowRoot = function (el) { return el.shadowRoot; };\n        BrowserDomAdapter.prototype.getHost = function (el) { return el.host; };\n        BrowserDomAdapter.prototype.clone = function (node) { return node.cloneNode(true); };\n        BrowserDomAdapter.prototype.getElementsByClassName = function (element /** TODO #9100 */, name) {\n            return element.getElementsByClassName(name);\n        };\n        BrowserDomAdapter.prototype.getElementsByTagName = function (element /** TODO #9100 */, name) {\n            return element.getElementsByTagName(name);\n        };\n        BrowserDomAdapter.prototype.classList = function (element /** TODO #9100 */) {\n            return Array.prototype.slice.call(element.classList, 0);\n        };\n        BrowserDomAdapter.prototype.addClass = function (element /** TODO #9100 */, className) { element.classList.add(className); };\n        BrowserDomAdapter.prototype.removeClass = function (element /** TODO #9100 */, className) {\n            element.classList.remove(className);\n        };\n        BrowserDomAdapter.prototype.hasClass = function (element /** TODO #9100 */, className) {\n            return element.classList.contains(className);\n        };\n        BrowserDomAdapter.prototype.setStyle = function (element /** TODO #9100 */, styleName, styleValue) {\n            element.style[styleName] = styleValue;\n        };\n        BrowserDomAdapter.prototype.removeStyle = function (element /** TODO #9100 */, stylename) {\n            element.style[stylename] = null;\n        };\n        BrowserDomAdapter.prototype.getStyle = function (element /** TODO #9100 */, stylename) {\n            return element.style[stylename];\n        };\n        BrowserDomAdapter.prototype.hasStyle = function (element /** TODO #9100 */, styleName, styleValue) {\n            if (styleValue === void 0) { styleValue = null; }\n            var value = this.getStyle(element, styleName) || '';\n            return styleValue ? value == styleValue : value.length > 0;\n        };\n        BrowserDomAdapter.prototype.tagName = function (element /** TODO #9100 */) { return element.tagName; };\n        BrowserDomAdapter.prototype.attributeMap = function (element /** TODO #9100 */) {\n            var res = new Map();\n            var elAttrs = element.attributes;\n            for (var i = 0; i < elAttrs.length; i++) {\n                var attrib = elAttrs[i];\n                res.set(attrib.name, attrib.value);\n            }\n            return res;\n        };\n        BrowserDomAdapter.prototype.hasAttribute = function (element /** TODO #9100 */, attribute) {\n            return element.hasAttribute(attribute);\n        };\n        BrowserDomAdapter.prototype.hasAttributeNS = function (element /** TODO #9100 */, ns, attribute) {\n            return element.hasAttributeNS(ns, attribute);\n        };\n        BrowserDomAdapter.prototype.getAttribute = function (element /** TODO #9100 */, attribute) {\n            return element.getAttribute(attribute);\n        };\n        BrowserDomAdapter.prototype.getAttributeNS = function (element /** TODO #9100 */, ns, name) {\n            return element.getAttributeNS(ns, name);\n        };\n        BrowserDomAdapter.prototype.setAttribute = function (element /** TODO #9100 */, name, value) {\n            element.setAttribute(name, value);\n        };\n        BrowserDomAdapter.prototype.setAttributeNS = function (element /** TODO #9100 */, ns, name, value) {\n            element.setAttributeNS(ns, name, value);\n        };\n        BrowserDomAdapter.prototype.removeAttribute = function (element /** TODO #9100 */, attribute) {\n            element.removeAttribute(attribute);\n        };\n        BrowserDomAdapter.prototype.removeAttributeNS = function (element /** TODO #9100 */, ns, name) {\n            element.removeAttributeNS(ns, name);\n        };\n        BrowserDomAdapter.prototype.templateAwareRoot = function (el /** TODO #9100 */) {\n            return this.isTemplateElement(el) ? this.content(el) : el;\n        };\n        BrowserDomAdapter.prototype.createHtmlDocument = function () {\n            return document.implementation.createHTMLDocument('fakeTitle');\n        };\n        BrowserDomAdapter.prototype.defaultDoc = function () { return document; };\n        BrowserDomAdapter.prototype.getBoundingClientRect = function (el /** TODO #9100 */) {\n            try {\n                return el.getBoundingClientRect();\n            }\n            catch (e) {\n                return { top: 0, bottom: 0, left: 0, right: 0, width: 0, height: 0 };\n            }\n        };\n        BrowserDomAdapter.prototype.getTitle = function () { return document.title; };\n        BrowserDomAdapter.prototype.setTitle = function (newTitle) { document.title = newTitle || ''; };\n        BrowserDomAdapter.prototype.elementMatches = function (n /** TODO #9100 */, selector) {\n            var matches = false;\n            if (n instanceof HTMLElement) {\n                if (n.matches) {\n                    matches = n.matches(selector);\n                }\n                else if (n.msMatchesSelector) {\n                    matches = n.msMatchesSelector(selector);\n                }\n                else if (n.webkitMatchesSelector) {\n                    matches = n.webkitMatchesSelector(selector);\n                }\n            }\n            return matches;\n        };\n        BrowserDomAdapter.prototype.isTemplateElement = function (el) {\n            return el instanceof HTMLElement && el.nodeName == 'TEMPLATE';\n        };\n        BrowserDomAdapter.prototype.isTextNode = function (node) { return node.nodeType === Node.TEXT_NODE; };\n        BrowserDomAdapter.prototype.isCommentNode = function (node) { return node.nodeType === Node.COMMENT_NODE; };\n        BrowserDomAdapter.prototype.isElementNode = function (node) { return node.nodeType === Node.ELEMENT_NODE; };\n        BrowserDomAdapter.prototype.hasShadowRoot = function (node /** TODO #9100 */) {\n            return isPresent(node.shadowRoot) && node instanceof HTMLElement;\n        };\n        BrowserDomAdapter.prototype.isShadowRoot = function (node /** TODO #9100 */) { return node instanceof DocumentFragment; };\n        BrowserDomAdapter.prototype.importIntoDoc = function (node) {\n            var toImport = node;\n            if (this.isTemplateElement(node)) {\n                toImport = this.content(node);\n            }\n            return document.importNode(toImport, true);\n        };\n        BrowserDomAdapter.prototype.adoptNode = function (node) { return document.adoptNode(node); };\n        BrowserDomAdapter.prototype.getHref = function (el) { return el.href; };\n        BrowserDomAdapter.prototype.getEventKey = function (event /** TODO #9100 */) {\n            var key = event.key;\n            if (isBlank(key)) {\n                key = event.keyIdentifier;\n                // keyIdentifier is defined in the old draft of DOM Level 3 Events implemented by Chrome and\n                // Safari\n                // cf\n                // http://www.w3.org/TR/2007/WD-DOM-Level-3-Events-20071221/events.html#Events-KeyboardEvents-Interfaces\n                if (isBlank(key)) {\n                    return 'Unidentified';\n                }\n                if (key.startsWith('U+')) {\n                    key = String.fromCharCode(parseInt(key.substring(2), 16));\n                    if (event.location === DOM_KEY_LOCATION_NUMPAD && _chromeNumKeyPadMap.hasOwnProperty(key)) {\n                        // There is a bug in Chrome for numeric keypad keys:\n                        // https://code.google.com/p/chromium/issues/detail?id=155654\n                        // 1, 2, 3 ... are reported as A, B, C ...\n                        key = _chromeNumKeyPadMap[key];\n                    }\n                }\n            }\n            if (_keyMap.hasOwnProperty(key)) {\n                key = _keyMap[key];\n            }\n            return key;\n        };\n        BrowserDomAdapter.prototype.getGlobalEventTarget = function (target) {\n            if (target == 'window') {\n                return window;\n            }\n            else if (target == 'document') {\n                return document;\n            }\n            else if (target == 'body') {\n                return document.body;\n            }\n        };\n        BrowserDomAdapter.prototype.getHistory = function () { return window.history; };\n        BrowserDomAdapter.prototype.getLocation = function () { return window.location; };\n        BrowserDomAdapter.prototype.getBaseHref = function () {\n            var href = getBaseElementHref();\n            if (isBlank(href)) {\n                return null;\n            }\n            return relativePath(href);\n        };\n        BrowserDomAdapter.prototype.resetBaseElement = function () { baseElement = null; };\n        BrowserDomAdapter.prototype.getUserAgent = function () { return window.navigator.userAgent; };\n        BrowserDomAdapter.prototype.setData = function (element /** TODO #9100 */, name, value) {\n            this.setAttribute(element, 'data-' + name, value);\n        };\n        BrowserDomAdapter.prototype.getData = function (element /** TODO #9100 */, name) {\n            return this.getAttribute(element, 'data-' + name);\n        };\n        BrowserDomAdapter.prototype.getComputedStyle = function (element /** TODO #9100 */) { return getComputedStyle(element); };\n        // TODO(tbosch): move this into a separate environment class once we have it\n        BrowserDomAdapter.prototype.setGlobalVar = function (path, value) { setValueOnPath(global$1, path, value); };\n        BrowserDomAdapter.prototype.supportsWebAnimation = function () { return isFunction(Element.prototype['animate']); };\n        BrowserDomAdapter.prototype.performanceNow = function () {\n            // performance.now() is not available in all browsers, see\n            // http://caniuse.com/#search=performance.now\n            if (isPresent(window.performance) && isPresent(window.performance.now)) {\n                return window.performance.now();\n            }\n            else {\n                return DateWrapper.toMillis(DateWrapper.now());\n            }\n        };\n        BrowserDomAdapter.prototype.supportsCookies = function () { return true; };\n        BrowserDomAdapter.prototype.getCookie = function (name) { return parseCookieValue(document.cookie, name); };\n        BrowserDomAdapter.prototype.setCookie = function (name, value) {\n            // document.cookie is magical, assigning into it assigns/overrides one cookie value, but does\n            // not clear other cookies.\n            document.cookie = encodeURIComponent(name) + '=' + encodeURIComponent(value);\n        };\n        return BrowserDomAdapter;\n    }(GenericBrowserDomAdapter));\n    var baseElement = null;\n    function getBaseElementHref() {\n        if (isBlank(baseElement)) {\n            baseElement = document.querySelector('base');\n            if (isBlank(baseElement)) {\n                return null;\n            }\n        }\n        return baseElement.getAttribute('href');\n    }\n    // based on urlUtils.js in AngularJS 1\n    var urlParsingNode = null;\n    function relativePath(url /** TODO #9100 */) {\n        if (isBlank(urlParsingNode)) {\n            urlParsingNode = document.createElement('a');\n        }\n        urlParsingNode.setAttribute('href', url);\n        return (urlParsingNode.pathname.charAt(0) === '/') ? urlParsingNode.pathname :\n            '/' + urlParsingNode.pathname;\n    }\n    function parseCookieValue(cookieStr, name) {\n        name = encodeURIComponent(name);\n        for (var _i = 0, _a = cookieStr.split(';'); _i < _a.length; _i++) {\n            var cookie = _a[_i];\n            var eqIndex = cookie.indexOf('=');\n            var _b = eqIndex == -1 ? [cookie, ''] : [cookie.slice(0, eqIndex), cookie.slice(eqIndex + 1)], cookieName = _b[0], cookieValue = _b[1];\n            if (cookieName.trim() === name) {\n                return decodeURIComponent(cookieValue);\n            }\n        }\n        return null;\n    }\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    function supportsState() {\n        return !!window.history.pushState;\n    }\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$2 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    /**\n     * `PlatformLocation` encapsulates all of the direct calls to platform APIs.\n     * This class should not be used directly by an application developer. Instead, use\n     * {@link Location}.\n     */\n    var BrowserPlatformLocation = (function (_super) {\n        __extends$2(BrowserPlatformLocation, _super);\n        function BrowserPlatformLocation() {\n            _super.call(this);\n            this._init();\n        }\n        // This is moved to its own method so that `MockPlatformLocationStrategy` can overwrite it\n        /** @internal */\n        BrowserPlatformLocation.prototype._init = function () {\n            this._location = getDOM().getLocation();\n            this._history = getDOM().getHistory();\n        };\n        Object.defineProperty(BrowserPlatformLocation.prototype, \"location\", {\n            get: function () { return this._location; },\n            enumerable: true,\n            configurable: true\n        });\n        BrowserPlatformLocation.prototype.getBaseHrefFromDOM = function () { return getDOM().getBaseHref(); };\n        BrowserPlatformLocation.prototype.onPopState = function (fn) {\n            getDOM().getGlobalEventTarget('window').addEventListener('popstate', fn, false);\n        };\n        BrowserPlatformLocation.prototype.onHashChange = function (fn) {\n            getDOM().getGlobalEventTarget('window').addEventListener('hashchange', fn, false);\n        };\n        Object.defineProperty(BrowserPlatformLocation.prototype, \"pathname\", {\n            get: function () { return this._location.pathname; },\n            set: function (newPath) { this._location.pathname = newPath; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(BrowserPlatformLocation.prototype, \"search\", {\n            get: function () { return this._location.search; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(BrowserPlatformLocation.prototype, \"hash\", {\n            get: function () { return this._location.hash; },\n            enumerable: true,\n            configurable: true\n        });\n        BrowserPlatformLocation.prototype.pushState = function (state, title, url) {\n            if (supportsState()) {\n                this._history.pushState(state, title, url);\n            }\n            else {\n                this._location.hash = url;\n            }\n        };\n        BrowserPlatformLocation.prototype.replaceState = function (state, title, url) {\n            if (supportsState()) {\n                this._history.replaceState(state, title, url);\n            }\n            else {\n                this._location.hash = url;\n            }\n        };\n        BrowserPlatformLocation.prototype.forward = function () { this._history.forward(); };\n        BrowserPlatformLocation.prototype.back = function () { this._history.back(); };\n        BrowserPlatformLocation.decorators = [\n            { type: _angular_core.Injectable },\n        ];\n        /** @nocollapse */\n        BrowserPlatformLocation.ctorParameters = [];\n        return BrowserPlatformLocation;\n    }(_angular_common.PlatformLocation));\n\n    var BrowserGetTestability = (function () {\n        function BrowserGetTestability() {\n        }\n        BrowserGetTestability.init = function () { _angular_core.setTestabilityGetter(new BrowserGetTestability()); };\n        BrowserGetTestability.prototype.addToWindow = function (registry) {\n            global$1.getAngularTestability = function (elem, findInAncestors) {\n                if (findInAncestors === void 0) { findInAncestors = true; }\n                var testability = registry.findTestabilityInTree(elem, findInAncestors);\n                if (testability == null) {\n                    throw new Error('Could not find testability for element.');\n                }\n                return testability;\n            };\n            global$1.getAllAngularTestabilities = function () { return registry.getAllTestabilities(); };\n            global$1.getAllAngularRootElements = function () { return registry.getAllRootElements(); };\n            var whenAllStable = function (callback /** TODO #9100 */) {\n                var testabilities = global$1.getAllAngularTestabilities();\n                var count = testabilities.length;\n                var didWork = false;\n                var decrement = function (didWork_ /** TODO #9100 */) {\n                    didWork = didWork || didWork_;\n                    count--;\n                    if (count == 0) {\n                        callback(didWork);\n                    }\n                };\n                testabilities.forEach(function (testability /** TODO #9100 */) {\n                    testability.whenStable(decrement);\n                });\n            };\n            if (!global$1['frameworkStabilizers']) {\n                global$1['frameworkStabilizers'] = ListWrapper.createGrowableSize(0);\n            }\n            global$1['frameworkStabilizers'].push(whenAllStable);\n        };\n        BrowserGetTestability.prototype.findTestabilityInTree = function (registry, elem, findInAncestors) {\n            if (elem == null) {\n                return null;\n            }\n            var t = registry.getTestability(elem);\n            if (isPresent(t)) {\n                return t;\n            }\n            else if (!findInAncestors) {\n                return null;\n            }\n            if (getDOM().isShadowRoot(elem)) {\n                return this.findTestabilityInTree(registry, getDOM().getHost(elem), true);\n            }\n            return this.findTestabilityInTree(registry, getDOM().parentElement(elem), true);\n        };\n        return BrowserGetTestability;\n    }());\n\n    /**\n     * A service that can be used to get and set the title of a current HTML document.\n     *\n     * Since an Angular 2 application can't be bootstrapped on the entire HTML document (`<html>` tag)\n     * it is not possible to bind to the `text` property of the `HTMLTitleElement` elements\n     * (representing the `<title>` tag). Instead, this service can be used to set and get the current\n     * title value.\n     *\n     * @experimental\n     */\n    var Title = (function () {\n        function Title() {\n        }\n        /**\n         * Get the title of the current HTML document.\n         * @returns {string}\n         */\n        Title.prototype.getTitle = function () { return getDOM().getTitle(); };\n        /**\n         * Set the title of the current HTML document.\n         * @param newTitle\n         */\n        Title.prototype.setTitle = function (newTitle) { getDOM().setTitle(newTitle); };\n        return Title;\n    }());\n\n    /**\n     * A DI Token representing the main rendering context. In a browser this is the DOM Document.\n     *\n     * Note: Document might not be available in the Application Context when Application and Rendering\n     * Contexts are not the same (e.g. when running the application into a Web Worker).\n     *\n     * @stable\n     */\n    var DOCUMENT = new _angular_core.OpaqueToken('DocumentToken');\n\n    /**\n     * @stable\n     */\n    var EVENT_MANAGER_PLUGINS = new _angular_core.OpaqueToken('EventManagerPlugins');\n    /**\n     * @stable\n     */\n    var EventManager = (function () {\n        function EventManager(plugins, _zone) {\n            var _this = this;\n            this._zone = _zone;\n            plugins.forEach(function (p) { return p.manager = _this; });\n            this._plugins = plugins.slice().reverse();\n        }\n        EventManager.prototype.addEventListener = function (element, eventName, handler) {\n            var plugin = this._findPluginFor(eventName);\n            return plugin.addEventListener(element, eventName, handler);\n        };\n        EventManager.prototype.addGlobalEventListener = function (target, eventName, handler) {\n            var plugin = this._findPluginFor(eventName);\n            return plugin.addGlobalEventListener(target, eventName, handler);\n        };\n        EventManager.prototype.getZone = function () { return this._zone; };\n        /** @internal */\n        EventManager.prototype._findPluginFor = function (eventName) {\n            var plugins = this._plugins;\n            for (var i = 0; i < plugins.length; i++) {\n                var plugin = plugins[i];\n                if (plugin.supports(eventName)) {\n                    return plugin;\n                }\n            }\n            throw new Error(\"No event manager plugin found for event \" + eventName);\n        };\n        EventManager.decorators = [\n            { type: _angular_core.Injectable },\n        ];\n        /** @nocollapse */\n        EventManager.ctorParameters = [\n            { type: Array, decorators: [{ type: _angular_core.Inject, args: [EVENT_MANAGER_PLUGINS,] },] },\n            { type: _angular_core.NgZone, },\n        ];\n        return EventManager;\n    }());\n    var EventManagerPlugin = (function () {\n        function EventManagerPlugin() {\n        }\n        // That is equivalent to having supporting $event.target\n        EventManagerPlugin.prototype.supports = function (eventName) { return false; };\n        EventManagerPlugin.prototype.addEventListener = function (element, eventName, handler) {\n            throw 'not implemented';\n        };\n        EventManagerPlugin.prototype.addGlobalEventListener = function (element, eventName, handler) {\n            throw 'not implemented';\n        };\n        return EventManagerPlugin;\n    }());\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$4 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    var SharedStylesHost = (function () {\n        function SharedStylesHost() {\n            /** @internal */\n            this._styles = [];\n            /** @internal */\n            this._stylesSet = new Set();\n        }\n        SharedStylesHost.prototype.addStyles = function (styles) {\n            var _this = this;\n            var additions = [];\n            styles.forEach(function (style) {\n                if (!_this._stylesSet.has(style)) {\n                    _this._stylesSet.add(style);\n                    _this._styles.push(style);\n                    additions.push(style);\n                }\n            });\n            this.onStylesAdded(additions);\n        };\n        SharedStylesHost.prototype.onStylesAdded = function (additions) { };\n        SharedStylesHost.prototype.getAllStyles = function () { return this._styles; };\n        SharedStylesHost.decorators = [\n            { type: _angular_core.Injectable },\n        ];\n        /** @nocollapse */\n        SharedStylesHost.ctorParameters = [];\n        return SharedStylesHost;\n    }());\n    var DomSharedStylesHost = (function (_super) {\n        __extends$4(DomSharedStylesHost, _super);\n        function DomSharedStylesHost(doc) {\n            _super.call(this);\n            this._hostNodes = new Set();\n            this._hostNodes.add(doc.head);\n        }\n        /** @internal */\n        DomSharedStylesHost.prototype._addStylesToHost = function (styles, host) {\n            for (var i = 0; i < styles.length; i++) {\n                var style = styles[i];\n                getDOM().appendChild(host, getDOM().createStyleElement(style));\n            }\n        };\n        DomSharedStylesHost.prototype.addHost = function (hostNode) {\n            this._addStylesToHost(this._styles, hostNode);\n            this._hostNodes.add(hostNode);\n        };\n        DomSharedStylesHost.prototype.removeHost = function (hostNode) { this._hostNodes.delete(hostNode); };\n        DomSharedStylesHost.prototype.onStylesAdded = function (additions) {\n            var _this = this;\n            this._hostNodes.forEach(function (hostNode) { _this._addStylesToHost(additions, hostNode); });\n        };\n        DomSharedStylesHost.decorators = [\n            { type: _angular_core.Injectable },\n        ];\n        /** @nocollapse */\n        DomSharedStylesHost.ctorParameters = [\n            { type: undefined, decorators: [{ type: _angular_core.Inject, args: [DOCUMENT,] },] },\n        ];\n        return DomSharedStylesHost;\n    }(SharedStylesHost));\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$3 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    var NAMESPACE_URIS = {\n        'xlink': 'http://www.w3.org/1999/xlink',\n        'svg': 'http://www.w3.org/2000/svg',\n        'xhtml': 'http://www.w3.org/1999/xhtml'\n    };\n    var TEMPLATE_COMMENT_TEXT = 'template bindings={}';\n    var TEMPLATE_BINDINGS_EXP = /^template bindings=(.*)$/;\n    var DomRootRenderer = (function () {\n        function DomRootRenderer(document, eventManager, sharedStylesHost, animationDriver) {\n            this.document = document;\n            this.eventManager = eventManager;\n            this.sharedStylesHost = sharedStylesHost;\n            this.animationDriver = animationDriver;\n            this.registeredComponents = new Map();\n        }\n        DomRootRenderer.prototype.renderComponent = function (componentProto) {\n            var renderer = this.registeredComponents.get(componentProto.id);\n            if (isBlank(renderer)) {\n                renderer = new DomRenderer(this, componentProto, this.animationDriver);\n                this.registeredComponents.set(componentProto.id, renderer);\n            }\n            return renderer;\n        };\n        return DomRootRenderer;\n    }());\n    var DomRootRenderer_ = (function (_super) {\n        __extends$3(DomRootRenderer_, _super);\n        function DomRootRenderer_(_document, _eventManager, sharedStylesHost, animationDriver) {\n            _super.call(this, _document, _eventManager, sharedStylesHost, animationDriver);\n        }\n        DomRootRenderer_.decorators = [\n            { type: _angular_core.Injectable },\n        ];\n        /** @nocollapse */\n        DomRootRenderer_.ctorParameters = [\n            { type: undefined, decorators: [{ type: _angular_core.Inject, args: [DOCUMENT,] },] },\n            { type: EventManager, },\n            { type: DomSharedStylesHost, },\n            { type: AnimationDriver, },\n        ];\n        return DomRootRenderer_;\n    }(DomRootRenderer));\n    var DomRenderer = (function () {\n        function DomRenderer(_rootRenderer, componentProto, _animationDriver) {\n            this._rootRenderer = _rootRenderer;\n            this.componentProto = componentProto;\n            this._animationDriver = _animationDriver;\n            this._styles = _flattenStyles(componentProto.id, componentProto.styles, []);\n            if (componentProto.encapsulation !== _angular_core.ViewEncapsulation.Native) {\n                this._rootRenderer.sharedStylesHost.addStyles(this._styles);\n            }\n            if (this.componentProto.encapsulation === _angular_core.ViewEncapsulation.Emulated) {\n                this._contentAttr = _shimContentAttribute(componentProto.id);\n                this._hostAttr = _shimHostAttribute(componentProto.id);\n            }\n            else {\n                this._contentAttr = null;\n                this._hostAttr = null;\n            }\n        }\n        DomRenderer.prototype.selectRootElement = function (selectorOrNode, debugInfo) {\n            var el;\n            if (isString(selectorOrNode)) {\n                el = getDOM().querySelector(this._rootRenderer.document, selectorOrNode);\n                if (isBlank(el)) {\n                    throw new Error(\"The selector \\\"\" + selectorOrNode + \"\\\" did not match any elements\");\n                }\n            }\n            else {\n                el = selectorOrNode;\n            }\n            getDOM().clearNodes(el);\n            return el;\n        };\n        DomRenderer.prototype.createElement = function (parent, name, debugInfo) {\n            var nsAndName = splitNamespace(name);\n            var el = isPresent(nsAndName[0]) ?\n                getDOM().createElementNS(NAMESPACE_URIS[nsAndName[0]], nsAndName[1]) :\n                getDOM().createElement(nsAndName[1]);\n            if (isPresent(this._contentAttr)) {\n                getDOM().setAttribute(el, this._contentAttr, '');\n            }\n            if (isPresent(parent)) {\n                getDOM().appendChild(parent, el);\n            }\n            return el;\n        };\n        DomRenderer.prototype.createViewRoot = function (hostElement) {\n            var nodesParent;\n            if (this.componentProto.encapsulation === _angular_core.ViewEncapsulation.Native) {\n                nodesParent = getDOM().createShadowRoot(hostElement);\n                this._rootRenderer.sharedStylesHost.addHost(nodesParent);\n                for (var i = 0; i < this._styles.length; i++) {\n                    getDOM().appendChild(nodesParent, getDOM().createStyleElement(this._styles[i]));\n                }\n            }\n            else {\n                if (isPresent(this._hostAttr)) {\n                    getDOM().setAttribute(hostElement, this._hostAttr, '');\n                }\n                nodesParent = hostElement;\n            }\n            return nodesParent;\n        };\n        DomRenderer.prototype.createTemplateAnchor = function (parentElement, debugInfo) {\n            var comment = getDOM().createComment(TEMPLATE_COMMENT_TEXT);\n            if (isPresent(parentElement)) {\n                getDOM().appendChild(parentElement, comment);\n            }\n            return comment;\n        };\n        DomRenderer.prototype.createText = function (parentElement, value, debugInfo) {\n            var node = getDOM().createTextNode(value);\n            if (isPresent(parentElement)) {\n                getDOM().appendChild(parentElement, node);\n            }\n            return node;\n        };\n        DomRenderer.prototype.projectNodes = function (parentElement, nodes) {\n            if (isBlank(parentElement))\n                return;\n            appendNodes(parentElement, nodes);\n        };\n        DomRenderer.prototype.attachViewAfter = function (node, viewRootNodes) { moveNodesAfterSibling(node, viewRootNodes); };\n        DomRenderer.prototype.detachView = function (viewRootNodes) {\n            for (var i = 0; i < viewRootNodes.length; i++) {\n                getDOM().remove(viewRootNodes[i]);\n            }\n        };\n        DomRenderer.prototype.destroyView = function (hostElement, viewAllNodes) {\n            if (this.componentProto.encapsulation === _angular_core.ViewEncapsulation.Native && isPresent(hostElement)) {\n                this._rootRenderer.sharedStylesHost.removeHost(getDOM().getShadowRoot(hostElement));\n            }\n        };\n        DomRenderer.prototype.listen = function (renderElement, name, callback) {\n            return this._rootRenderer.eventManager.addEventListener(renderElement, name, decoratePreventDefault(callback));\n        };\n        DomRenderer.prototype.listenGlobal = function (target, name, callback) {\n            return this._rootRenderer.eventManager.addGlobalEventListener(target, name, decoratePreventDefault(callback));\n        };\n        DomRenderer.prototype.setElementProperty = function (renderElement, propertyName, propertyValue) {\n            getDOM().setProperty(renderElement, propertyName, propertyValue);\n        };\n        DomRenderer.prototype.setElementAttribute = function (renderElement, attributeName, attributeValue) {\n            var attrNs;\n            var nsAndName = splitNamespace(attributeName);\n            if (isPresent(nsAndName[0])) {\n                attributeName = nsAndName[0] + ':' + nsAndName[1];\n                attrNs = NAMESPACE_URIS[nsAndName[0]];\n            }\n            if (isPresent(attributeValue)) {\n                if (isPresent(attrNs)) {\n                    getDOM().setAttributeNS(renderElement, attrNs, attributeName, attributeValue);\n                }\n                else {\n                    getDOM().setAttribute(renderElement, attributeName, attributeValue);\n                }\n            }\n            else {\n                if (isPresent(attrNs)) {\n                    getDOM().removeAttributeNS(renderElement, attrNs, nsAndName[1]);\n                }\n                else {\n                    getDOM().removeAttribute(renderElement, attributeName);\n                }\n            }\n        };\n        DomRenderer.prototype.setBindingDebugInfo = function (renderElement, propertyName, propertyValue) {\n            var dashCasedPropertyName = camelCaseToDashCase(propertyName);\n            if (getDOM().isCommentNode(renderElement)) {\n                var existingBindings = StringWrapper.replaceAll(getDOM().getText(renderElement), /\\n/g, '')\n                    .match(TEMPLATE_BINDINGS_EXP);\n                var parsedBindings = Json.parse(existingBindings[1]);\n                parsedBindings[dashCasedPropertyName] = propertyValue;\n                getDOM().setText(renderElement, StringWrapper.replace(TEMPLATE_COMMENT_TEXT, '{}', Json.stringify(parsedBindings)));\n            }\n            else {\n                this.setElementAttribute(renderElement, propertyName, propertyValue);\n            }\n        };\n        DomRenderer.prototype.setElementClass = function (renderElement, className, isAdd) {\n            if (isAdd) {\n                getDOM().addClass(renderElement, className);\n            }\n            else {\n                getDOM().removeClass(renderElement, className);\n            }\n        };\n        DomRenderer.prototype.setElementStyle = function (renderElement, styleName, styleValue) {\n            if (isPresent(styleValue)) {\n                getDOM().setStyle(renderElement, styleName, stringify(styleValue));\n            }\n            else {\n                getDOM().removeStyle(renderElement, styleName);\n            }\n        };\n        DomRenderer.prototype.invokeElementMethod = function (renderElement, methodName, args) {\n            getDOM().invoke(renderElement, methodName, args);\n        };\n        DomRenderer.prototype.setText = function (renderNode, text) { getDOM().setText(renderNode, text); };\n        DomRenderer.prototype.animate = function (element, startingStyles, keyframes, duration, delay, easing) {\n            return this._animationDriver.animate(element, startingStyles, keyframes, duration, delay, easing);\n        };\n        return DomRenderer;\n    }());\n    function moveNodesAfterSibling(sibling /** TODO #9100 */, nodes /** TODO #9100 */) {\n        var parent = getDOM().parentElement(sibling);\n        if (nodes.length > 0 && isPresent(parent)) {\n            var nextSibling = getDOM().nextSibling(sibling);\n            if (isPresent(nextSibling)) {\n                for (var i = 0; i < nodes.length; i++) {\n                    getDOM().insertBefore(nextSibling, nodes[i]);\n                }\n            }\n            else {\n                for (var i = 0; i < nodes.length; i++) {\n                    getDOM().appendChild(parent, nodes[i]);\n                }\n            }\n        }\n    }\n    function appendNodes(parent /** TODO #9100 */, nodes /** TODO #9100 */) {\n        for (var i = 0; i < nodes.length; i++) {\n            getDOM().appendChild(parent, nodes[i]);\n        }\n    }\n    function decoratePreventDefault(eventHandler) {\n        return function (event /** TODO #9100 */) {\n            var allowDefaultBehavior = eventHandler(event);\n            if (allowDefaultBehavior === false) {\n                // TODO(tbosch): move preventDefault into event plugins...\n                getDOM().preventDefault(event);\n            }\n        };\n    }\n    var COMPONENT_REGEX = /%COMP%/g;\n    var COMPONENT_VARIABLE = '%COMP%';\n    var HOST_ATTR = \"_nghost-\" + COMPONENT_VARIABLE;\n    var CONTENT_ATTR = \"_ngcontent-\" + COMPONENT_VARIABLE;\n    function _shimContentAttribute(componentShortId) {\n        return StringWrapper.replaceAll(CONTENT_ATTR, COMPONENT_REGEX, componentShortId);\n    }\n    function _shimHostAttribute(componentShortId) {\n        return StringWrapper.replaceAll(HOST_ATTR, COMPONENT_REGEX, componentShortId);\n    }\n    function _flattenStyles(compId, styles, target) {\n        for (var i = 0; i < styles.length; i++) {\n            var style = styles[i];\n            if (isArray(style)) {\n                _flattenStyles(compId, style, target);\n            }\n            else {\n                style = StringWrapper.replaceAll(style, COMPONENT_REGEX, compId);\n                target.push(style);\n            }\n        }\n        return target;\n    }\n    var NS_PREFIX_RE = /^:([^:]+):(.+)$/;\n    function splitNamespace(name) {\n        if (name[0] != ':') {\n            return [null, name];\n        }\n        var match = name.match(NS_PREFIX_RE);\n        return [match[1], match[2]];\n    }\n\n    var CORE_TOKENS = {\n        'ApplicationRef': _angular_core.ApplicationRef,\n        'NgZone': _angular_core.NgZone\n    };\n    var INSPECT_GLOBAL_NAME = 'ng.probe';\n    var CORE_TOKENS_GLOBAL_NAME = 'ng.coreTokens';\n    /**\n     * Returns a {@link DebugElement} for the given native DOM element, or\n     * null if the given native element does not have an Angular view associated\n     * with it.\n     */\n    function inspectNativeElement(element /** TODO #9100 */) {\n        return _angular_core.getDebugNode(element);\n    }\n    /**\n     * @experimental\n     */\n    var NgProbeToken = (function () {\n        function NgProbeToken(name, token) {\n            this.name = name;\n            this.token = token;\n        }\n        return NgProbeToken;\n    }());\n    function _createConditionalRootRenderer(rootRenderer /** TODO #9100 */, extraTokens) {\n        if (_angular_core.isDevMode()) {\n            return _createRootRenderer(rootRenderer, extraTokens);\n        }\n        return rootRenderer;\n    }\n    function _createRootRenderer(rootRenderer /** TODO #9100 */, extraTokens) {\n        getDOM().setGlobalVar(INSPECT_GLOBAL_NAME, inspectNativeElement);\n        getDOM().setGlobalVar(CORE_TOKENS_GLOBAL_NAME, StringMapWrapper.merge(CORE_TOKENS, _ngProbeTokensToMap(extraTokens || [])));\n        return new DebugDomRootRenderer(rootRenderer);\n    }\n    function _ngProbeTokensToMap(tokens) {\n        return tokens.reduce(function (prev, t) { return (prev[t.name] = t.token, prev); }, {});\n    }\n    /**\n     * Providers which support debugging Angular applications (e.g. via `ng.probe`).\n     */\n    var ELEMENT_PROBE_PROVIDERS = [{\n            provide: _angular_core.RootRenderer,\n            useFactory: _createConditionalRootRenderer,\n            deps: [DomRootRenderer, [NgProbeToken, new _angular_core.Optional()]]\n        }];\n    var ELEMENT_PROBE_PROVIDERS_PROD_MODE = [{\n            provide: _angular_core.RootRenderer,\n            useFactory: _createRootRenderer,\n            deps: [DomRootRenderer, [NgProbeToken, new _angular_core.Optional()]]\n        }];\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$5 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    var DomEventsPlugin = (function (_super) {\n        __extends$5(DomEventsPlugin, _super);\n        function DomEventsPlugin() {\n            _super.apply(this, arguments);\n        }\n        // This plugin should come last in the list of plugins, because it accepts all\n        // events.\n        DomEventsPlugin.prototype.supports = function (eventName) { return true; };\n        DomEventsPlugin.prototype.addEventListener = function (element, eventName, handler) {\n            var zone = this.manager.getZone();\n            var outsideHandler = function (event /** TODO #9100 */) { return zone.runGuarded(function () { return handler(event); }); };\n            return this.manager.getZone().runOutsideAngular(function () { return getDOM().onAndCancel(element, eventName, outsideHandler); });\n        };\n        DomEventsPlugin.prototype.addGlobalEventListener = function (target, eventName, handler) {\n            var element = getDOM().getGlobalEventTarget(target);\n            var zone = this.manager.getZone();\n            var outsideHandler = function (event /** TODO #9100 */) { return zone.runGuarded(function () { return handler(event); }); };\n            return this.manager.getZone().runOutsideAngular(function () { return getDOM().onAndCancel(element, eventName, outsideHandler); });\n        };\n        DomEventsPlugin.decorators = [\n            { type: _angular_core.Injectable },\n        ];\n        /** @nocollapse */\n        DomEventsPlugin.ctorParameters = [];\n        return DomEventsPlugin;\n    }(EventManagerPlugin));\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$7 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    var _eventNames = {\n        // pan\n        'pan': true,\n        'panstart': true,\n        'panmove': true,\n        'panend': true,\n        'pancancel': true,\n        'panleft': true,\n        'panright': true,\n        'panup': true,\n        'pandown': true,\n        // pinch\n        'pinch': true,\n        'pinchstart': true,\n        'pinchmove': true,\n        'pinchend': true,\n        'pinchcancel': true,\n        'pinchin': true,\n        'pinchout': true,\n        // press\n        'press': true,\n        'pressup': true,\n        // rotate\n        'rotate': true,\n        'rotatestart': true,\n        'rotatemove': true,\n        'rotateend': true,\n        'rotatecancel': true,\n        // swipe\n        'swipe': true,\n        'swipeleft': true,\n        'swiperight': true,\n        'swipeup': true,\n        'swipedown': true,\n        // tap\n        'tap': true,\n    };\n    var HammerGesturesPluginCommon = (function (_super) {\n        __extends$7(HammerGesturesPluginCommon, _super);\n        function HammerGesturesPluginCommon() {\n            _super.call(this);\n        }\n        HammerGesturesPluginCommon.prototype.supports = function (eventName) {\n            return _eventNames.hasOwnProperty(eventName.toLowerCase());\n        };\n        return HammerGesturesPluginCommon;\n    }(EventManagerPlugin));\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$6 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    /**\n     * A DI token that you can use to provide{@link HammerGestureConfig} to Angular. Use it to configure\n     * Hammer gestures.\n     *\n     * @experimental\n     */\n    var HAMMER_GESTURE_CONFIG = new _angular_core.OpaqueToken('HammerGestureConfig');\n    /**\n     * @experimental\n     */\n    var HammerGestureConfig = (function () {\n        function HammerGestureConfig() {\n            this.events = [];\n            this.overrides = {};\n        }\n        HammerGestureConfig.prototype.buildHammer = function (element) {\n            var mc = new Hammer(element);\n            mc.get('pinch').set({ enable: true });\n            mc.get('rotate').set({ enable: true });\n            for (var eventName in this.overrides) {\n                mc.get(eventName).set(this.overrides[eventName]);\n            }\n            return mc;\n        };\n        HammerGestureConfig.decorators = [\n            { type: _angular_core.Injectable },\n        ];\n        /** @nocollapse */\n        HammerGestureConfig.ctorParameters = [];\n        return HammerGestureConfig;\n    }());\n    var HammerGesturesPlugin = (function (_super) {\n        __extends$6(HammerGesturesPlugin, _super);\n        function HammerGesturesPlugin(_config) {\n            _super.call(this);\n            this._config = _config;\n        }\n        HammerGesturesPlugin.prototype.supports = function (eventName) {\n            if (!_super.prototype.supports.call(this, eventName) && !this.isCustomEvent(eventName))\n                return false;\n            if (!isPresent(window['Hammer'])) {\n                throw new Error(\"Hammer.js is not loaded, can not bind \" + eventName + \" event\");\n            }\n            return true;\n        };\n        HammerGesturesPlugin.prototype.addEventListener = function (element, eventName, handler) {\n            var _this = this;\n            var zone = this.manager.getZone();\n            eventName = eventName.toLowerCase();\n            return zone.runOutsideAngular(function () {\n                // Creating the manager bind events, must be done outside of angular\n                var mc = _this._config.buildHammer(element);\n                var callback = function (eventObj /** TODO #???? */) {\n                    zone.runGuarded(function () { handler(eventObj); });\n                };\n                mc.on(eventName, callback);\n                return function () { mc.off(eventName, callback); };\n            });\n        };\n        HammerGesturesPlugin.prototype.isCustomEvent = function (eventName) { return this._config.events.indexOf(eventName) > -1; };\n        HammerGesturesPlugin.decorators = [\n            { type: _angular_core.Injectable },\n        ];\n        /** @nocollapse */\n        HammerGesturesPlugin.ctorParameters = [\n            { type: HammerGestureConfig, decorators: [{ type: _angular_core.Inject, args: [HAMMER_GESTURE_CONFIG,] },] },\n        ];\n        return HammerGesturesPlugin;\n    }(HammerGesturesPluginCommon));\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$8 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    var modifierKeys = ['alt', 'control', 'meta', 'shift'];\n    var modifierKeyGetters = {\n        'alt': function (event) { return event.altKey; },\n        'control': function (event) { return event.ctrlKey; },\n        'meta': function (event) { return event.metaKey; },\n        'shift': function (event) { return event.shiftKey; }\n    };\n    /**\n     * @experimental\n     */\n    var KeyEventsPlugin = (function (_super) {\n        __extends$8(KeyEventsPlugin, _super);\n        function KeyEventsPlugin() {\n            _super.call(this);\n        }\n        KeyEventsPlugin.prototype.supports = function (eventName) {\n            return isPresent(KeyEventsPlugin.parseEventName(eventName));\n        };\n        KeyEventsPlugin.prototype.addEventListener = function (element, eventName, handler) {\n            var parsedEvent = KeyEventsPlugin.parseEventName(eventName);\n            var outsideHandler = KeyEventsPlugin.eventCallback(element, StringMapWrapper.get(parsedEvent, 'fullKey'), handler, this.manager.getZone());\n            return this.manager.getZone().runOutsideAngular(function () {\n                return getDOM().onAndCancel(element, StringMapWrapper.get(parsedEvent, 'domEventName'), outsideHandler);\n            });\n        };\n        KeyEventsPlugin.parseEventName = function (eventName) {\n            var parts = eventName.toLowerCase().split('.');\n            var domEventName = parts.shift();\n            if ((parts.length === 0) ||\n                !(StringWrapper.equals(domEventName, 'keydown') ||\n                    StringWrapper.equals(domEventName, 'keyup'))) {\n                return null;\n            }\n            var key = KeyEventsPlugin._normalizeKey(parts.pop());\n            var fullKey = '';\n            modifierKeys.forEach(function (modifierName) {\n                if (ListWrapper.contains(parts, modifierName)) {\n                    ListWrapper.remove(parts, modifierName);\n                    fullKey += modifierName + '.';\n                }\n            });\n            fullKey += key;\n            if (parts.length != 0 || key.length === 0) {\n                // returning null instead of throwing to let another plugin process the event\n                return null;\n            }\n            var result = {};\n            StringMapWrapper.set(result, 'domEventName', domEventName);\n            StringMapWrapper.set(result, 'fullKey', fullKey);\n            return result;\n        };\n        KeyEventsPlugin.getEventFullKey = function (event) {\n            var fullKey = '';\n            var key = getDOM().getEventKey(event);\n            key = key.toLowerCase();\n            if (StringWrapper.equals(key, ' ')) {\n                key = 'space'; // for readability\n            }\n            else if (StringWrapper.equals(key, '.')) {\n                key = 'dot'; // because '.' is used as a separator in event names\n            }\n            modifierKeys.forEach(function (modifierName) {\n                if (modifierName != key) {\n                    var modifierGetter = StringMapWrapper.get(modifierKeyGetters, modifierName);\n                    if (modifierGetter(event)) {\n                        fullKey += modifierName + '.';\n                    }\n                }\n            });\n            fullKey += key;\n            return fullKey;\n        };\n        KeyEventsPlugin.eventCallback = function (element, fullKey, handler, zone) {\n            return function (event /** TODO #9100 */) {\n                if (StringWrapper.equals(KeyEventsPlugin.getEventFullKey(event), fullKey)) {\n                    zone.runGuarded(function () { return handler(event); });\n                }\n            };\n        };\n        /** @internal */\n        KeyEventsPlugin._normalizeKey = function (keyName) {\n            // TODO: switch to a StringMap if the mapping grows too much\n            switch (keyName) {\n                case 'esc':\n                    return 'escape';\n                default:\n                    return keyName;\n            }\n        };\n        KeyEventsPlugin.decorators = [\n            { type: _angular_core.Injectable },\n        ];\n        /** @nocollapse */\n        KeyEventsPlugin.ctorParameters = [];\n        return KeyEventsPlugin;\n    }(EventManagerPlugin));\n\n    /**\n     * A pattern that recognizes a commonly useful subset of URLs that are safe.\n     *\n     * This regular expression matches a subset of URLs that will not cause script\n     * execution if used in URL context within a HTML document. Specifically, this\n     * regular expression matches if (comment from here on and regex copied from\n     * Soy's EscapingConventions):\n     * (1) Either a protocol in a whitelist (http, https, mailto or ftp).\n     * (2) or no protocol.  A protocol must be followed by a colon. The below\n     *     allows that by allowing colons only after one of the characters [/?#].\n     *     A colon after a hash (#) must be in the fragment.\n     *     Otherwise, a colon after a (?) must be in a query.\n     *     Otherwise, a colon after a single solidus (/) must be in a path.\n     *     Otherwise, a colon after a double solidus (//) must be in the authority\n     *     (before port).\n     *\n     * The pattern disallows &, used in HTML entity declarations before\n     * one of the characters in [/?#]. This disallows HTML entities used in the\n     * protocol name, which should never happen, e.g. \"h&#116;tp\" for \"http\".\n     * It also disallows HTML entities in the first path part of a relative path,\n     * e.g. \"foo&lt;bar/baz\".  Our existing escaping functions should not produce\n     * that. More importantly, it disallows masking of a colon,\n     * e.g. \"javascript&#58;...\".\n     *\n     * This regular expression was taken from the Closure sanitization library.\n     */\n    var SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file):|[^&:/?#]*(?:[/?#]|$))/gi;\n    /** A pattern that matches safe data URLs. Only matches image, video and audio types. */\n    var DATA_URL_PATTERN = /^data:(?:image\\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\\/(?:mpeg|mp4|ogg|webm)|audio\\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+\\/]+=*$/i;\n    function sanitizeUrl(url) {\n        url = String(url);\n        if (url.match(SAFE_URL_PATTERN) || url.match(DATA_URL_PATTERN))\n            return url;\n        if (_angular_core.isDevMode()) {\n            getDOM().log(\"WARNING: sanitizing unsafe URL value \" + url + \" (see http://g.co/ng/security#xss)\");\n        }\n        return 'unsafe:' + url;\n    }\n    function sanitizeSrcset(srcset) {\n        srcset = String(srcset);\n        return srcset.split(',').map(function (srcset) { return sanitizeUrl(srcset.trim()); }).join(', ');\n    }\n\n    /** A <body> element that can be safely used to parse untrusted HTML. Lazily initialized below. */\n    var inertElement = null;\n    /** Lazily initialized to make sure the DOM adapter gets set before use. */\n    var DOM = null;\n    /** Returns an HTML element that is guaranteed to not execute code when creating elements in it. */\n    function getInertElement() {\n        if (inertElement)\n            return inertElement;\n        DOM = getDOM();\n        // Prefer using <template> element if supported.\n        var templateEl = DOM.createElement('template');\n        if ('content' in templateEl)\n            return templateEl;\n        var doc = DOM.createHtmlDocument();\n        inertElement = DOM.querySelector(doc, 'body');\n        if (inertElement == null) {\n            // usually there should be only one body element in the document, but IE doesn't have any, so we\n            // need to create one.\n            var html = DOM.createElement('html', doc);\n            inertElement = DOM.createElement('body', doc);\n            DOM.appendChild(html, inertElement);\n            DOM.appendChild(doc, html);\n        }\n        return inertElement;\n    }\n    function tagSet(tags) {\n        var res = {};\n        for (var _i = 0, _a = tags.split(','); _i < _a.length; _i++) {\n            var t = _a[_i];\n            res[t] = true;\n        }\n        return res;\n    }\n    function merge() {\n        var sets = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            sets[_i - 0] = arguments[_i];\n        }\n        var res = {};\n        for (var _a = 0, sets_1 = sets; _a < sets_1.length; _a++) {\n            var s = sets_1[_a];\n            for (var v in s) {\n                if (s.hasOwnProperty(v))\n                    res[v] = true;\n            }\n        }\n        return res;\n    }\n    // Good source of info about elements and attributes\n    // http://dev.w3.org/html5/spec/Overview.html#semantics\n    // http://simon.html5.org/html-elements\n    // Safe Void Elements - HTML5\n    // http://dev.w3.org/html5/spec/Overview.html#void-elements\n    var VOID_ELEMENTS = tagSet('area,br,col,hr,img,wbr');\n    // Elements that you can, intentionally, leave open (and which close themselves)\n    // http://dev.w3.org/html5/spec/Overview.html#optional-tags\n    var OPTIONAL_END_TAG_BLOCK_ELEMENTS = tagSet('colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr');\n    var OPTIONAL_END_TAG_INLINE_ELEMENTS = tagSet('rp,rt');\n    var OPTIONAL_END_TAG_ELEMENTS = merge(OPTIONAL_END_TAG_INLINE_ELEMENTS, OPTIONAL_END_TAG_BLOCK_ELEMENTS);\n    // Safe Block Elements - HTML5\n    var BLOCK_ELEMENTS = merge(OPTIONAL_END_TAG_BLOCK_ELEMENTS, tagSet('address,article,' +\n        'aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,' +\n        'h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul'));\n    // Inline Elements - HTML5\n    var INLINE_ELEMENTS = merge(OPTIONAL_END_TAG_INLINE_ELEMENTS, tagSet('a,abbr,acronym,audio,b,' +\n        'bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,' +\n        'samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video'));\n    var VALID_ELEMENTS = merge(VOID_ELEMENTS, BLOCK_ELEMENTS, INLINE_ELEMENTS, OPTIONAL_END_TAG_ELEMENTS);\n    // Attributes that have href and hence need to be sanitized\n    var URI_ATTRS = tagSet('background,cite,href,itemtype,longdesc,poster,src,xlink:href');\n    // Attributes that have special href set hence need to be sanitized\n    var SRCSET_ATTRS = tagSet('srcset');\n    var HTML_ATTRS = tagSet('abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,' +\n        'compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,' +\n        'ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,' +\n        'scope,scrolling,shape,size,sizes,span,srclang,start,summary,tabindex,target,title,translate,type,usemap,' +\n        'valign,value,vspace,width');\n    // NB: This currently conciously doesn't support SVG. SVG sanitization has had several security\n    // issues in the past, so it seems safer to leave it out if possible. If support for binding SVG via\n    // innerHTML is required, SVG attributes should be added here.\n    // NB: Sanitization does not allow <form> elements or other active elements (<button> etc). Those\n    // can be sanitized, but they increase security surface area without a legitimate use case, so they\n    // are left out here.\n    var VALID_ATTRS = merge(URI_ATTRS, SRCSET_ATTRS, HTML_ATTRS);\n    /**\n     * SanitizingHtmlSerializer serializes a DOM fragment, stripping out any unsafe elements and unsafe\n     * attributes.\n     */\n    var SanitizingHtmlSerializer = (function () {\n        function SanitizingHtmlSerializer() {\n            // Explicitly track if something was stripped, to avoid accidentally warning of sanitization just\n            // because characters were re-encoded.\n            this.sanitizedSomething = false;\n            this.buf = [];\n        }\n        SanitizingHtmlSerializer.prototype.sanitizeChildren = function (el) {\n            // This cannot use a TreeWalker, as it has to run on Angular's various DOM adapters.\n            // However this code never accesses properties off of `document` before deleting its contents\n            // again, so it shouldn't be vulnerable to DOM clobbering.\n            var current = el.firstChild;\n            while (current) {\n                if (DOM.isElementNode(current)) {\n                    this.startElement(current);\n                }\n                else if (DOM.isTextNode(current)) {\n                    this.chars(DOM.nodeValue(current));\n                }\n                else {\n                    // Strip non-element, non-text nodes.\n                    this.sanitizedSomething = true;\n                }\n                if (DOM.firstChild(current)) {\n                    current = DOM.firstChild(current);\n                    continue;\n                }\n                while (current) {\n                    // Leaving the element. Walk up and to the right, closing tags as we go.\n                    if (DOM.isElementNode(current)) {\n                        this.endElement(current);\n                    }\n                    if (DOM.nextSibling(current)) {\n                        current = DOM.nextSibling(current);\n                        break;\n                    }\n                    current = DOM.parentElement(current);\n                }\n            }\n            return this.buf.join('');\n        };\n        SanitizingHtmlSerializer.prototype.startElement = function (element) {\n            var _this = this;\n            var tagName = DOM.nodeName(element).toLowerCase();\n            if (!VALID_ELEMENTS.hasOwnProperty(tagName)) {\n                this.sanitizedSomething = true;\n                return;\n            }\n            this.buf.push('<');\n            this.buf.push(tagName);\n            DOM.attributeMap(element).forEach(function (value, attrName) {\n                var lower = attrName.toLowerCase();\n                if (!VALID_ATTRS.hasOwnProperty(lower)) {\n                    _this.sanitizedSomething = true;\n                    return;\n                }\n                // TODO(martinprobst): Special case image URIs for data:image/...\n                if (URI_ATTRS[lower])\n                    value = sanitizeUrl(value);\n                if (SRCSET_ATTRS[lower])\n                    value = sanitizeSrcset(value);\n                _this.buf.push(' ');\n                _this.buf.push(attrName);\n                _this.buf.push('=\"');\n                _this.buf.push(encodeEntities(value));\n                _this.buf.push('\"');\n            });\n            this.buf.push('>');\n        };\n        SanitizingHtmlSerializer.prototype.endElement = function (current) {\n            var tagName = DOM.nodeName(current).toLowerCase();\n            if (VALID_ELEMENTS.hasOwnProperty(tagName) && !VOID_ELEMENTS.hasOwnProperty(tagName)) {\n                this.buf.push('</');\n                this.buf.push(tagName);\n                this.buf.push('>');\n            }\n        };\n        SanitizingHtmlSerializer.prototype.chars = function (chars /** TODO #9100 */) { this.buf.push(encodeEntities(chars)); };\n        return SanitizingHtmlSerializer;\n    }());\n    // Regular Expressions for parsing tags and attributes\n    var SURROGATE_PAIR_REGEXP = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g;\n    // ! to ~ is the ASCII range.\n    var NON_ALPHANUMERIC_REGEXP = /([^\\#-~ |!])/g;\n    /**\n     * Escapes all potentially dangerous characters, so that the\n     * resulting string can be safely inserted into attribute or\n     * element text.\n     * @param value\n     * @returns {string} escaped text\n     */\n    function encodeEntities(value) {\n        return value.replace(/&/g, '&amp;')\n            .replace(SURROGATE_PAIR_REGEXP, function (match) {\n            var hi = match.charCodeAt(0);\n            var low = match.charCodeAt(1);\n            return '&#' + (((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000) + ';';\n        })\n            .replace(NON_ALPHANUMERIC_REGEXP, function (match) { return '&#' + match.charCodeAt(0) + ';'; })\n            .replace(/</g, '&lt;')\n            .replace(/>/g, '&gt;');\n    }\n    /**\n     * When IE9-11 comes across an unknown namespaced attribute e.g. 'xlink:foo' it adds 'xmlns:ns1'\n     * attribute to declare ns1 namespace and prefixes the attribute with 'ns1' (e.g. 'ns1:xlink:foo').\n     *\n     * This is undesirable since we don't want to allow any of these custom attributes. This method\n     * strips them all.\n     */\n    function stripCustomNsAttrs(el) {\n        DOM.attributeMap(el).forEach(function (_, attrName) {\n            if (attrName === 'xmlns:ns1' || attrName.indexOf('ns1:') === 0) {\n                DOM.removeAttribute(el, attrName);\n            }\n        });\n        for (var _i = 0, _a = DOM.childNodesAsList(el); _i < _a.length; _i++) {\n            var n = _a[_i];\n            if (DOM.isElementNode(n))\n                stripCustomNsAttrs(n);\n        }\n    }\n    /**\n     * Sanitizes the given unsafe, untrusted HTML fragment, and returns HTML text that is safe to add to\n     * the DOM in a browser environment.\n     */\n    function sanitizeHtml(unsafeHtmlInput) {\n        try {\n            var containerEl = getInertElement();\n            // Make sure unsafeHtml is actually a string (TypeScript types are not enforced at runtime).\n            var unsafeHtml = unsafeHtmlInput ? String(unsafeHtmlInput) : '';\n            // mXSS protection. Repeatedly parse the document to make sure it stabilizes, so that a browser\n            // trying to auto-correct incorrect HTML cannot cause formerly inert HTML to become dangerous.\n            var mXSSAttempts = 5;\n            var parsedHtml = unsafeHtml;\n            do {\n                if (mXSSAttempts === 0) {\n                    throw new Error('Failed to sanitize html because the input is unstable');\n                }\n                mXSSAttempts--;\n                unsafeHtml = parsedHtml;\n                DOM.setInnerHTML(containerEl, unsafeHtml);\n                if (DOM.defaultDoc().documentMode) {\n                    // strip custom-namespaced attributes on IE<=11\n                    stripCustomNsAttrs(containerEl);\n                }\n                parsedHtml = DOM.getInnerHTML(containerEl);\n            } while (unsafeHtml !== parsedHtml);\n            var sanitizer = new SanitizingHtmlSerializer();\n            var safeHtml = sanitizer.sanitizeChildren(DOM.getTemplateContent(containerEl) || containerEl);\n            // Clear out the body element.\n            var parent_1 = DOM.getTemplateContent(containerEl) || containerEl;\n            for (var _i = 0, _a = DOM.childNodesAsList(parent_1); _i < _a.length; _i++) {\n                var child = _a[_i];\n                DOM.removeChild(parent_1, child);\n            }\n            if (_angular_core.isDevMode() && sanitizer.sanitizedSomething) {\n                DOM.log('WARNING: sanitizing HTML stripped some content (see http://g.co/ng/security#xss).');\n            }\n            return safeHtml;\n        }\n        catch (e) {\n            // In case anything goes wrong, clear out inertElement to reset the entire DOM structure.\n            inertElement = null;\n            throw e;\n        }\n    }\n\n    /**\n     * Regular expression for safe style values.\n     *\n     * Quotes (\" and ') are allowed, but a check must be done elsewhere to ensure they're balanced.\n     *\n     * ',' allows multiple values to be assigned to the same property (e.g. background-attachment or\n     * font-family) and hence could allow multiple values to get injected, but that should pose no risk\n     * of XSS.\n     *\n     * The function expression checks only for XSS safety, not for CSS validity.\n     *\n     * This regular expression was taken from the Closure sanitization library, and augmented for\n     * transformation values.\n     */\n    var VALUES = '[-,.\"\\'%_!# a-zA-Z0-9]+';\n    var TRANSFORMATION_FNS = '(?:matrix|translate|scale|rotate|skew|perspective)(?:X|Y|3d)?';\n    var COLOR_FNS = '(?:rgb|hsl)a?';\n    var FN_ARGS = '\\\\([-0-9.%, a-zA-Z]+\\\\)';\n    var SAFE_STYLE_VALUE = new RegExp(\"^(\" + VALUES + \"|(?:\" + TRANSFORMATION_FNS + \"|\" + COLOR_FNS + \")\" + FN_ARGS + \")$\", 'g');\n    /**\n     * Matches a `url(...)` value with an arbitrary argument as long as it does\n     * not contain parentheses.\n     *\n     * The URL value still needs to be sanitized separately.\n     *\n     * `url(...)` values are a very common use case, e.g. for `background-image`. With carefully crafted\n     * CSS style rules, it is possible to construct an information leak with `url` values in CSS, e.g.\n     * by observing whether scroll bars are displayed, or character ranges used by a font face\n     * definition.\n     *\n     * Angular only allows binding CSS values (as opposed to entire CSS rules), so it is unlikely that\n     * binding a URL value without further cooperation from the page will cause an information leak, and\n     * if so, it is just a leak, not a full blown XSS vulnerability.\n     *\n     * Given the common use case, low likelihood of attack vector, and low impact of an attack, this\n     * code is permissive and allows URLs that sanitize otherwise.\n     */\n    var URL_RE = /^url\\(([^)]+)\\)$/;\n    /**\n     * Checks that quotes (\" and ') are properly balanced inside a string. Assumes\n     * that neither escape (\\) nor any other character that could result in\n     * breaking out of a string parsing context are allowed;\n     * see http://www.w3.org/TR/css3-syntax/#string-token-diagram.\n     *\n     * This code was taken from the Closure sanitization library.\n     */\n    function hasBalancedQuotes(value) {\n        var outsideSingle = true;\n        var outsideDouble = true;\n        for (var i = 0; i < value.length; i++) {\n            var c = value.charAt(i);\n            if (c === '\\'' && outsideDouble) {\n                outsideSingle = !outsideSingle;\n            }\n            else if (c === '\"' && outsideSingle) {\n                outsideDouble = !outsideDouble;\n            }\n        }\n        return outsideSingle && outsideDouble;\n    }\n    /**\n     * Sanitizes the given untrusted CSS style property value (i.e. not an entire object, just a single\n     * value) and returns a value that is safe to use in a browser environment.\n     */\n    function sanitizeStyle(value) {\n        value = String(value).trim(); // Make sure it's actually a string.\n        if (!value)\n            return '';\n        // Single url(...) values are supported, but only for URLs that sanitize cleanly. See above for\n        // reasoning behind this.\n        var urlMatch = value.match(URL_RE);\n        if ((urlMatch && sanitizeUrl(urlMatch[1]) === urlMatch[1]) ||\n            value.match(SAFE_STYLE_VALUE) && hasBalancedQuotes(value)) {\n            return value; // Safe style values.\n        }\n        if (_angular_core.isDevMode()) {\n            getDOM().log(\"WARNING: sanitizing unsafe style value \" + value + \" (see http://g.co/ng/security#xss).\");\n        }\n        return 'unsafe';\n    }\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$9 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    /**\n     * DomSanitizer helps preventing Cross Site Scripting Security bugs (XSS) by sanitizing\n     * values to be safe to use in the different DOM contexts.\n     *\n     * For example, when binding a URL in an `<a [href]=\"someValue\">` hyperlink, `someValue` will be\n     * sanitized so that an attacker cannot inject e.g. a `javascript:` URL that would execute code on\n     * the website.\n     *\n     * In specific situations, it might be necessary to disable sanitization, for example if the\n     * application genuinely needs to produce a `javascript:` style link with a dynamic value in it.\n     * Users can bypass security by constructing a value with one of the `bypassSecurityTrust...`\n     * methods, and then binding to that value from the template.\n     *\n     * These situations should be very rare, and extraordinary care must be taken to avoid creating a\n     * Cross Site Scripting (XSS) security bug!\n     *\n     * When using `bypassSecurityTrust...`, make sure to call the method as early as possible and as\n     * close as possible to the source of the value, to make it easy to verify no security bug is\n     * created by its use.\n     *\n     * It is not required (and not recommended) to bypass security if the value is safe, e.g. a URL that\n     * does not start with a suspicious protocol, or an HTML snippet that does not contain dangerous\n     * code. The sanitizer leaves safe values intact.\n     *\n     * @security Calling any of the `bypassSecurityTrust...` APIs disables Angular's built-in\n     * sanitization for the value passed in. Carefully check and audit all values and code paths going\n     * into this call. Make sure any user data is appropriately escaped for this security context.\n     * For more detail, see the [Security Guide](http://g.co/ng/security).\n     *\n     * @stable\n     */\n    var DomSanitizer = (function () {\n        function DomSanitizer() {\n        }\n        return DomSanitizer;\n    }());\n    var DomSanitizerImpl = (function (_super) {\n        __extends$9(DomSanitizerImpl, _super);\n        function DomSanitizerImpl() {\n            _super.apply(this, arguments);\n        }\n        DomSanitizerImpl.prototype.sanitize = function (ctx, value) {\n            if (value == null)\n                return null;\n            switch (ctx) {\n                case _angular_core.SecurityContext.NONE:\n                    return value;\n                case _angular_core.SecurityContext.HTML:\n                    if (value instanceof SafeHtmlImpl)\n                        return value.changingThisBreaksApplicationSecurity;\n                    this.checkNotSafeValue(value, 'HTML');\n                    return sanitizeHtml(String(value));\n                case _angular_core.SecurityContext.STYLE:\n                    if (value instanceof SafeStyleImpl)\n                        return value.changingThisBreaksApplicationSecurity;\n                    this.checkNotSafeValue(value, 'Style');\n                    return sanitizeStyle(value);\n                case _angular_core.SecurityContext.SCRIPT:\n                    if (value instanceof SafeScriptImpl)\n                        return value.changingThisBreaksApplicationSecurity;\n                    this.checkNotSafeValue(value, 'Script');\n                    throw new Error('unsafe value used in a script context');\n                case _angular_core.SecurityContext.URL:\n                    if (value instanceof SafeResourceUrlImpl || value instanceof SafeUrlImpl) {\n                        // Allow resource URLs in URL contexts, they are strictly more trusted.\n                        return value.changingThisBreaksApplicationSecurity;\n                    }\n                    this.checkNotSafeValue(value, 'URL');\n                    return sanitizeUrl(String(value));\n                case _angular_core.SecurityContext.RESOURCE_URL:\n                    if (value instanceof SafeResourceUrlImpl) {\n                        return value.changingThisBreaksApplicationSecurity;\n                    }\n                    this.checkNotSafeValue(value, 'ResourceURL');\n                    throw new Error('unsafe value used in a resource URL context (see http://g.co/ng/security#xss)');\n                default:\n                    throw new Error(\"Unexpected SecurityContext \" + ctx + \" (see http://g.co/ng/security#xss)\");\n            }\n        };\n        DomSanitizerImpl.prototype.checkNotSafeValue = function (value, expectedType) {\n            if (value instanceof SafeValueImpl) {\n                throw new Error((\"Required a safe \" + expectedType + \", got a \" + value.getTypeName() + \" \") +\n                    \"(see http://g.co/ng/security#xss)\");\n            }\n        };\n        DomSanitizerImpl.prototype.bypassSecurityTrustHtml = function (value) { return new SafeHtmlImpl(value); };\n        DomSanitizerImpl.prototype.bypassSecurityTrustStyle = function (value) { return new SafeStyleImpl(value); };\n        DomSanitizerImpl.prototype.bypassSecurityTrustScript = function (value) { return new SafeScriptImpl(value); };\n        DomSanitizerImpl.prototype.bypassSecurityTrustUrl = function (value) { return new SafeUrlImpl(value); };\n        DomSanitizerImpl.prototype.bypassSecurityTrustResourceUrl = function (value) {\n            return new SafeResourceUrlImpl(value);\n        };\n        DomSanitizerImpl.decorators = [\n            { type: _angular_core.Injectable },\n        ];\n        /** @nocollapse */\n        DomSanitizerImpl.ctorParameters = [];\n        return DomSanitizerImpl;\n    }(DomSanitizer));\n    var SafeValueImpl = (function () {\n        function SafeValueImpl(changingThisBreaksApplicationSecurity) {\n            this.changingThisBreaksApplicationSecurity = changingThisBreaksApplicationSecurity;\n            // empty\n        }\n        SafeValueImpl.prototype.toString = function () {\n            return (\"SafeValue must use [property]=binding: \" + this.changingThisBreaksApplicationSecurity) +\n                \" (see http://g.co/ng/security#xss)\";\n        };\n        return SafeValueImpl;\n    }());\n    var SafeHtmlImpl = (function (_super) {\n        __extends$9(SafeHtmlImpl, _super);\n        function SafeHtmlImpl() {\n            _super.apply(this, arguments);\n        }\n        SafeHtmlImpl.prototype.getTypeName = function () { return 'HTML'; };\n        return SafeHtmlImpl;\n    }(SafeValueImpl));\n    var SafeStyleImpl = (function (_super) {\n        __extends$9(SafeStyleImpl, _super);\n        function SafeStyleImpl() {\n            _super.apply(this, arguments);\n        }\n        SafeStyleImpl.prototype.getTypeName = function () { return 'Style'; };\n        return SafeStyleImpl;\n    }(SafeValueImpl));\n    var SafeScriptImpl = (function (_super) {\n        __extends$9(SafeScriptImpl, _super);\n        function SafeScriptImpl() {\n            _super.apply(this, arguments);\n        }\n        SafeScriptImpl.prototype.getTypeName = function () { return 'Script'; };\n        return SafeScriptImpl;\n    }(SafeValueImpl));\n    var SafeUrlImpl = (function (_super) {\n        __extends$9(SafeUrlImpl, _super);\n        function SafeUrlImpl() {\n            _super.apply(this, arguments);\n        }\n        SafeUrlImpl.prototype.getTypeName = function () { return 'URL'; };\n        return SafeUrlImpl;\n    }(SafeValueImpl));\n    var SafeResourceUrlImpl = (function (_super) {\n        __extends$9(SafeResourceUrlImpl, _super);\n        function SafeResourceUrlImpl() {\n            _super.apply(this, arguments);\n        }\n        SafeResourceUrlImpl.prototype.getTypeName = function () { return 'ResourceURL'; };\n        return SafeResourceUrlImpl;\n    }(SafeValueImpl));\n\n    var INTERNAL_BROWSER_PLATFORM_PROVIDERS = [\n        { provide: _angular_core.PLATFORM_INITIALIZER, useValue: initDomAdapter, multi: true },\n        { provide: _angular_common.PlatformLocation, useClass: BrowserPlatformLocation }\n    ];\n    /**\n     * @security Replacing built-in sanitization providers exposes the application to XSS risks.\n     * Attacker-controlled data introduced by an unsanitized provider could expose your\n     * application to XSS risks. For more detail, see the [Security Guide](http://g.co/ng/security).\n     * @experimental\n     */\n    var BROWSER_SANITIZATION_PROVIDERS = [\n        { provide: _angular_core.Sanitizer, useExisting: DomSanitizer },\n        { provide: DomSanitizer, useClass: DomSanitizerImpl },\n    ];\n    /**\n     * @stable\n     */\n    var platformBrowser = _angular_core.createPlatformFactory(_angular_core.platformCore, 'browser', INTERNAL_BROWSER_PLATFORM_PROVIDERS);\n    function initDomAdapter() {\n        BrowserDomAdapter.makeCurrent();\n        BrowserGetTestability.init();\n    }\n    function errorHandler() {\n        return new _angular_core.ErrorHandler();\n    }\n    function _document() {\n        return getDOM().defaultDoc();\n    }\n    function _resolveDefaultAnimationDriver() {\n        if (getDOM().supportsWebAnimation()) {\n            return new WebAnimationsDriver();\n        }\n        return AnimationDriver.NOOP;\n    }\n    /**\n     * The ng module for the browser.\n     *\n     * @stable\n     */\n    var BrowserModule = (function () {\n        function BrowserModule(parentModule) {\n            if (parentModule) {\n                throw new Error(\"BrowserModule has already been loaded. If you need access to common directives such as NgIf and NgFor from a lazy loaded module, import CommonModule instead.\");\n            }\n        }\n        BrowserModule.decorators = [\n            { type: _angular_core.NgModule, args: [{\n                        providers: [\n                            BROWSER_SANITIZATION_PROVIDERS, { provide: _angular_core.ErrorHandler, useFactory: errorHandler, deps: [] },\n                            { provide: DOCUMENT, useFactory: _document, deps: [] },\n                            { provide: EVENT_MANAGER_PLUGINS, useClass: DomEventsPlugin, multi: true },\n                            { provide: EVENT_MANAGER_PLUGINS, useClass: KeyEventsPlugin, multi: true },\n                            { provide: EVENT_MANAGER_PLUGINS, useClass: HammerGesturesPlugin, multi: true },\n                            { provide: HAMMER_GESTURE_CONFIG, useClass: HammerGestureConfig },\n                            { provide: DomRootRenderer, useClass: DomRootRenderer_ },\n                            { provide: _angular_core.RootRenderer, useExisting: DomRootRenderer },\n                            { provide: SharedStylesHost, useExisting: DomSharedStylesHost },\n                            { provide: AnimationDriver, useFactory: _resolveDefaultAnimationDriver }, DomSharedStylesHost,\n                            _angular_core.Testability, EventManager, ELEMENT_PROBE_PROVIDERS, Title\n                        ],\n                        exports: [_angular_common.CommonModule, _angular_core.ApplicationModule]\n                    },] },\n        ];\n        /** @nocollapse */\n        BrowserModule.ctorParameters = [\n            { type: BrowserModule, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.SkipSelf },] },\n        ];\n        return BrowserModule;\n    }());\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * JS version of browser APIs. This library can only run in the browser.\n     */\n    var win = typeof window !== 'undefined' && window || {};\n\n    var ChangeDetectionPerfRecord = (function () {\n        function ChangeDetectionPerfRecord(msPerTick, numTicks) {\n            this.msPerTick = msPerTick;\n            this.numTicks = numTicks;\n        }\n        return ChangeDetectionPerfRecord;\n    }());\n    /**\n     * Entry point for all Angular debug tools. This object corresponds to the `ng`\n     * global variable accessible in the dev console.\n     */\n    var AngularTools = (function () {\n        function AngularTools(ref) {\n            this.profiler = new AngularProfiler(ref);\n        }\n        return AngularTools;\n    }());\n    /**\n     * Entry point for all Angular profiling-related debug tools. This object\n     * corresponds to the `ng.profiler` in the dev console.\n     */\n    var AngularProfiler = (function () {\n        function AngularProfiler(ref) {\n            this.appRef = ref.injector.get(_angular_core.ApplicationRef);\n        }\n        /**\n         * Exercises change detection in a loop and then prints the average amount of\n         * time in milliseconds how long a single round of change detection takes for\n         * the current state of the UI. It runs a minimum of 5 rounds for a minimum\n         * of 500 milliseconds.\n         *\n         * Optionally, a user may pass a `config` parameter containing a map of\n         * options. Supported options are:\n         *\n         * `record` (boolean) - causes the profiler to record a CPU profile while\n         * it exercises the change detector. Example:\n         *\n         * ```\n         * ng.profiler.timeChangeDetection({record: true})\n         * ```\n         */\n        AngularProfiler.prototype.timeChangeDetection = function (config) {\n            var record = isPresent(config) && config['record'];\n            var profileName = 'Change Detection';\n            // Profiler is not available in Android browsers, nor in IE 9 without dev tools opened\n            var isProfilerAvailable = isPresent(win.console.profile);\n            if (record && isProfilerAvailable) {\n                win.console.profile(profileName);\n            }\n            var start = getDOM().performanceNow();\n            var numTicks = 0;\n            while (numTicks < 5 || (getDOM().performanceNow() - start) < 500) {\n                this.appRef.tick();\n                numTicks++;\n            }\n            var end = getDOM().performanceNow();\n            if (record && isProfilerAvailable) {\n                // need to cast to <any> because type checker thinks there's no argument\n                // while in fact there is:\n                //\n                // https://developer.mozilla.org/en-US/docs/Web/API/Console/profileEnd\n                win.console.profileEnd(profileName);\n            }\n            var msPerTick = (end - start) / numTicks;\n            win.console.log(\"ran \" + numTicks + \" change detection cycles\");\n            win.console.log(NumberWrapper.toFixed(msPerTick, 2) + \" ms per check\");\n            return new ChangeDetectionPerfRecord(msPerTick, numTicks);\n        };\n        return AngularProfiler;\n    }());\n\n    var context = global$1;\n    /**\n     * Enabled Angular 2 debug tools that are accessible via your browser's\n     * developer console.\n     *\n     * Usage:\n     *\n     * 1. Open developer console (e.g. in Chrome Ctrl + Shift + j)\n     * 1. Type `ng.` (usually the console will show auto-complete suggestion)\n     * 1. Try the change detection profiler `ng.profiler.timeChangeDetection()`\n     *    then hit Enter.\n     *\n     * @experimental All debugging apis are currently experimental.\n     */\n    function enableDebugTools(ref) {\n        context.ng = new AngularTools(ref);\n        return ref;\n    }\n    /**\n     * Disables Angular 2 tools.\n     *\n     * @experimental All debugging apis are currently experimental.\n     */\n    function disableDebugTools() {\n        delete context.ng;\n    }\n\n    /**\n     * Predicates for use with {@link DebugElement}'s query functions.\n     *\n     * @experimental All debugging apis are currently experimental.\n     */\n    var By = (function () {\n        function By() {\n        }\n        /**\n         * Match all elements.\n         *\n         * ## Example\n         *\n         * {@example platform-browser/dom/debug/ts/by/by.ts region='by_all'}\n         */\n        By.all = function () { return function (debugElement) { return true; }; };\n        /**\n         * Match elements by the given CSS selector.\n         *\n         * ## Example\n         *\n         * {@example platform-browser/dom/debug/ts/by/by.ts region='by_css'}\n         */\n        By.css = function (selector) {\n            return function (debugElement) {\n                return isPresent(debugElement.nativeElement) ?\n                    getDOM().elementMatches(debugElement.nativeElement, selector) :\n                    false;\n            };\n        };\n        /**\n         * Match elements that have the given directive present.\n         *\n         * ## Example\n         *\n         * {@example platform-browser/dom/debug/ts/by/by.ts region='by_directive'}\n         */\n        By.directive = function (type) {\n            return function (debugElement) { return debugElement.providerTokens.indexOf(type) !== -1; };\n        };\n        return By;\n    }());\n\n    var __platform_browser_private__ = {\n        BrowserPlatformLocation: BrowserPlatformLocation,\n        DomAdapter: DomAdapter,\n        BrowserDomAdapter: BrowserDomAdapter,\n        BrowserGetTestability: BrowserGetTestability,\n        getDOM: getDOM,\n        setRootDomAdapter: setRootDomAdapter,\n        DomRootRenderer_: DomRootRenderer_,\n        DomRootRenderer: DomRootRenderer,\n        DomSharedStylesHost: DomSharedStylesHost,\n        SharedStylesHost: SharedStylesHost,\n        ELEMENT_PROBE_PROVIDERS: ELEMENT_PROBE_PROVIDERS,\n        DomEventsPlugin: DomEventsPlugin,\n        KeyEventsPlugin: KeyEventsPlugin,\n        HammerGesturesPlugin: HammerGesturesPlugin,\n        initDomAdapter: initDomAdapter,\n        INTERNAL_BROWSER_PLATFORM_PROVIDERS: INTERNAL_BROWSER_PLATFORM_PROVIDERS,\n        BROWSER_SANITIZATION_PROVIDERS: BROWSER_SANITIZATION_PROVIDERS\n    };\n\n    exports.BrowserModule = BrowserModule;\n    exports.platformBrowser = platformBrowser;\n    exports.Title = Title;\n    exports.disableDebugTools = disableDebugTools;\n    exports.enableDebugTools = enableDebugTools;\n    exports.AnimationDriver = AnimationDriver;\n    exports.By = By;\n    exports.NgProbeToken = NgProbeToken;\n    exports.DOCUMENT = DOCUMENT;\n    exports.EVENT_MANAGER_PLUGINS = EVENT_MANAGER_PLUGINS;\n    exports.EventManager = EventManager;\n    exports.HAMMER_GESTURE_CONFIG = HAMMER_GESTURE_CONFIG;\n    exports.HammerGestureConfig = HammerGestureConfig;\n    exports.DomSanitizer = DomSanitizer;\n    exports.__platform_browser_private__ = __platform_browser_private__;\n\n}));\n\n/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/@angular/platform-browser/bundles/platform-browser.umd.js\n ** module id = 21\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/@angular/platform-browser/bundles/platform-browser.umd.js?");

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(global) {/**\n * @license Angular v2.0.1\n * (c) 2010-2016 Google, Inc. https://angular.io/\n * License: MIT\n */\n(function (global, factory) {\n     true ? factory(exports, __webpack_require__(3)) :\n    typeof define === 'function' && define.amd ? define(['exports', '@angular/core'], factory) :\n    (factory((global.ng = global.ng || {}, global.ng.common = global.ng.common || {}),global.ng.core));\n}(this, function (exports,_angular_core) { 'use strict';\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * This class should not be used directly by an application developer. Instead, use\n     * {@link Location}.\n     *\n     * `PlatformLocation` encapsulates all calls to DOM apis, which allows the Router to be platform\n     * agnostic.\n     * This means that we can have different implementation of `PlatformLocation` for the different\n     * platforms\n     * that angular supports. For example, the default `PlatformLocation` is {@link\n     * BrowserPlatformLocation},\n     * however when you run your app in a WebWorker you use {@link WebWorkerPlatformLocation}.\n     *\n     * The `PlatformLocation` class is used directly by all implementations of {@link LocationStrategy}\n     * when\n     * they need to interact with the DOM apis like pushState, popState, etc...\n     *\n     * {@link LocationStrategy} in turn is used by the {@link Location} service which is used directly\n     * by\n     * the {@link Router} in order to navigate between routes. Since all interactions between {@link\n     * Router} /\n     * {@link Location} / {@link LocationStrategy} and DOM apis flow through the `PlatformLocation`\n     * class\n     * they are all platform independent.\n     *\n     * @stable\n     */\n    var PlatformLocation = (function () {\n        function PlatformLocation() {\n        }\n        Object.defineProperty(PlatformLocation.prototype, \"pathname\", {\n            get: function () { return null; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(PlatformLocation.prototype, \"search\", {\n            get: function () { return null; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(PlatformLocation.prototype, \"hash\", {\n            get: function () { return null; },\n            enumerable: true,\n            configurable: true\n        });\n        return PlatformLocation;\n    }());\n\n    /**\n     * `LocationStrategy` is responsible for representing and reading route state\n     * from the browser's URL. Angular provides two strategies:\n     * {@link HashLocationStrategy} and {@link PathLocationStrategy} (default).\n     *\n     * This is used under the hood of the {@link Location} service.\n     *\n     * Applications should use the {@link Router} or {@link Location} services to\n     * interact with application route state.\n     *\n     * For instance, {@link HashLocationStrategy} produces URLs like\n     * `http://example.com#/foo`, and {@link PathLocationStrategy} produces\n     * `http://example.com/foo` as an equivalent URL.\n     *\n     * See these two classes for more.\n     *\n     * @stable\n     */\n    var LocationStrategy = (function () {\n        function LocationStrategy() {\n        }\n        return LocationStrategy;\n    }());\n    /**\n     * The `APP_BASE_HREF` token represents the base href to be used with the\n     * {@link PathLocationStrategy}.\n     *\n     * If you're using {@link PathLocationStrategy}, you must provide a provider to a string\n     * representing the URL prefix that should be preserved when generating and recognizing\n     * URLs.\n     *\n     * ### Example\n     *\n     * ```typescript\n     * import {Component, NgModule} from '@angular/core';\n     * import {APP_BASE_HREF} from '@angular/common';\n     *\n     * @NgModule({\n     *   providers: [{provide: APP_BASE_HREF, useValue: '/my/app'}]\n     * })\n     * class AppModule {}\n     * ```\n     *\n     * @stable\n     */\n    var APP_BASE_HREF = new _angular_core.OpaqueToken('appBaseHref');\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var globalScope;\n    if (typeof window === 'undefined') {\n        if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {\n            // TODO: Replace any with WorkerGlobalScope from lib.webworker.d.ts #3492\n            globalScope = self;\n        }\n        else {\n            globalScope = global;\n        }\n    }\n    else {\n        globalScope = window;\n    }\n    // Need to declare a new variable for global here since TypeScript\n    // exports the original value of the symbol.\n    var _global = globalScope;\n    function getTypeNameForDebugging(type) {\n        if (type['name']) {\n            return type['name'];\n        }\n        return typeof type;\n    }\n    var Date$1 = _global.Date;\n    // TODO: remove calls to assert in production environment\n    // Note: Can't just export this and import in in other files\n    // as `assert` is a reserved keyword in Dart\n    _global.assert = function assert(condition) {\n        // TODO: to be fixed properly via #2830, noop for now\n    };\n    function isPresent(obj) {\n        return obj !== undefined && obj !== null;\n    }\n    function isBlank(obj) {\n        return obj === undefined || obj === null;\n    }\n    function isStringMap(obj) {\n        return typeof obj === 'object' && obj !== null;\n    }\n    function isArray(obj) {\n        return Array.isArray(obj);\n    }\n    function isDate(obj) {\n        return obj instanceof Date$1 && !isNaN(obj.valueOf());\n    }\n    function stringify(token) {\n        if (typeof token === 'string') {\n            return token;\n        }\n        if (token === undefined || token === null) {\n            return '' + token;\n        }\n        if (token.overriddenName) {\n            return token.overriddenName;\n        }\n        if (token.name) {\n            return token.name;\n        }\n        var res = token.toString();\n        var newLineIndex = res.indexOf('\\n');\n        return (newLineIndex === -1) ? res : res.substring(0, newLineIndex);\n    }\n    var NumberWrapper = (function () {\n        function NumberWrapper() {\n        }\n        NumberWrapper.toFixed = function (n, fractionDigits) { return n.toFixed(fractionDigits); };\n        NumberWrapper.equal = function (a, b) { return a === b; };\n        NumberWrapper.parseIntAutoRadix = function (text) {\n            var result = parseInt(text);\n            if (isNaN(result)) {\n                throw new Error('Invalid integer literal when parsing ' + text);\n            }\n            return result;\n        };\n        NumberWrapper.parseInt = function (text, radix) {\n            if (radix == 10) {\n                if (/^(\\-|\\+)?[0-9]+$/.test(text)) {\n                    return parseInt(text, radix);\n                }\n            }\n            else if (radix == 16) {\n                if (/^(\\-|\\+)?[0-9ABCDEFabcdef]+$/.test(text)) {\n                    return parseInt(text, radix);\n                }\n            }\n            else {\n                var result = parseInt(text, radix);\n                if (!isNaN(result)) {\n                    return result;\n                }\n            }\n            throw new Error('Invalid integer literal when parsing ' + text + ' in base ' + radix);\n        };\n        Object.defineProperty(NumberWrapper, \"NaN\", {\n            get: function () { return NaN; },\n            enumerable: true,\n            configurable: true\n        });\n        NumberWrapper.isNumeric = function (value) { return !isNaN(value - parseFloat(value)); };\n        NumberWrapper.isNaN = function (value) { return isNaN(value); };\n        NumberWrapper.isInteger = function (value) { return Number.isInteger(value); };\n        return NumberWrapper;\n    }());\n    function isJsObject(o) {\n        return o !== null && (typeof o === 'function' || typeof o === 'object');\n    }\n    // Can't be all uppercase as our transpiler would think it is a special directive...\n    var Json = (function () {\n        function Json() {\n        }\n        Json.parse = function (s) { return _global.JSON.parse(s); };\n        Json.stringify = function (data) {\n            // Dart doesn't take 3 arguments\n            return _global.JSON.stringify(data, null, 2);\n        };\n        return Json;\n    }());\n    var _symbolIterator = null;\n    function getSymbolIterator() {\n        if (isBlank(_symbolIterator)) {\n            if (isPresent(globalScope.Symbol) && isPresent(Symbol.iterator)) {\n                _symbolIterator = Symbol.iterator;\n            }\n            else {\n                // es6-shim specific logic\n                var keys = Object.getOwnPropertyNames(Map.prototype);\n                for (var i = 0; i < keys.length; ++i) {\n                    var key = keys[i];\n                    if (key !== 'entries' && key !== 'size' &&\n                        Map.prototype[key] === Map.prototype['entries']) {\n                        _symbolIterator = key;\n                    }\n                }\n            }\n        }\n        return _symbolIterator;\n    }\n\n    /**\n     * `Location` is a service that applications can use to interact with a browser's URL.\n     * Depending on which {@link LocationStrategy} is used, `Location` will either persist\n     * to the URL's path or the URL's hash segment.\n     *\n     * Note: it's better to use {@link Router#navigate} service to trigger route changes. Use\n     * `Location` only if you need to interact with or create normalized URLs outside of\n     * routing.\n     *\n     * `Location` is responsible for normalizing the URL against the application's base href.\n     * A normalized URL is absolute from the URL host, includes the application's base href, and has no\n     * trailing slash:\n     * - `/my/app/user/123` is normalized\n     * - `my/app/user/123` **is not** normalized\n     * - `/my/app/user/123/` **is not** normalized\n     *\n     * ### Example\n     *\n     * ```\n     * import {Component} from '@angular/core';\n     * import {Location} from '@angular/common';\n     *\n     * @Component({selector: 'app-component'})\n     * class AppCmp {\n     *   constructor(location: Location) {\n     *     location.go('/foo');\n     *   }\n     * }\n     * ```\n     *\n     * @stable\n     */\n    var Location = (function () {\n        function Location(platformStrategy) {\n            var _this = this;\n            /** @internal */\n            this._subject = new _angular_core.EventEmitter();\n            this._platformStrategy = platformStrategy;\n            var browserBaseHref = this._platformStrategy.getBaseHref();\n            this._baseHref = Location.stripTrailingSlash(_stripIndexHtml(browserBaseHref));\n            this._platformStrategy.onPopState(function (ev) {\n                _this._subject.emit({\n                    'url': _this.path(true),\n                    'pop': true,\n                    'type': ev.type,\n                });\n            });\n        }\n        /**\n         * Returns the normalized URL path.\n         */\n        // TODO: vsavkin. Remove the boolean flag and always include hash once the deprecated router is\n        // removed.\n        Location.prototype.path = function (includeHash) {\n            if (includeHash === void 0) { includeHash = false; }\n            return this.normalize(this._platformStrategy.path(includeHash));\n        };\n        /**\n         * Normalizes the given path and compares to the current normalized path.\n         */\n        Location.prototype.isCurrentPathEqualTo = function (path, query) {\n            if (query === void 0) { query = ''; }\n            return this.path() == this.normalize(path + Location.normalizeQueryParams(query));\n        };\n        /**\n         * Given a string representing a URL, returns the normalized URL path without leading or\n         * trailing slashes.\n         */\n        Location.prototype.normalize = function (url) {\n            return Location.stripTrailingSlash(_stripBaseHref(this._baseHref, _stripIndexHtml(url)));\n        };\n        /**\n         * Given a string representing a URL, returns the platform-specific external URL path.\n         * If the given URL doesn't begin with a leading slash (`'/'`), this method adds one\n         * before normalizing. This method will also add a hash if `HashLocationStrategy` is\n         * used, or the `APP_BASE_HREF` if the `PathLocationStrategy` is in use.\n         */\n        Location.prototype.prepareExternalUrl = function (url) {\n            if (url.length > 0 && !url.startsWith('/')) {\n                url = '/' + url;\n            }\n            return this._platformStrategy.prepareExternalUrl(url);\n        };\n        // TODO: rename this method to pushState\n        /**\n         * Changes the browsers URL to the normalized version of the given URL, and pushes a\n         * new item onto the platform's history.\n         */\n        Location.prototype.go = function (path, query) {\n            if (query === void 0) { query = ''; }\n            this._platformStrategy.pushState(null, '', path, query);\n        };\n        /**\n         * Changes the browsers URL to the normalized version of the given URL, and replaces\n         * the top item on the platform's history stack.\n         */\n        Location.prototype.replaceState = function (path, query) {\n            if (query === void 0) { query = ''; }\n            this._platformStrategy.replaceState(null, '', path, query);\n        };\n        /**\n         * Navigates forward in the platform's history.\n         */\n        Location.prototype.forward = function () { this._platformStrategy.forward(); };\n        /**\n         * Navigates back in the platform's history.\n         */\n        Location.prototype.back = function () { this._platformStrategy.back(); };\n        /**\n         * Subscribe to the platform's `popState` events.\n         */\n        Location.prototype.subscribe = function (onNext, onThrow, onReturn) {\n            if (onThrow === void 0) { onThrow = null; }\n            if (onReturn === void 0) { onReturn = null; }\n            return this._subject.subscribe({ next: onNext, error: onThrow, complete: onReturn });\n        };\n        /**\n         * Given a string of url parameters, prepend with '?' if needed, otherwise return parameters as\n         * is.\n         */\n        Location.normalizeQueryParams = function (params) {\n            return (params.length > 0 && params.substring(0, 1) != '?') ? ('?' + params) : params;\n        };\n        /**\n         * Given 2 parts of a url, join them with a slash if needed.\n         */\n        Location.joinWithSlash = function (start, end) {\n            if (start.length == 0) {\n                return end;\n            }\n            if (end.length == 0) {\n                return start;\n            }\n            var slashes = 0;\n            if (start.endsWith('/')) {\n                slashes++;\n            }\n            if (end.startsWith('/')) {\n                slashes++;\n            }\n            if (slashes == 2) {\n                return start + end.substring(1);\n            }\n            if (slashes == 1) {\n                return start + end;\n            }\n            return start + '/' + end;\n        };\n        /**\n         * If url has a trailing slash, remove it, otherwise return url as is.\n         */\n        Location.stripTrailingSlash = function (url) {\n            if (/\\/$/g.test(url)) {\n                url = url.substring(0, url.length - 1);\n            }\n            return url;\n        };\n        Location.decorators = [\n            { type: _angular_core.Injectable },\n        ];\n        /** @nocollapse */\n        Location.ctorParameters = [\n            { type: LocationStrategy, },\n        ];\n        return Location;\n    }());\n    function _stripBaseHref(baseHref, url) {\n        if (baseHref.length > 0 && url.startsWith(baseHref)) {\n            return url.substring(baseHref.length);\n        }\n        return url;\n    }\n    function _stripIndexHtml(url) {\n        if (/\\/index.html$/g.test(url)) {\n            // '/index.html'.length == 11\n            return url.substring(0, url.length - 11);\n        }\n        return url;\n    }\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    /**\n     * `HashLocationStrategy` is a {@link LocationStrategy} used to configure the\n     * {@link Location} service to represent its state in the\n     * [hash fragment](https://en.wikipedia.org/wiki/Uniform_Resource_Locator#Syntax)\n     * of the browser's URL.\n     *\n     * For instance, if you call `location.go('/foo')`, the browser's URL will become\n     * `example.com#/foo`.\n     *\n     * ### Example\n     *\n     * ```\n     * import {Component, NgModule} from '@angular/core';\n     * import {\n     *   LocationStrategy,\n     *   HashLocationStrategy\n     * } from '@angular/common';\n     *\n     * @NgModule({\n     *   providers: [{provide: LocationStrategy, useClass: HashLocationStrategy}]\n     * })\n     * class AppModule {}\n     * ```\n     *\n     * @stable\n     */\n    var HashLocationStrategy = (function (_super) {\n        __extends(HashLocationStrategy, _super);\n        function HashLocationStrategy(_platformLocation, _baseHref) {\n            _super.call(this);\n            this._platformLocation = _platformLocation;\n            this._baseHref = '';\n            if (isPresent(_baseHref)) {\n                this._baseHref = _baseHref;\n            }\n        }\n        HashLocationStrategy.prototype.onPopState = function (fn) {\n            this._platformLocation.onPopState(fn);\n            this._platformLocation.onHashChange(fn);\n        };\n        HashLocationStrategy.prototype.getBaseHref = function () { return this._baseHref; };\n        HashLocationStrategy.prototype.path = function (includeHash) {\n            if (includeHash === void 0) { includeHash = false; }\n            // the hash value is always prefixed with a `#`\n            // and if it is empty then it will stay empty\n            var path = this._platformLocation.hash;\n            if (!isPresent(path))\n                path = '#';\n            return path.length > 0 ? path.substring(1) : path;\n        };\n        HashLocationStrategy.prototype.prepareExternalUrl = function (internal) {\n            var url = Location.joinWithSlash(this._baseHref, internal);\n            return url.length > 0 ? ('#' + url) : url;\n        };\n        HashLocationStrategy.prototype.pushState = function (state, title, path, queryParams) {\n            var url = this.prepareExternalUrl(path + Location.normalizeQueryParams(queryParams));\n            if (url.length == 0) {\n                url = this._platformLocation.pathname;\n            }\n            this._platformLocation.pushState(state, title, url);\n        };\n        HashLocationStrategy.prototype.replaceState = function (state, title, path, queryParams) {\n            var url = this.prepareExternalUrl(path + Location.normalizeQueryParams(queryParams));\n            if (url.length == 0) {\n                url = this._platformLocation.pathname;\n            }\n            this._platformLocation.replaceState(state, title, url);\n        };\n        HashLocationStrategy.prototype.forward = function () { this._platformLocation.forward(); };\n        HashLocationStrategy.prototype.back = function () { this._platformLocation.back(); };\n        HashLocationStrategy.decorators = [\n            { type: _angular_core.Injectable },\n        ];\n        /** @nocollapse */\n        HashLocationStrategy.ctorParameters = [\n            { type: PlatformLocation, },\n            { type: undefined, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Inject, args: [APP_BASE_HREF,] },] },\n        ];\n        return HashLocationStrategy;\n    }(LocationStrategy));\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$1 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    /**\n     * `PathLocationStrategy` is a {@link LocationStrategy} used to configure the\n     * {@link Location} service to represent its state in the\n     * [path](https://en.wikipedia.org/wiki/Uniform_Resource_Locator#Syntax) of the\n     * browser's URL.\n     *\n     * `PathLocationStrategy` is the default binding for {@link LocationStrategy}\n     * provided in {@link ROUTER_PROVIDERS}.\n     *\n     * If you're using `PathLocationStrategy`, you must provide a {@link APP_BASE_HREF}\n     * or add a base element to the document. This URL prefix that will be preserved\n     * when generating and recognizing URLs.\n     *\n     * For instance, if you provide an `APP_BASE_HREF` of `'/my/app'` and call\n     * `location.go('/foo')`, the browser's URL will become\n     * `example.com/my/app/foo`.\n     *\n     * Similarly, if you add `<base href='/my/app'/>` to the document and call\n     * `location.go('/foo')`, the browser's URL will become\n     * `example.com/my/app/foo`.\n     *\n     * @stable\n     */\n    var PathLocationStrategy = (function (_super) {\n        __extends$1(PathLocationStrategy, _super);\n        function PathLocationStrategy(_platformLocation, href) {\n            _super.call(this);\n            this._platformLocation = _platformLocation;\n            if (isBlank(href)) {\n                href = this._platformLocation.getBaseHrefFromDOM();\n            }\n            if (isBlank(href)) {\n                throw new Error(\"No base href set. Please provide a value for the APP_BASE_HREF token or add a base element to the document.\");\n            }\n            this._baseHref = href;\n        }\n        PathLocationStrategy.prototype.onPopState = function (fn) {\n            this._platformLocation.onPopState(fn);\n            this._platformLocation.onHashChange(fn);\n        };\n        PathLocationStrategy.prototype.getBaseHref = function () { return this._baseHref; };\n        PathLocationStrategy.prototype.prepareExternalUrl = function (internal) {\n            return Location.joinWithSlash(this._baseHref, internal);\n        };\n        PathLocationStrategy.prototype.path = function (includeHash) {\n            if (includeHash === void 0) { includeHash = false; }\n            var pathname = this._platformLocation.pathname +\n                Location.normalizeQueryParams(this._platformLocation.search);\n            var hash = this._platformLocation.hash;\n            return hash && includeHash ? \"\" + pathname + hash : pathname;\n        };\n        PathLocationStrategy.prototype.pushState = function (state, title, url, queryParams) {\n            var externalUrl = this.prepareExternalUrl(url + Location.normalizeQueryParams(queryParams));\n            this._platformLocation.pushState(state, title, externalUrl);\n        };\n        PathLocationStrategy.prototype.replaceState = function (state, title, url, queryParams) {\n            var externalUrl = this.prepareExternalUrl(url + Location.normalizeQueryParams(queryParams));\n            this._platformLocation.replaceState(state, title, externalUrl);\n        };\n        PathLocationStrategy.prototype.forward = function () { this._platformLocation.forward(); };\n        PathLocationStrategy.prototype.back = function () { this._platformLocation.back(); };\n        PathLocationStrategy.decorators = [\n            { type: _angular_core.Injectable },\n        ];\n        /** @nocollapse */\n        PathLocationStrategy.ctorParameters = [\n            { type: PlatformLocation, },\n            { type: undefined, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Inject, args: [APP_BASE_HREF,] },] },\n        ];\n        return PathLocationStrategy;\n    }(LocationStrategy));\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$2 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    /**\n     * @experimental\n     */\n    var NgLocalization = (function () {\n        function NgLocalization() {\n        }\n        return NgLocalization;\n    }());\n    /**\n     * Returns the plural category for a given value.\n     * - \"=value\" when the case exists,\n     * - the plural category otherwise\n     *\n     * @internal\n     */\n    function getPluralCategory(value, cases, ngLocalization) {\n        var nbCase = \"=\" + value;\n        return cases.indexOf(nbCase) > -1 ? nbCase : ngLocalization.getPluralCategory(value);\n    }\n    /**\n     * Returns the plural case based on the locale\n     *\n     * @experimental\n     */\n    var NgLocaleLocalization = (function (_super) {\n        __extends$2(NgLocaleLocalization, _super);\n        function NgLocaleLocalization(_locale) {\n            _super.call(this);\n            this._locale = _locale;\n        }\n        NgLocaleLocalization.prototype.getPluralCategory = function (value) {\n            var plural = getPluralCase(this._locale, value);\n            switch (plural) {\n                case Plural.Zero:\n                    return 'zero';\n                case Plural.One:\n                    return 'one';\n                case Plural.Two:\n                    return 'two';\n                case Plural.Few:\n                    return 'few';\n                case Plural.Many:\n                    return 'many';\n                default:\n                    return 'other';\n            }\n        };\n        NgLocaleLocalization.decorators = [\n            { type: _angular_core.Injectable },\n        ];\n        /** @nocollapse */\n        NgLocaleLocalization.ctorParameters = [\n            { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_core.LOCALE_ID,] },] },\n        ];\n        return NgLocaleLocalization;\n    }(NgLocalization));\n    // This is generated code DO NOT MODIFY\n    // see angular2/script/cldr/gen_plural_rules.js\n    /** @experimental */\n    var Plural;\n    (function (Plural) {\n        Plural[Plural[\"Zero\"] = 0] = \"Zero\";\n        Plural[Plural[\"One\"] = 1] = \"One\";\n        Plural[Plural[\"Two\"] = 2] = \"Two\";\n        Plural[Plural[\"Few\"] = 3] = \"Few\";\n        Plural[Plural[\"Many\"] = 4] = \"Many\";\n        Plural[Plural[\"Other\"] = 5] = \"Other\";\n    })(Plural || (Plural = {}));\n    /**\n     * Returns the plural case based on the locale\n     *\n     * @experimental\n     */\n    function getPluralCase(locale, nLike) {\n        // TODO(vicb): lazy compute\n        if (typeof nLike === 'string') {\n            nLike = parseInt(nLike, 10);\n        }\n        var n = nLike;\n        var nDecimal = n.toString().replace(/^[^.]*\\.?/, '');\n        var i = Math.floor(Math.abs(n));\n        var v = nDecimal.length;\n        var f = parseInt(nDecimal, 10);\n        var t = parseInt(n.toString().replace(/^[^.]*\\.?|0+$/g, ''), 10) || 0;\n        var lang = locale.split('-')[0].toLowerCase();\n        switch (lang) {\n            case 'af':\n            case 'asa':\n            case 'az':\n            case 'bem':\n            case 'bez':\n            case 'bg':\n            case 'brx':\n            case 'ce':\n            case 'cgg':\n            case 'chr':\n            case 'ckb':\n            case 'ee':\n            case 'el':\n            case 'eo':\n            case 'es':\n            case 'eu':\n            case 'fo':\n            case 'fur':\n            case 'gsw':\n            case 'ha':\n            case 'haw':\n            case 'hu':\n            case 'jgo':\n            case 'jmc':\n            case 'ka':\n            case 'kk':\n            case 'kkj':\n            case 'kl':\n            case 'ks':\n            case 'ksb':\n            case 'ky':\n            case 'lb':\n            case 'lg':\n            case 'mas':\n            case 'mgo':\n            case 'ml':\n            case 'mn':\n            case 'nb':\n            case 'nd':\n            case 'ne':\n            case 'nn':\n            case 'nnh':\n            case 'nyn':\n            case 'om':\n            case 'or':\n            case 'os':\n            case 'ps':\n            case 'rm':\n            case 'rof':\n            case 'rwk':\n            case 'saq':\n            case 'seh':\n            case 'sn':\n            case 'so':\n            case 'sq':\n            case 'ta':\n            case 'te':\n            case 'teo':\n            case 'tk':\n            case 'tr':\n            case 'ug':\n            case 'uz':\n            case 'vo':\n            case 'vun':\n            case 'wae':\n            case 'xog':\n                if (n === 1)\n                    return Plural.One;\n                return Plural.Other;\n            case 'agq':\n            case 'bas':\n            case 'cu':\n            case 'dav':\n            case 'dje':\n            case 'dua':\n            case 'dyo':\n            case 'ebu':\n            case 'ewo':\n            case 'guz':\n            case 'kam':\n            case 'khq':\n            case 'ki':\n            case 'kln':\n            case 'kok':\n            case 'ksf':\n            case 'lrc':\n            case 'lu':\n            case 'luo':\n            case 'luy':\n            case 'mer':\n            case 'mfe':\n            case 'mgh':\n            case 'mua':\n            case 'mzn':\n            case 'nmg':\n            case 'nus':\n            case 'qu':\n            case 'rn':\n            case 'rw':\n            case 'sbp':\n            case 'twq':\n            case 'vai':\n            case 'yav':\n            case 'yue':\n            case 'zgh':\n            case 'ak':\n            case 'ln':\n            case 'mg':\n            case 'pa':\n            case 'ti':\n                if (n === Math.floor(n) && n >= 0 && n <= 1)\n                    return Plural.One;\n                return Plural.Other;\n            case 'am':\n            case 'as':\n            case 'bn':\n            case 'fa':\n            case 'gu':\n            case 'hi':\n            case 'kn':\n            case 'mr':\n            case 'zu':\n                if (i === 0 || n === 1)\n                    return Plural.One;\n                return Plural.Other;\n            case 'ar':\n                if (n === 0)\n                    return Plural.Zero;\n                if (n === 1)\n                    return Plural.One;\n                if (n === 2)\n                    return Plural.Two;\n                if (n % 100 === Math.floor(n % 100) && n % 100 >= 3 && n % 100 <= 10)\n                    return Plural.Few;\n                if (n % 100 === Math.floor(n % 100) && n % 100 >= 11 && n % 100 <= 99)\n                    return Plural.Many;\n                return Plural.Other;\n            case 'ast':\n            case 'ca':\n            case 'de':\n            case 'en':\n            case 'et':\n            case 'fi':\n            case 'fy':\n            case 'gl':\n            case 'it':\n            case 'nl':\n            case 'sv':\n            case 'sw':\n            case 'ur':\n            case 'yi':\n                if (i === 1 && v === 0)\n                    return Plural.One;\n                return Plural.Other;\n            case 'be':\n                if (n % 10 === 1 && !(n % 100 === 11))\n                    return Plural.One;\n                if (n % 10 === Math.floor(n % 10) && n % 10 >= 2 && n % 10 <= 4 &&\n                    !(n % 100 >= 12 && n % 100 <= 14))\n                    return Plural.Few;\n                if (n % 10 === 0 || n % 10 === Math.floor(n % 10) && n % 10 >= 5 && n % 10 <= 9 ||\n                    n % 100 === Math.floor(n % 100) && n % 100 >= 11 && n % 100 <= 14)\n                    return Plural.Many;\n                return Plural.Other;\n            case 'br':\n                if (n % 10 === 1 && !(n % 100 === 11 || n % 100 === 71 || n % 100 === 91))\n                    return Plural.One;\n                if (n % 10 === 2 && !(n % 100 === 12 || n % 100 === 72 || n % 100 === 92))\n                    return Plural.Two;\n                if (n % 10 === Math.floor(n % 10) && (n % 10 >= 3 && n % 10 <= 4 || n % 10 === 9) &&\n                    !(n % 100 >= 10 && n % 100 <= 19 || n % 100 >= 70 && n % 100 <= 79 ||\n                        n % 100 >= 90 && n % 100 <= 99))\n                    return Plural.Few;\n                if (!(n === 0) && n % 1e6 === 0)\n                    return Plural.Many;\n                return Plural.Other;\n            case 'bs':\n            case 'hr':\n            case 'sr':\n                if (v === 0 && i % 10 === 1 && !(i % 100 === 11) || f % 10 === 1 && !(f % 100 === 11))\n                    return Plural.One;\n                if (v === 0 && i % 10 === Math.floor(i % 10) && i % 10 >= 2 && i % 10 <= 4 &&\n                    !(i % 100 >= 12 && i % 100 <= 14) ||\n                    f % 10 === Math.floor(f % 10) && f % 10 >= 2 && f % 10 <= 4 &&\n                        !(f % 100 >= 12 && f % 100 <= 14))\n                    return Plural.Few;\n                return Plural.Other;\n            case 'cs':\n            case 'sk':\n                if (i === 1 && v === 0)\n                    return Plural.One;\n                if (i === Math.floor(i) && i >= 2 && i <= 4 && v === 0)\n                    return Plural.Few;\n                if (!(v === 0))\n                    return Plural.Many;\n                return Plural.Other;\n            case 'cy':\n                if (n === 0)\n                    return Plural.Zero;\n                if (n === 1)\n                    return Plural.One;\n                if (n === 2)\n                    return Plural.Two;\n                if (n === 3)\n                    return Plural.Few;\n                if (n === 6)\n                    return Plural.Many;\n                return Plural.Other;\n            case 'da':\n                if (n === 1 || !(t === 0) && (i === 0 || i === 1))\n                    return Plural.One;\n                return Plural.Other;\n            case 'dsb':\n            case 'hsb':\n                if (v === 0 && i % 100 === 1 || f % 100 === 1)\n                    return Plural.One;\n                if (v === 0 && i % 100 === 2 || f % 100 === 2)\n                    return Plural.Two;\n                if (v === 0 && i % 100 === Math.floor(i % 100) && i % 100 >= 3 && i % 100 <= 4 ||\n                    f % 100 === Math.floor(f % 100) && f % 100 >= 3 && f % 100 <= 4)\n                    return Plural.Few;\n                return Plural.Other;\n            case 'ff':\n            case 'fr':\n            case 'hy':\n            case 'kab':\n                if (i === 0 || i === 1)\n                    return Plural.One;\n                return Plural.Other;\n            case 'fil':\n                if (v === 0 && (i === 1 || i === 2 || i === 3) ||\n                    v === 0 && !(i % 10 === 4 || i % 10 === 6 || i % 10 === 9) ||\n                    !(v === 0) && !(f % 10 === 4 || f % 10 === 6 || f % 10 === 9))\n                    return Plural.One;\n                return Plural.Other;\n            case 'ga':\n                if (n === 1)\n                    return Plural.One;\n                if (n === 2)\n                    return Plural.Two;\n                if (n === Math.floor(n) && n >= 3 && n <= 6)\n                    return Plural.Few;\n                if (n === Math.floor(n) && n >= 7 && n <= 10)\n                    return Plural.Many;\n                return Plural.Other;\n            case 'gd':\n                if (n === 1 || n === 11)\n                    return Plural.One;\n                if (n === 2 || n === 12)\n                    return Plural.Two;\n                if (n === Math.floor(n) && (n >= 3 && n <= 10 || n >= 13 && n <= 19))\n                    return Plural.Few;\n                return Plural.Other;\n            case 'gv':\n                if (v === 0 && i % 10 === 1)\n                    return Plural.One;\n                if (v === 0 && i % 10 === 2)\n                    return Plural.Two;\n                if (v === 0 &&\n                    (i % 100 === 0 || i % 100 === 20 || i % 100 === 40 || i % 100 === 60 || i % 100 === 80))\n                    return Plural.Few;\n                if (!(v === 0))\n                    return Plural.Many;\n                return Plural.Other;\n            case 'he':\n                if (i === 1 && v === 0)\n                    return Plural.One;\n                if (i === 2 && v === 0)\n                    return Plural.Two;\n                if (v === 0 && !(n >= 0 && n <= 10) && n % 10 === 0)\n                    return Plural.Many;\n                return Plural.Other;\n            case 'is':\n                if (t === 0 && i % 10 === 1 && !(i % 100 === 11) || !(t === 0))\n                    return Plural.One;\n                return Plural.Other;\n            case 'ksh':\n                if (n === 0)\n                    return Plural.Zero;\n                if (n === 1)\n                    return Plural.One;\n                return Plural.Other;\n            case 'kw':\n            case 'naq':\n            case 'se':\n            case 'smn':\n                if (n === 1)\n                    return Plural.One;\n                if (n === 2)\n                    return Plural.Two;\n                return Plural.Other;\n            case 'lag':\n                if (n === 0)\n                    return Plural.Zero;\n                if ((i === 0 || i === 1) && !(n === 0))\n                    return Plural.One;\n                return Plural.Other;\n            case 'lt':\n                if (n % 10 === 1 && !(n % 100 >= 11 && n % 100 <= 19))\n                    return Plural.One;\n                if (n % 10 === Math.floor(n % 10) && n % 10 >= 2 && n % 10 <= 9 &&\n                    !(n % 100 >= 11 && n % 100 <= 19))\n                    return Plural.Few;\n                if (!(f === 0))\n                    return Plural.Many;\n                return Plural.Other;\n            case 'lv':\n            case 'prg':\n                if (n % 10 === 0 || n % 100 === Math.floor(n % 100) && n % 100 >= 11 && n % 100 <= 19 ||\n                    v === 2 && f % 100 === Math.floor(f % 100) && f % 100 >= 11 && f % 100 <= 19)\n                    return Plural.Zero;\n                if (n % 10 === 1 && !(n % 100 === 11) || v === 2 && f % 10 === 1 && !(f % 100 === 11) ||\n                    !(v === 2) && f % 10 === 1)\n                    return Plural.One;\n                return Plural.Other;\n            case 'mk':\n                if (v === 0 && i % 10 === 1 || f % 10 === 1)\n                    return Plural.One;\n                return Plural.Other;\n            case 'mt':\n                if (n === 1)\n                    return Plural.One;\n                if (n === 0 || n % 100 === Math.floor(n % 100) && n % 100 >= 2 && n % 100 <= 10)\n                    return Plural.Few;\n                if (n % 100 === Math.floor(n % 100) && n % 100 >= 11 && n % 100 <= 19)\n                    return Plural.Many;\n                return Plural.Other;\n            case 'pl':\n                if (i === 1 && v === 0)\n                    return Plural.One;\n                if (v === 0 && i % 10 === Math.floor(i % 10) && i % 10 >= 2 && i % 10 <= 4 &&\n                    !(i % 100 >= 12 && i % 100 <= 14))\n                    return Plural.Few;\n                if (v === 0 && !(i === 1) && i % 10 === Math.floor(i % 10) && i % 10 >= 0 && i % 10 <= 1 ||\n                    v === 0 && i % 10 === Math.floor(i % 10) && i % 10 >= 5 && i % 10 <= 9 ||\n                    v === 0 && i % 100 === Math.floor(i % 100) && i % 100 >= 12 && i % 100 <= 14)\n                    return Plural.Many;\n                return Plural.Other;\n            case 'pt':\n                if (n === Math.floor(n) && n >= 0 && n <= 2 && !(n === 2))\n                    return Plural.One;\n                return Plural.Other;\n            case 'ro':\n                if (i === 1 && v === 0)\n                    return Plural.One;\n                if (!(v === 0) || n === 0 ||\n                    !(n === 1) && n % 100 === Math.floor(n % 100) && n % 100 >= 1 && n % 100 <= 19)\n                    return Plural.Few;\n                return Plural.Other;\n            case 'ru':\n            case 'uk':\n                if (v === 0 && i % 10 === 1 && !(i % 100 === 11))\n                    return Plural.One;\n                if (v === 0 && i % 10 === Math.floor(i % 10) && i % 10 >= 2 && i % 10 <= 4 &&\n                    !(i % 100 >= 12 && i % 100 <= 14))\n                    return Plural.Few;\n                if (v === 0 && i % 10 === 0 ||\n                    v === 0 && i % 10 === Math.floor(i % 10) && i % 10 >= 5 && i % 10 <= 9 ||\n                    v === 0 && i % 100 === Math.floor(i % 100) && i % 100 >= 11 && i % 100 <= 14)\n                    return Plural.Many;\n                return Plural.Other;\n            case 'shi':\n                if (i === 0 || n === 1)\n                    return Plural.One;\n                if (n === Math.floor(n) && n >= 2 && n <= 10)\n                    return Plural.Few;\n                return Plural.Other;\n            case 'si':\n                if (n === 0 || n === 1 || i === 0 && f === 1)\n                    return Plural.One;\n                return Plural.Other;\n            case 'sl':\n                if (v === 0 && i % 100 === 1)\n                    return Plural.One;\n                if (v === 0 && i % 100 === 2)\n                    return Plural.Two;\n                if (v === 0 && i % 100 === Math.floor(i % 100) && i % 100 >= 3 && i % 100 <= 4 || !(v === 0))\n                    return Plural.Few;\n                return Plural.Other;\n            case 'tzm':\n                if (n === Math.floor(n) && n >= 0 && n <= 1 || n === Math.floor(n) && n >= 11 && n <= 99)\n                    return Plural.One;\n                return Plural.Other;\n            default:\n                return Plural.Other;\n        }\n    }\n\n    var _clearValues = (function () {\n        if ((new Map()).keys().next) {\n            return function _clearValues(m) {\n                var keyIterator = m.keys();\n                var k;\n                while (!((k = keyIterator.next()).done)) {\n                    m.set(k.value, null);\n                }\n            };\n        }\n        else {\n            return function _clearValuesWithForeEach(m) {\n                m.forEach(function (v, k) { m.set(k, null); });\n            };\n        }\n    })();\n    // Safari doesn't implement MapIterator.next(), which is used is Traceur's polyfill of Array.from\n    // TODO(mlaval): remove the work around once we have a working polyfill of Array.from\n    var _arrayFromMap = (function () {\n        try {\n            if ((new Map()).values().next) {\n                return function createArrayFromMap(m, getValues) {\n                    return getValues ? Array.from(m.values()) : Array.from(m.keys());\n                };\n            }\n        }\n        catch (e) {\n        }\n        return function createArrayFromMapWithForeach(m, getValues) {\n            var res = new Array(m.size), i = 0;\n            m.forEach(function (v, k) {\n                res[i] = getValues ? v : k;\n                i++;\n            });\n            return res;\n        };\n    })();\n    var ListWrapper = (function () {\n        function ListWrapper() {\n        }\n        // JS has no way to express a statically fixed size list, but dart does so we\n        // keep both methods.\n        ListWrapper.createFixedSize = function (size) { return new Array(size); };\n        ListWrapper.createGrowableSize = function (size) { return new Array(size); };\n        ListWrapper.clone = function (array) { return array.slice(0); };\n        ListWrapper.forEachWithIndex = function (array, fn) {\n            for (var i = 0; i < array.length; i++) {\n                fn(array[i], i);\n            }\n        };\n        ListWrapper.first = function (array) {\n            if (!array)\n                return null;\n            return array[0];\n        };\n        ListWrapper.last = function (array) {\n            if (!array || array.length == 0)\n                return null;\n            return array[array.length - 1];\n        };\n        ListWrapper.indexOf = function (array, value, startIndex) {\n            if (startIndex === void 0) { startIndex = 0; }\n            return array.indexOf(value, startIndex);\n        };\n        ListWrapper.contains = function (list, el) { return list.indexOf(el) !== -1; };\n        ListWrapper.reversed = function (array) {\n            var a = ListWrapper.clone(array);\n            return a.reverse();\n        };\n        ListWrapper.concat = function (a, b) { return a.concat(b); };\n        ListWrapper.insert = function (list, index, value) { list.splice(index, 0, value); };\n        ListWrapper.removeAt = function (list, index) {\n            var res = list[index];\n            list.splice(index, 1);\n            return res;\n        };\n        ListWrapper.removeAll = function (list, items) {\n            for (var i = 0; i < items.length; ++i) {\n                var index = list.indexOf(items[i]);\n                list.splice(index, 1);\n            }\n        };\n        ListWrapper.remove = function (list, el) {\n            var index = list.indexOf(el);\n            if (index > -1) {\n                list.splice(index, 1);\n                return true;\n            }\n            return false;\n        };\n        ListWrapper.clear = function (list) { list.length = 0; };\n        ListWrapper.isEmpty = function (list) { return list.length == 0; };\n        ListWrapper.fill = function (list, value, start, end) {\n            if (start === void 0) { start = 0; }\n            if (end === void 0) { end = null; }\n            list.fill(value, start, end === null ? list.length : end);\n        };\n        ListWrapper.equals = function (a, b) {\n            if (a.length != b.length)\n                return false;\n            for (var i = 0; i < a.length; ++i) {\n                if (a[i] !== b[i])\n                    return false;\n            }\n            return true;\n        };\n        ListWrapper.slice = function (l, from, to) {\n            if (from === void 0) { from = 0; }\n            if (to === void 0) { to = null; }\n            return l.slice(from, to === null ? undefined : to);\n        };\n        ListWrapper.splice = function (l, from, length) { return l.splice(from, length); };\n        ListWrapper.sort = function (l, compareFn) {\n            if (isPresent(compareFn)) {\n                l.sort(compareFn);\n            }\n            else {\n                l.sort();\n            }\n        };\n        ListWrapper.toString = function (l) { return l.toString(); };\n        ListWrapper.toJSON = function (l) { return JSON.stringify(l); };\n        ListWrapper.maximum = function (list, predicate) {\n            if (list.length == 0) {\n                return null;\n            }\n            var solution = null;\n            var maxValue = -Infinity;\n            for (var index = 0; index < list.length; index++) {\n                var candidate = list[index];\n                if (isBlank(candidate)) {\n                    continue;\n                }\n                var candidateValue = predicate(candidate);\n                if (candidateValue > maxValue) {\n                    solution = candidate;\n                    maxValue = candidateValue;\n                }\n            }\n            return solution;\n        };\n        ListWrapper.flatten = function (list) {\n            var target = [];\n            _flattenArray(list, target);\n            return target;\n        };\n        ListWrapper.addAll = function (list, source) {\n            for (var i = 0; i < source.length; i++) {\n                list.push(source[i]);\n            }\n        };\n        return ListWrapper;\n    }());\n    function _flattenArray(source, target) {\n        if (isPresent(source)) {\n            for (var i = 0; i < source.length; i++) {\n                var item = source[i];\n                if (isArray(item)) {\n                    _flattenArray(item, target);\n                }\n                else {\n                    target.push(item);\n                }\n            }\n        }\n        return target;\n    }\n    function isListLikeIterable(obj) {\n        if (!isJsObject(obj))\n            return false;\n        return isArray(obj) ||\n            (!(obj instanceof Map) &&\n                getSymbolIterator() in obj); // JS Iterable have a Symbol.iterator prop\n    }\n\n    /**\n     * @ngModule CommonModule\n     *\n     * @whatItDoes Adds and removes CSS classes on an HTML element.\n     *\n     * @howToUse\n     * ```\n     *     <some-element [ngClass]=\"'first second'\">...</some-element>\n     *\n     *     <some-element [ngClass]=\"['first', 'second']\">...</some-element>\n     *\n     *     <some-element [ngClass]=\"{'first': true, 'second': true, 'third': false}\">...</some-element>\n     *\n     *     <some-element [ngClass]=\"stringExp|arrayExp|objExp\">...</some-element>\n     * ```\n     *\n     * @description\n     *\n     * The CSS classes are updated as follow depending on the type of the expression evaluation:\n     * - `string` - the CSS classes listed in a string (space delimited) are added,\n     * - `Array` - the CSS classes (Array elements) are added,\n     * - `Object` - keys are CSS class names that get added when the expression given in the value\n     *              evaluates to a truthy value, otherwise class are removed.\n     *\n     * @stable\n     */\n    var NgClass = (function () {\n        function NgClass(_iterableDiffers, _keyValueDiffers, _ngEl, _renderer) {\n            this._iterableDiffers = _iterableDiffers;\n            this._keyValueDiffers = _keyValueDiffers;\n            this._ngEl = _ngEl;\n            this._renderer = _renderer;\n            this._initialClasses = [];\n        }\n        Object.defineProperty(NgClass.prototype, \"klass\", {\n            set: function (v) {\n                this._applyInitialClasses(true);\n                this._initialClasses = typeof v === 'string' ? v.split(/\\s+/) : [];\n                this._applyInitialClasses(false);\n                this._applyClasses(this._rawClass, false);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(NgClass.prototype, \"ngClass\", {\n            set: function (v) {\n                this._cleanupClasses(this._rawClass);\n                this._iterableDiffer = null;\n                this._keyValueDiffer = null;\n                this._rawClass = typeof v === 'string' ? v.split(/\\s+/) : v;\n                if (this._rawClass) {\n                    if (isListLikeIterable(this._rawClass)) {\n                        this._iterableDiffer = this._iterableDiffers.find(this._rawClass).create(null);\n                    }\n                    else {\n                        this._keyValueDiffer = this._keyValueDiffers.find(this._rawClass).create(null);\n                    }\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        NgClass.prototype.ngDoCheck = function () {\n            if (this._iterableDiffer) {\n                var changes = this._iterableDiffer.diff(this._rawClass);\n                if (changes) {\n                    this._applyIterableChanges(changes);\n                }\n            }\n            else if (this._keyValueDiffer) {\n                var changes = this._keyValueDiffer.diff(this._rawClass);\n                if (changes) {\n                    this._applyKeyValueChanges(changes);\n                }\n            }\n        };\n        NgClass.prototype._cleanupClasses = function (rawClassVal) {\n            this._applyClasses(rawClassVal, true);\n            this._applyInitialClasses(false);\n        };\n        NgClass.prototype._applyKeyValueChanges = function (changes) {\n            var _this = this;\n            changes.forEachAddedItem(function (record) { return _this._toggleClass(record.key, record.currentValue); });\n            changes.forEachChangedItem(function (record) { return _this._toggleClass(record.key, record.currentValue); });\n            changes.forEachRemovedItem(function (record) {\n                if (record.previousValue) {\n                    _this._toggleClass(record.key, false);\n                }\n            });\n        };\n        NgClass.prototype._applyIterableChanges = function (changes) {\n            var _this = this;\n            changes.forEachAddedItem(function (record) { return _this._toggleClass(record.item, true); });\n            changes.forEachRemovedItem(function (record) { return _this._toggleClass(record.item, false); });\n        };\n        NgClass.prototype._applyInitialClasses = function (isCleanup) {\n            var _this = this;\n            this._initialClasses.forEach(function (klass) { return _this._toggleClass(klass, !isCleanup); });\n        };\n        NgClass.prototype._applyClasses = function (rawClassVal, isCleanup) {\n            var _this = this;\n            if (rawClassVal) {\n                if (Array.isArray(rawClassVal) || rawClassVal instanceof Set) {\n                    rawClassVal.forEach(function (klass) { return _this._toggleClass(klass, !isCleanup); });\n                }\n                else {\n                    Object.keys(rawClassVal).forEach(function (klass) {\n                        if (isPresent(rawClassVal[klass]))\n                            _this._toggleClass(klass, !isCleanup);\n                    });\n                }\n            }\n        };\n        NgClass.prototype._toggleClass = function (klass, enabled) {\n            var _this = this;\n            klass = klass.trim();\n            if (klass) {\n                klass.split(/\\s+/g).forEach(function (klass) { _this._renderer.setElementClass(_this._ngEl.nativeElement, klass, enabled); });\n            }\n        };\n        NgClass.decorators = [\n            { type: _angular_core.Directive, args: [{ selector: '[ngClass]' },] },\n        ];\n        /** @nocollapse */\n        NgClass.ctorParameters = [\n            { type: _angular_core.IterableDiffers, },\n            { type: _angular_core.KeyValueDiffers, },\n            { type: _angular_core.ElementRef, },\n            { type: _angular_core.Renderer, },\n        ];\n        NgClass.propDecorators = {\n            'klass': [{ type: _angular_core.Input, args: ['class',] },],\n            'ngClass': [{ type: _angular_core.Input },],\n        };\n        return NgClass;\n    }());\n\n    var NgForRow = (function () {\n        function NgForRow($implicit, index, count) {\n            this.$implicit = $implicit;\n            this.index = index;\n            this.count = count;\n        }\n        Object.defineProperty(NgForRow.prototype, \"first\", {\n            get: function () { return this.index === 0; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(NgForRow.prototype, \"last\", {\n            get: function () { return this.index === this.count - 1; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(NgForRow.prototype, \"even\", {\n            get: function () { return this.index % 2 === 0; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(NgForRow.prototype, \"odd\", {\n            get: function () { return !this.even; },\n            enumerable: true,\n            configurable: true\n        });\n        return NgForRow;\n    }());\n    /**\n     * The `NgFor` directive instantiates a template once per item from an iterable. The context for\n     * each instantiated template inherits from the outer context with the given loop variable set\n     * to the current item from the iterable.\n     *\n     * ### Local Variables\n     *\n     * `NgFor` provides several exported values that can be aliased to local variables:\n     *\n     * * `index` will be set to the current loop iteration for each template context.\n     * * `first` will be set to a boolean value indicating whether the item is the first one in the\n     *   iteration.\n     * * `last` will be set to a boolean value indicating whether the item is the last one in the\n     *   iteration.\n     * * `even` will be set to a boolean value indicating whether this item has an even index.\n     * * `odd` will be set to a boolean value indicating whether this item has an odd index.\n     *\n     * ### Change Propagation\n     *\n     * When the contents of the iterator changes, `NgFor` makes the corresponding changes to the DOM:\n     *\n     * * When an item is added, a new instance of the template is added to the DOM.\n     * * When an item is removed, its template instance is removed from the DOM.\n     * * When items are reordered, their respective templates are reordered in the DOM.\n     * * Otherwise, the DOM element for that item will remain the same.\n     *\n     * Angular uses object identity to track insertions and deletions within the iterator and reproduce\n     * those changes in the DOM. This has important implications for animations and any stateful\n     * controls\n     * (such as `<input>` elements which accept user input) that are present. Inserted rows can be\n     * animated in, deleted rows can be animated out, and unchanged rows retain any unsaved state such\n     * as user input.\n     *\n     * It is possible for the identities of elements in the iterator to change while the data does not.\n     * This can happen, for example, if the iterator produced from an RPC to the server, and that\n     * RPC is re-run. Even if the data hasn't changed, the second response will produce objects with\n     * different identities, and Angular will tear down the entire DOM and rebuild it (as if all old\n     * elements were deleted and all new elements inserted). This is an expensive operation and should\n     * be avoided if possible.\n     *\n     * To customize the default tracking algorithm, `NgFor` supports `trackBy` option.\n     * `trackBy` takes a function which has two arguments: `index` and `item`.\n     * If `trackBy` is given, Angular tracks changes by the return value of the function.\n     *\n     * ### Syntax\n     *\n     * - `<li *ngFor=\"let item of items; let i = index; trackBy: trackByFn\">...</li>`\n     * - `<li template=\"ngFor let item of items; let i = index; trackBy: trackByFn\">...</li>`\n     *\n     * With `<template>` element:\n     *\n     * ```\n     * <template ngFor let-item [ngForOf]=\"items\" let-i=\"index\" [ngForTrackBy]=\"trackByFn\">\n     *   <li>...</li>\n     * </template>\n     * ```\n     *\n     * ### Example\n     *\n     * See a [live demo](http://plnkr.co/edit/KVuXxDp0qinGDyo307QW?p=preview) for a more detailed\n     * example.\n     *\n     * @stable\n     */\n    var NgFor = (function () {\n        function NgFor(_viewContainer, _template, _differs, _cdr) {\n            this._viewContainer = _viewContainer;\n            this._template = _template;\n            this._differs = _differs;\n            this._cdr = _cdr;\n            this._differ = null;\n        }\n        Object.defineProperty(NgFor.prototype, \"ngForTemplate\", {\n            set: function (value) {\n                if (value) {\n                    this._template = value;\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        NgFor.prototype.ngOnChanges = function (changes) {\n            if ('ngForOf' in changes) {\n                // React on ngForOf changes only once all inputs have been initialized\n                var value = changes['ngForOf'].currentValue;\n                if (!this._differ && value) {\n                    try {\n                        this._differ = this._differs.find(value).create(this._cdr, this.ngForTrackBy);\n                    }\n                    catch (e) {\n                        throw new Error(\"Cannot find a differ supporting object '\" + value + \"' of type '\" + getTypeNameForDebugging(value) + \"'. NgFor only supports binding to Iterables such as Arrays.\");\n                    }\n                }\n            }\n        };\n        NgFor.prototype.ngDoCheck = function () {\n            if (this._differ) {\n                var changes = this._differ.diff(this.ngForOf);\n                if (changes)\n                    this._applyChanges(changes);\n            }\n        };\n        NgFor.prototype._applyChanges = function (changes) {\n            var _this = this;\n            var insertTuples = [];\n            changes.forEachOperation(function (item, adjustedPreviousIndex, currentIndex) {\n                if (item.previousIndex == null) {\n                    var view = _this._viewContainer.createEmbeddedView(_this._template, new NgForRow(null, null, null), currentIndex);\n                    var tuple = new RecordViewTuple(item, view);\n                    insertTuples.push(tuple);\n                }\n                else if (currentIndex == null) {\n                    _this._viewContainer.remove(adjustedPreviousIndex);\n                }\n                else {\n                    var view = _this._viewContainer.get(adjustedPreviousIndex);\n                    _this._viewContainer.move(view, currentIndex);\n                    var tuple = new RecordViewTuple(item, view);\n                    insertTuples.push(tuple);\n                }\n            });\n            for (var i = 0; i < insertTuples.length; i++) {\n                this._perViewChange(insertTuples[i].view, insertTuples[i].record);\n            }\n            for (var i = 0, ilen = this._viewContainer.length; i < ilen; i++) {\n                var viewRef = this._viewContainer.get(i);\n                viewRef.context.index = i;\n                viewRef.context.count = ilen;\n            }\n            changes.forEachIdentityChange(function (record) {\n                var viewRef = _this._viewContainer.get(record.currentIndex);\n                viewRef.context.$implicit = record.item;\n            });\n        };\n        NgFor.prototype._perViewChange = function (view, record) {\n            view.context.$implicit = record.item;\n        };\n        NgFor.decorators = [\n            { type: _angular_core.Directive, args: [{ selector: '[ngFor][ngForOf]' },] },\n        ];\n        /** @nocollapse */\n        NgFor.ctorParameters = [\n            { type: _angular_core.ViewContainerRef, },\n            { type: _angular_core.TemplateRef, },\n            { type: _angular_core.IterableDiffers, },\n            { type: _angular_core.ChangeDetectorRef, },\n        ];\n        NgFor.propDecorators = {\n            'ngForOf': [{ type: _angular_core.Input },],\n            'ngForTrackBy': [{ type: _angular_core.Input },],\n            'ngForTemplate': [{ type: _angular_core.Input },],\n        };\n        return NgFor;\n    }());\n    var RecordViewTuple = (function () {\n        function RecordViewTuple(record, view) {\n            this.record = record;\n            this.view = view;\n        }\n        return RecordViewTuple;\n    }());\n\n    /**\n     * Removes or recreates a portion of the DOM tree based on an {expression}.\n     *\n     * If the expression assigned to `ngIf` evaluates to a false value then the element\n     * is removed from the DOM, otherwise a clone of the element is reinserted into the DOM.\n     *\n     * ### Example ([live demo](http://plnkr.co/edit/fe0kgemFBtmQOY31b4tw?p=preview)):\n     *\n     * ```\n     * <div *ngIf=\"errorCount > 0\" class=\"error\">\n     *   <!-- Error message displayed when the errorCount property on the current context is greater\n     * than 0. -->\n     *   {{errorCount}} errors detected\n     * </div>\n     * ```\n     *\n     * ### Syntax\n     *\n     * - `<div *ngIf=\"condition\">...</div>`\n     * - `<div template=\"ngIf condition\">...</div>`\n     * - `<template [ngIf]=\"condition\"><div>...</div></template>`\n     *\n     * @stable\n     */\n    var NgIf = (function () {\n        function NgIf(_viewContainer, _template) {\n            this._viewContainer = _viewContainer;\n            this._template = _template;\n            this._hasView = false;\n        }\n        Object.defineProperty(NgIf.prototype, \"ngIf\", {\n            set: function (condition) {\n                if (condition && !this._hasView) {\n                    this._hasView = true;\n                    this._viewContainer.createEmbeddedView(this._template);\n                }\n                else if (!condition && this._hasView) {\n                    this._hasView = false;\n                    this._viewContainer.clear();\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        NgIf.decorators = [\n            { type: _angular_core.Directive, args: [{ selector: '[ngIf]' },] },\n        ];\n        /** @nocollapse */\n        NgIf.ctorParameters = [\n            { type: _angular_core.ViewContainerRef, },\n            { type: _angular_core.TemplateRef, },\n        ];\n        NgIf.propDecorators = {\n            'ngIf': [{ type: _angular_core.Input },],\n        };\n        return NgIf;\n    }());\n\n    var _CASE_DEFAULT = new Object();\n    var SwitchView = (function () {\n        function SwitchView(_viewContainerRef, _templateRef) {\n            this._viewContainerRef = _viewContainerRef;\n            this._templateRef = _templateRef;\n        }\n        SwitchView.prototype.create = function () { this._viewContainerRef.createEmbeddedView(this._templateRef); };\n        SwitchView.prototype.destroy = function () { this._viewContainerRef.clear(); };\n        return SwitchView;\n    }());\n    /**\n     * @ngModule CommonModule\n     *\n     * @whatItDoes Adds / removes DOM sub-trees when the nest match expressions matches the switch\n     *             expression.\n     *\n     * @howToUse\n     * ```\n     *     <container-element [ngSwitch]=\"switch_expression\">\n     *       <some-element *ngSwitchCase=\"match_expression_1\">...</some-element>\n     *       <some-element *ngSwitchCase=\"match_expression_2\">...</some-element>\n     *       <some-other-element *ngSwitchCase=\"match_expression_3\">...</some-other-element>\n     *       <ng-container *ngSwitchCase=\"match_expression_3\">\n     *         <!-- use a ng-container to group multiple root nodes -->\n     *         <inner-element></inner-element>\n     *         <inner-other-element></inner-other-element>\n     *       </ng-container>\n     *       <some-element *ngSwitchDefault>...</p>\n     *     </container-element>\n     * ```\n     * @description\n     *\n     * `NgSwitch` stamps out nested views when their match expression value matches the value of the\n     * switch expression.\n     *\n     * In other words:\n     * - you define a container element (where you place the directive with a switch expression on the\n     * `[ngSwitch]=\"...\"` attribute)\n     * - you define inner views inside the `NgSwitch` and place a `*ngSwitchCase` attribute on the view\n     * root elements.\n     *\n     * Elements within `NgSwitch` but outside of a `NgSwitchCase` or `NgSwitchDefault` directives will\n     * be\n     * preserved at the location.\n     *\n     * The `ngSwitchCase` directive informs the parent `NgSwitch` of which view to display when the\n     * expression is evaluated.\n     * When no matching expression is found on a `ngSwitchCase` view, the `ngSwitchDefault` view is\n     * stamped out.\n     *\n     * @stable\n     */\n    var NgSwitch = (function () {\n        function NgSwitch() {\n            this._useDefault = false;\n            this._valueViews = new Map();\n            this._activeViews = [];\n        }\n        Object.defineProperty(NgSwitch.prototype, \"ngSwitch\", {\n            set: function (value) {\n                // Empty the currently active ViewContainers\n                this._emptyAllActiveViews();\n                // Add the ViewContainers matching the value (with a fallback to default)\n                this._useDefault = false;\n                var views = this._valueViews.get(value);\n                if (!views) {\n                    this._useDefault = true;\n                    views = this._valueViews.get(_CASE_DEFAULT) || null;\n                }\n                this._activateViews(views);\n                this._switchValue = value;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /** @internal */\n        NgSwitch.prototype._onCaseValueChanged = function (oldCase, newCase, view) {\n            this._deregisterView(oldCase, view);\n            this._registerView(newCase, view);\n            if (oldCase === this._switchValue) {\n                view.destroy();\n                ListWrapper.remove(this._activeViews, view);\n            }\n            else if (newCase === this._switchValue) {\n                if (this._useDefault) {\n                    this._useDefault = false;\n                    this._emptyAllActiveViews();\n                }\n                view.create();\n                this._activeViews.push(view);\n            }\n            // Switch to default when there is no more active ViewContainers\n            if (this._activeViews.length === 0 && !this._useDefault) {\n                this._useDefault = true;\n                this._activateViews(this._valueViews.get(_CASE_DEFAULT));\n            }\n        };\n        NgSwitch.prototype._emptyAllActiveViews = function () {\n            var activeContainers = this._activeViews;\n            for (var i = 0; i < activeContainers.length; i++) {\n                activeContainers[i].destroy();\n            }\n            this._activeViews = [];\n        };\n        NgSwitch.prototype._activateViews = function (views) {\n            if (views) {\n                for (var i = 0; i < views.length; i++) {\n                    views[i].create();\n                }\n                this._activeViews = views;\n            }\n        };\n        /** @internal */\n        NgSwitch.prototype._registerView = function (value, view) {\n            var views = this._valueViews.get(value);\n            if (!views) {\n                views = [];\n                this._valueViews.set(value, views);\n            }\n            views.push(view);\n        };\n        NgSwitch.prototype._deregisterView = function (value, view) {\n            // `_CASE_DEFAULT` is used a marker for non-registered cases\n            if (value === _CASE_DEFAULT)\n                return;\n            var views = this._valueViews.get(value);\n            if (views.length == 1) {\n                this._valueViews.delete(value);\n            }\n            else {\n                ListWrapper.remove(views, view);\n            }\n        };\n        NgSwitch.decorators = [\n            { type: _angular_core.Directive, args: [{ selector: '[ngSwitch]' },] },\n        ];\n        /** @nocollapse */\n        NgSwitch.ctorParameters = [];\n        NgSwitch.propDecorators = {\n            'ngSwitch': [{ type: _angular_core.Input },],\n        };\n        return NgSwitch;\n    }());\n    /**\n     * @ngModule CommonModule\n     *\n     * @whatItDoes Creates a view that will be added/removed from the parent {@link NgSwitch} when the\n     *             given expression evaluate to respectively the same/different value as the switch\n     *             expression.\n     *\n     * @howToUse\n     * ```\n     * <container-element [ngSwitch]=\"switch_expression\">\n     *   <some-element *ngSwitchCase=\"match_expression_1\">...</some-element>\n     * </container-element>\n     *```\n     * @description\n     *\n     * Insert the sub-tree when the expression evaluates to the same value as the enclosing switch\n     * expression.\n     *\n     * If multiple match expressions match the switch expression value, all of them are displayed.\n     *\n     * See {@link NgSwitch} for more details and example.\n     *\n     * @stable\n     */\n    var NgSwitchCase = (function () {\n        function NgSwitchCase(viewContainer, templateRef, ngSwitch) {\n            // `_CASE_DEFAULT` is used as a marker for a not yet initialized value\n            this._value = _CASE_DEFAULT;\n            this._switch = ngSwitch;\n            this._view = new SwitchView(viewContainer, templateRef);\n        }\n        Object.defineProperty(NgSwitchCase.prototype, \"ngSwitchCase\", {\n            set: function (value) {\n                this._switch._onCaseValueChanged(this._value, value, this._view);\n                this._value = value;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        NgSwitchCase.decorators = [\n            { type: _angular_core.Directive, args: [{ selector: '[ngSwitchCase]' },] },\n        ];\n        /** @nocollapse */\n        NgSwitchCase.ctorParameters = [\n            { type: _angular_core.ViewContainerRef, },\n            { type: _angular_core.TemplateRef, },\n            { type: NgSwitch, decorators: [{ type: _angular_core.Host },] },\n        ];\n        NgSwitchCase.propDecorators = {\n            'ngSwitchCase': [{ type: _angular_core.Input },],\n        };\n        return NgSwitchCase;\n    }());\n    /**\n     * @ngModule CommonModule\n     * @whatItDoes Creates a view that is added to the parent {@link NgSwitch} when no case expressions\n     * match the\n     *             switch expression.\n     *\n     * @howToUse\n     * ```\n     * <container-element [ngSwitch]=\"switch_expression\">\n     *   <some-element *ngSwitchCase=\"match_expression_1\">...</some-element>\n     *   <some-other-element *ngSwitchDefault>...</some-other-element>\n     * </container-element>\n     * ```\n     *\n     * @description\n     *\n     * Insert the sub-tree when no case expressions evaluate to the same value as the enclosing switch\n     * expression.\n     *\n     * See {@link NgSwitch} for more details and example.\n     *\n     * @stable\n     */\n    var NgSwitchDefault = (function () {\n        function NgSwitchDefault(viewContainer, templateRef, sswitch) {\n            sswitch._registerView(_CASE_DEFAULT, new SwitchView(viewContainer, templateRef));\n        }\n        NgSwitchDefault.decorators = [\n            { type: _angular_core.Directive, args: [{ selector: '[ngSwitchDefault]' },] },\n        ];\n        /** @nocollapse */\n        NgSwitchDefault.ctorParameters = [\n            { type: _angular_core.ViewContainerRef, },\n            { type: _angular_core.TemplateRef, },\n            { type: NgSwitch, decorators: [{ type: _angular_core.Host },] },\n        ];\n        return NgSwitchDefault;\n    }());\n\n    /**\n     * @ngModule CommonModule\n     *\n     * @whatItDoes Adds / removes DOM sub-trees based on a numeric value. Tailored for pluralization.\n     *\n     * @howToUse\n     * ```\n     * <some-element [ngPlural]=\"value\">\n     *   <ng-container *ngPluralCase=\"'=0'\">there is nothing</ng-container>\n     *   <ng-container *ngPluralCase=\"'=1'\">there is one</ng-container>\n     *   <ng-container *ngPluralCase=\"'few'\">there are a few</ng-container>\n     *   <ng-container *ngPluralCase=\"'other'\">there are exactly #</ng-container>\n     * </some-element>\n     * ```\n     *\n     * @description\n     *\n     * Displays DOM sub-trees that match the switch expression value, or failing that, DOM sub-trees\n     * that match the switch expression's pluralization category.\n     *\n     * To use this directive you must provide a container element that sets the `[ngPlural]` attribute\n     * to a switch expression. Inner elements with a `[ngPluralCase]` will display based on their\n     * expression:\n     * - if `[ngPluralCase]` is set to a value starting with `=`, it will only display if the value\n     *   matches the switch expression exactly,\n     * - otherwise, the view will be treated as a \"category match\", and will only display if exact\n     *   value matches aren't found and the value maps to its category for the defined locale.\n     *\n     * See http://cldr.unicode.org/index/cldr-spec/plural-rules\n     *\n     * @experimental\n     */\n    var NgPlural = (function () {\n        function NgPlural(_localization) {\n            this._localization = _localization;\n            this._caseViews = {};\n        }\n        Object.defineProperty(NgPlural.prototype, \"ngPlural\", {\n            set: function (value) {\n                this._switchValue = value;\n                this._updateView();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        NgPlural.prototype.addCase = function (value, switchView) { this._caseViews[value] = switchView; };\n        NgPlural.prototype._updateView = function () {\n            this._clearViews();\n            var cases = Object.keys(this._caseViews);\n            var key = getPluralCategory(this._switchValue, cases, this._localization);\n            this._activateView(this._caseViews[key]);\n        };\n        NgPlural.prototype._clearViews = function () {\n            if (this._activeView)\n                this._activeView.destroy();\n        };\n        NgPlural.prototype._activateView = function (view) {\n            if (view) {\n                this._activeView = view;\n                this._activeView.create();\n            }\n        };\n        NgPlural.decorators = [\n            { type: _angular_core.Directive, args: [{ selector: '[ngPlural]' },] },\n        ];\n        /** @nocollapse */\n        NgPlural.ctorParameters = [\n            { type: NgLocalization, },\n        ];\n        NgPlural.propDecorators = {\n            'ngPlural': [{ type: _angular_core.Input },],\n        };\n        return NgPlural;\n    }());\n    /**\n     * @ngModule CommonModule\n     *\n     * @whatItDoes Creates a view that will be added/removed from the parent {@link NgPlural} when the\n     *             given expression matches the plural expression according to CLDR rules.\n     *\n     * @howToUse\n     * ```\n     * <some-element [ngPlural]=\"value\">\n     *   <ng-container *ngPluralCase=\"'=0'\">...</ng-container>\n     *   <ng-container *ngPluralCase=\"'other'\">...</ng-container>\n     * </some-element>\n     *```\n     *\n     * See {@link NgPlural} for more details and example.\n     *\n     * @experimental\n     */\n    var NgPluralCase = (function () {\n        function NgPluralCase(value, template, viewContainer, ngPlural) {\n            this.value = value;\n            ngPlural.addCase(value, new SwitchView(viewContainer, template));\n        }\n        NgPluralCase.decorators = [\n            { type: _angular_core.Directive, args: [{ selector: '[ngPluralCase]' },] },\n        ];\n        /** @nocollapse */\n        NgPluralCase.ctorParameters = [\n            { type: undefined, decorators: [{ type: _angular_core.Attribute, args: ['ngPluralCase',] },] },\n            { type: _angular_core.TemplateRef, },\n            { type: _angular_core.ViewContainerRef, },\n            { type: NgPlural, decorators: [{ type: _angular_core.Host },] },\n        ];\n        return NgPluralCase;\n    }());\n\n    /**\n     * @ngModule CommonModule\n     *\n     * @whatItDoes Update an HTML element styles.\n     *\n     * @howToUse\n     * ```\n     * <some-element [ngStyle]=\"{'font-style': styleExp}\">...</some-element>\n     *\n     * <some-element [ngStyle]=\"{'max-width.px': widthExp}\">...</some-element>\n     *\n     * <some-element [ngStyle]=\"objExp\">...</some-element>\n     * ```\n     *\n     * @description\n     *\n     * The styles are updated according to the value of the expression evaluation:\n     * - keys are style names with an option `.<unit>` suffix (ie 'top.px', 'font-style.em'),\n     * - values are the values assigned to those properties (expressed in the given unit).\n     *\n     * @stable\n     */\n    var NgStyle = (function () {\n        function NgStyle(_differs, _ngEl, _renderer) {\n            this._differs = _differs;\n            this._ngEl = _ngEl;\n            this._renderer = _renderer;\n        }\n        Object.defineProperty(NgStyle.prototype, \"ngStyle\", {\n            set: function (v) {\n                this._ngStyle = v;\n                if (!this._differ && v) {\n                    this._differ = this._differs.find(v).create(null);\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        NgStyle.prototype.ngDoCheck = function () {\n            if (this._differ) {\n                var changes = this._differ.diff(this._ngStyle);\n                if (changes) {\n                    this._applyChanges(changes);\n                }\n            }\n        };\n        NgStyle.prototype._applyChanges = function (changes) {\n            var _this = this;\n            changes.forEachRemovedItem(function (record) { return _this._setStyle(record.key, null); });\n            changes.forEachAddedItem(function (record) { return _this._setStyle(record.key, record.currentValue); });\n            changes.forEachChangedItem(function (record) { return _this._setStyle(record.key, record.currentValue); });\n        };\n        NgStyle.prototype._setStyle = function (nameAndUnit, value) {\n            var _a = nameAndUnit.split('.'), name = _a[0], unit = _a[1];\n            value = value !== null && value !== void (0) && unit ? \"\" + value + unit : value;\n            this._renderer.setElementStyle(this._ngEl.nativeElement, name, value);\n        };\n        NgStyle.decorators = [\n            { type: _angular_core.Directive, args: [{ selector: '[ngStyle]' },] },\n        ];\n        /** @nocollapse */\n        NgStyle.ctorParameters = [\n            { type: _angular_core.KeyValueDiffers, },\n            { type: _angular_core.ElementRef, },\n            { type: _angular_core.Renderer, },\n        ];\n        NgStyle.propDecorators = {\n            'ngStyle': [{ type: _angular_core.Input },],\n        };\n        return NgStyle;\n    }());\n\n    /**\n     * @ngModule CommonModule\n     *\n     * @whatItDoes Inserts an embedded view from a prepared `TemplateRef`\n     *\n     * @howToUse\n     * ```\n     * <template [ngTemplateOutlet]=\"templateRefExpression\"\n     *           [ngOutletContext]=\"objectExpression\">\n     * </template>\n     * ```\n     *\n     * @description\n     *\n     * You can attach a context object to the `EmbeddedViewRef` by setting `[ngOutletContext]`.\n     * `[ngOutletContext]` should be an object, the object's keys will be the local template variables\n     * available within the `TemplateRef`.\n     *\n     * Note: using the key `$implicit` in the context object will set it's value as default.\n     *\n     * @experimental\n     */\n    var NgTemplateOutlet = (function () {\n        function NgTemplateOutlet(_viewContainerRef) {\n            this._viewContainerRef = _viewContainerRef;\n        }\n        Object.defineProperty(NgTemplateOutlet.prototype, \"ngOutletContext\", {\n            set: function (context) { this._context = context; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(NgTemplateOutlet.prototype, \"ngTemplateOutlet\", {\n            set: function (templateRef) { this._templateRef = templateRef; },\n            enumerable: true,\n            configurable: true\n        });\n        NgTemplateOutlet.prototype.ngOnChanges = function (changes) {\n            if (this._viewRef) {\n                this._viewContainerRef.remove(this._viewContainerRef.indexOf(this._viewRef));\n            }\n            if (this._templateRef) {\n                this._viewRef = this._viewContainerRef.createEmbeddedView(this._templateRef, this._context);\n            }\n        };\n        NgTemplateOutlet.decorators = [\n            { type: _angular_core.Directive, args: [{ selector: '[ngTemplateOutlet]' },] },\n        ];\n        /** @nocollapse */\n        NgTemplateOutlet.ctorParameters = [\n            { type: _angular_core.ViewContainerRef, },\n        ];\n        NgTemplateOutlet.propDecorators = {\n            'ngOutletContext': [{ type: _angular_core.Input },],\n            'ngTemplateOutlet': [{ type: _angular_core.Input },],\n        };\n        return NgTemplateOutlet;\n    }());\n\n    /**\n     * A collection of Angular directives that are likely to be used in each and every Angular\n     * application.\n     */\n    var COMMON_DIRECTIVES = [\n        NgClass,\n        NgFor,\n        NgIf,\n        NgTemplateOutlet,\n        NgStyle,\n        NgSwitch,\n        NgSwitchCase,\n        NgSwitchDefault,\n        NgPlural,\n        NgPluralCase,\n    ];\n\n    var isPromise = _angular_core.__core_private__.isPromise;\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$4 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    /**\n     * @stable\n     */\n    var BaseError = (function (_super) {\n        __extends$4(BaseError, _super);\n        function BaseError(message) {\n            // Errors don't use current this, instead they create a new instance.\n            // We have to do forward all of our api to the nativeInstance.\n            var nativeError = _super.call(this, message);\n            this._nativeError = nativeError;\n        }\n        Object.defineProperty(BaseError.prototype, \"message\", {\n            get: function () { return this._nativeError.message; },\n            set: function (message) { this._nativeError.message = message; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(BaseError.prototype, \"name\", {\n            get: function () { return this._nativeError.name; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(BaseError.prototype, \"stack\", {\n            get: function () { return this._nativeError.stack; },\n            set: function (value) { this._nativeError.stack = value; },\n            enumerable: true,\n            configurable: true\n        });\n        BaseError.prototype.toString = function () { return this._nativeError.toString(); };\n        return BaseError;\n    }(Error));\n    /**\n     * @stable\n     */\n    var WrappedError = (function (_super) {\n        __extends$4(WrappedError, _super);\n        function WrappedError(message, error) {\n            _super.call(this, message + \" caused by: \" + (error instanceof Error ? error.message : error));\n            this.originalError = error;\n        }\n        Object.defineProperty(WrappedError.prototype, \"stack\", {\n            get: function () {\n                return (this.originalError instanceof Error ? this.originalError : this._nativeError)\n                    .stack;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        return WrappedError;\n    }(BaseError));\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$3 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    var InvalidPipeArgumentError = (function (_super) {\n        __extends$3(InvalidPipeArgumentError, _super);\n        function InvalidPipeArgumentError(type, value) {\n            _super.call(this, \"Invalid argument '\" + value + \"' for pipe '\" + stringify(type) + \"'\");\n        }\n        return InvalidPipeArgumentError;\n    }(BaseError));\n\n    var ObservableStrategy = (function () {\n        function ObservableStrategy() {\n        }\n        ObservableStrategy.prototype.createSubscription = function (async, updateLatestValue) {\n            return async.subscribe({ next: updateLatestValue, error: function (e) { throw e; } });\n        };\n        ObservableStrategy.prototype.dispose = function (subscription) { subscription.unsubscribe(); };\n        ObservableStrategy.prototype.onDestroy = function (subscription) { subscription.unsubscribe(); };\n        return ObservableStrategy;\n    }());\n    var PromiseStrategy = (function () {\n        function PromiseStrategy() {\n        }\n        PromiseStrategy.prototype.createSubscription = function (async, updateLatestValue) {\n            return async.then(updateLatestValue, function (e) { throw e; });\n        };\n        PromiseStrategy.prototype.dispose = function (subscription) { };\n        PromiseStrategy.prototype.onDestroy = function (subscription) { };\n        return PromiseStrategy;\n    }());\n    var _promiseStrategy = new PromiseStrategy();\n    var _observableStrategy = new ObservableStrategy();\n    /**\n     * @ngModule CommonModule\n     * @whatItDoes Unwraps a value from an asynchronous primitive.\n     * @howToUse `observable_or_promise_expression | async`\n     * @description\n     * The `async` pipe subscribes to an `Observable` or `Promise` and returns the latest value it has\n     * emitted. When a new value is emitted, the `async` pipe marks the component to be checked for\n     * changes. When the component gets destroyed, the `async` pipe unsubscribes automatically to avoid\n     * potential memory leaks.\n     *\n     *\n     * ## Examples\n     *\n     * This example binds a `Promise` to the view. Clicking the `Resolve` button resolves the\n     * promise.\n     *\n     * {@example common/pipes/ts/async_pipe.ts region='AsyncPipePromise'}\n     *\n     * It's also possible to use `async` with Observables. The example below binds the `time` Observable\n     * to the view. The Observable continuesly updates the view with the current time.\n     *\n     * {@example common/pipes/ts/async_pipe.ts region='AsyncPipeObservable'}\n     *\n     * @stable\n     */\n    var AsyncPipe = (function () {\n        function AsyncPipe(_ref) {\n            this._ref = _ref;\n            this._latestValue = null;\n            this._latestReturnedValue = null;\n            this._subscription = null;\n            this._obj = null;\n            this._strategy = null;\n        }\n        AsyncPipe.prototype.ngOnDestroy = function () {\n            if (this._subscription) {\n                this._dispose();\n            }\n        };\n        AsyncPipe.prototype.transform = function (obj) {\n            if (!this._obj) {\n                if (obj) {\n                    this._subscribe(obj);\n                }\n                this._latestReturnedValue = this._latestValue;\n                return this._latestValue;\n            }\n            if (obj !== this._obj) {\n                this._dispose();\n                return this.transform(obj);\n            }\n            if (this._latestValue === this._latestReturnedValue) {\n                return this._latestReturnedValue;\n            }\n            this._latestReturnedValue = this._latestValue;\n            return _angular_core.WrappedValue.wrap(this._latestValue);\n        };\n        AsyncPipe.prototype._subscribe = function (obj) {\n            var _this = this;\n            this._obj = obj;\n            this._strategy = this._selectStrategy(obj);\n            this._subscription = this._strategy.createSubscription(obj, function (value) { return _this._updateLatestValue(obj, value); });\n        };\n        AsyncPipe.prototype._selectStrategy = function (obj) {\n            if (isPromise(obj)) {\n                return _promiseStrategy;\n            }\n            if (obj.subscribe) {\n                return _observableStrategy;\n            }\n            throw new InvalidPipeArgumentError(AsyncPipe, obj);\n        };\n        AsyncPipe.prototype._dispose = function () {\n            this._strategy.dispose(this._subscription);\n            this._latestValue = null;\n            this._latestReturnedValue = null;\n            this._subscription = null;\n            this._obj = null;\n        };\n        AsyncPipe.prototype._updateLatestValue = function (async, value) {\n            if (async === this._obj) {\n                this._latestValue = value;\n                this._ref.markForCheck();\n            }\n        };\n        AsyncPipe.decorators = [\n            { type: _angular_core.Pipe, args: [{ name: 'async', pure: false },] },\n        ];\n        /** @nocollapse */\n        AsyncPipe.ctorParameters = [\n            { type: _angular_core.ChangeDetectorRef, },\n        ];\n        return AsyncPipe;\n    }());\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var NumberFormatStyle;\n    (function (NumberFormatStyle) {\n        NumberFormatStyle[NumberFormatStyle[\"Decimal\"] = 0] = \"Decimal\";\n        NumberFormatStyle[NumberFormatStyle[\"Percent\"] = 1] = \"Percent\";\n        NumberFormatStyle[NumberFormatStyle[\"Currency\"] = 2] = \"Currency\";\n    })(NumberFormatStyle || (NumberFormatStyle = {}));\n    var NumberFormatter = (function () {\n        function NumberFormatter() {\n        }\n        NumberFormatter.format = function (num, locale, style, _a) {\n            var _b = _a === void 0 ? {} : _a, minimumIntegerDigits = _b.minimumIntegerDigits, minimumFractionDigits = _b.minimumFractionDigits, maximumFractionDigits = _b.maximumFractionDigits, currency = _b.currency, _c = _b.currencyAsSymbol, currencyAsSymbol = _c === void 0 ? false : _c;\n            var options = {\n                minimumIntegerDigits: minimumIntegerDigits,\n                minimumFractionDigits: minimumFractionDigits,\n                maximumFractionDigits: maximumFractionDigits,\n                style: NumberFormatStyle[style].toLowerCase()\n            };\n            if (style == NumberFormatStyle.Currency) {\n                options.currency = currency;\n                options.currencyDisplay = currencyAsSymbol ? 'symbol' : 'code';\n            }\n            return new Intl.NumberFormat(locale, options).format(num);\n        };\n        return NumberFormatter;\n    }());\n    var DATE_FORMATS_SPLIT = /((?:[^yMLdHhmsazZEwGjJ']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|L+|d+|H+|h+|J+|j+|m+|s+|a|z|Z|G+|w+))(.*)/;\n    var PATTERN_ALIASES = {\n        yMMMdjms: datePartGetterFactory(combine([\n            digitCondition('year', 1),\n            nameCondition('month', 3),\n            digitCondition('day', 1),\n            digitCondition('hour', 1),\n            digitCondition('minute', 1),\n            digitCondition('second', 1),\n        ])),\n        yMdjm: datePartGetterFactory(combine([\n            digitCondition('year', 1), digitCondition('month', 1), digitCondition('day', 1),\n            digitCondition('hour', 1), digitCondition('minute', 1)\n        ])),\n        yMMMMEEEEd: datePartGetterFactory(combine([\n            digitCondition('year', 1), nameCondition('month', 4), nameCondition('weekday', 4),\n            digitCondition('day', 1)\n        ])),\n        yMMMMd: datePartGetterFactory(combine([digitCondition('year', 1), nameCondition('month', 4), digitCondition('day', 1)])),\n        yMMMd: datePartGetterFactory(combine([digitCondition('year', 1), nameCondition('month', 3), digitCondition('day', 1)])),\n        yMd: datePartGetterFactory(combine([digitCondition('year', 1), digitCondition('month', 1), digitCondition('day', 1)])),\n        jms: datePartGetterFactory(combine([digitCondition('hour', 1), digitCondition('second', 1), digitCondition('minute', 1)])),\n        jm: datePartGetterFactory(combine([digitCondition('hour', 1), digitCondition('minute', 1)]))\n    };\n    var DATE_FORMATS = {\n        yyyy: datePartGetterFactory(digitCondition('year', 4)),\n        yy: datePartGetterFactory(digitCondition('year', 2)),\n        y: datePartGetterFactory(digitCondition('year', 1)),\n        MMMM: datePartGetterFactory(nameCondition('month', 4)),\n        MMM: datePartGetterFactory(nameCondition('month', 3)),\n        MM: datePartGetterFactory(digitCondition('month', 2)),\n        M: datePartGetterFactory(digitCondition('month', 1)),\n        LLLL: datePartGetterFactory(nameCondition('month', 4)),\n        dd: datePartGetterFactory(digitCondition('day', 2)),\n        d: datePartGetterFactory(digitCondition('day', 1)),\n        HH: digitModifier(hourExtracter(datePartGetterFactory(hour12Modify(digitCondition('hour', 2), false)))),\n        H: hourExtracter(datePartGetterFactory(hour12Modify(digitCondition('hour', 1), false))),\n        hh: digitModifier(hourExtracter(datePartGetterFactory(hour12Modify(digitCondition('hour', 2), true)))),\n        h: hourExtracter(datePartGetterFactory(hour12Modify(digitCondition('hour', 1), true))),\n        jj: datePartGetterFactory(digitCondition('hour', 2)),\n        j: datePartGetterFactory(digitCondition('hour', 1)),\n        mm: digitModifier(datePartGetterFactory(digitCondition('minute', 2))),\n        m: datePartGetterFactory(digitCondition('minute', 1)),\n        ss: digitModifier(datePartGetterFactory(digitCondition('second', 2))),\n        s: datePartGetterFactory(digitCondition('second', 1)),\n        // while ISO 8601 requires fractions to be prefixed with `.` or `,`\n        // we can be just safely rely on using `sss` since we currently don't support single or two digit\n        // fractions\n        sss: datePartGetterFactory(digitCondition('second', 3)),\n        EEEE: datePartGetterFactory(nameCondition('weekday', 4)),\n        EEE: datePartGetterFactory(nameCondition('weekday', 3)),\n        EE: datePartGetterFactory(nameCondition('weekday', 2)),\n        E: datePartGetterFactory(nameCondition('weekday', 1)),\n        a: hourClockExtracter(datePartGetterFactory(hour12Modify(digitCondition('hour', 1), true))),\n        Z: timeZoneGetter('short'),\n        z: timeZoneGetter('long'),\n        ww: datePartGetterFactory({}),\n        // first Thursday of the year. not support ?\n        w: datePartGetterFactory({}),\n        // of the year not support ?\n        G: datePartGetterFactory(nameCondition('era', 1)),\n        GG: datePartGetterFactory(nameCondition('era', 2)),\n        GGG: datePartGetterFactory(nameCondition('era', 3)),\n        GGGG: datePartGetterFactory(nameCondition('era', 4))\n    };\n    function digitModifier(inner) {\n        return function (date, locale) {\n            var result = inner(date, locale);\n            return result.length == 1 ? '0' + result : result;\n        };\n    }\n    function hourClockExtracter(inner) {\n        return function (date, locale) {\n            var result = inner(date, locale);\n            return result.split(' ')[1];\n        };\n    }\n    function hourExtracter(inner) {\n        return function (date, locale) {\n            var result = inner(date, locale);\n            return result.split(' ')[0];\n        };\n    }\n    function intlDateFormat(date, locale, options) {\n        return new Intl.DateTimeFormat(locale, options).format(date).replace(/[\\u200e\\u200f]/g, '');\n    }\n    function timeZoneGetter(timezone) {\n        // To workaround `Intl` API restriction for single timezone let format with 24 hours\n        var options = { hour: '2-digit', hour12: false, timeZoneName: timezone };\n        return function (date, locale) {\n            var result = intlDateFormat(date, locale, options);\n            // Then extract first 3 letters that related to hours\n            return result ? result.substring(3) : '';\n        };\n    }\n    function hour12Modify(options, value) {\n        options.hour12 = value;\n        return options;\n    }\n    function digitCondition(prop, len) {\n        var result = {};\n        result[prop] = len == 2 ? '2-digit' : 'numeric';\n        return result;\n    }\n    function nameCondition(prop, len) {\n        var result = {};\n        result[prop] = len < 4 ? 'short' : 'long';\n        return result;\n    }\n    function combine(options) {\n        var result = {};\n        options.forEach(function (option) { Object.assign(result, option); });\n        return result;\n    }\n    function datePartGetterFactory(ret) {\n        return function (date, locale) { return intlDateFormat(date, locale, ret); };\n    }\n    var datePartsFormatterCache = new Map();\n    function dateFormatter(format, date, locale) {\n        var text = '';\n        var match;\n        var fn;\n        var parts = [];\n        if (PATTERN_ALIASES[format]) {\n            return PATTERN_ALIASES[format](date, locale);\n        }\n        if (datePartsFormatterCache.has(format)) {\n            parts = datePartsFormatterCache.get(format);\n        }\n        else {\n            var matches = DATE_FORMATS_SPLIT.exec(format);\n            while (format) {\n                match = DATE_FORMATS_SPLIT.exec(format);\n                if (match) {\n                    parts = concat(parts, match, 1);\n                    format = parts.pop();\n                }\n                else {\n                    parts.push(format);\n                    format = null;\n                }\n            }\n            datePartsFormatterCache.set(format, parts);\n        }\n        parts.forEach(function (part) {\n            fn = DATE_FORMATS[part];\n            text += fn ? fn(date, locale) :\n                part === '\\'\\'' ? '\\'' : part.replace(/(^'|'$)/g, '').replace(/''/g, '\\'');\n        });\n        return text;\n    }\n    var slice = [].slice;\n    function concat(array1 /** TODO #9100 */, array2 /** TODO #9100 */, index /** TODO #9100 */) {\n        return array1.concat(slice.call(array2, index));\n    }\n    var DateFormatter = (function () {\n        function DateFormatter() {\n        }\n        DateFormatter.format = function (date, locale, pattern) {\n            return dateFormatter(pattern, date, locale);\n        };\n        return DateFormatter;\n    }());\n\n    /**\n     * @ngModule CommonModule\n     * @whatItDoes Formats a date according to locale rules.\n     * @howToUse `date_expression | date[:format]`\n     * @description\n     *\n     * Where:\n     * - `expression` is a date object or a number (milliseconds since UTC epoch) or an ISO string\n     * (https://www.w3.org/TR/NOTE-datetime).\n     * - `format` indicates which date/time components to include. The format can be predifined as\n     *   shown below or custom as shown in the table.\n     *   - `'medium'`: equivalent to `'yMMMdjms'` (e.g. `Sep 3, 2010, 12:05:08 PM` for `en-US`)\n     *   - `'short'`: equivalent to `'yMdjm'` (e.g. `9/3/2010, 12:05 PM` for `en-US`)\n     *   - `'fullDate'`: equivalent to `'yMMMMEEEEd'` (e.g. `Friday, September 3, 2010` for `en-US`)\n     *   - `'longDate'`: equivalent to `'yMMMMd'` (e.g. `September 3, 2010` for `en-US`)\n     *   - `'mediumDate'`: equivalent to `'yMMMd'` (e.g. `Sep 3, 2010` for `en-US`)\n     *   - `'shortDate'`: equivalent to `'yMd'` (e.g. `9/3/2010` for `en-US`)\n     *   - `'mediumTime'`: equivalent to `'jms'` (e.g. `12:05:08 PM` for `en-US`)\n     *   - `'shortTime'`: equivalent to `'jm'` (e.g. `12:05 PM` for `en-US`)\n     *\n     *\n     *  | Component | Symbol | Short Form   | Long Form         | Numeric   | 2-digit   |\n     *  |-----------|:------:|--------------|-------------------|-----------|-----------|\n     *  | era       |   G    | G (AD)       | GGGG (Anno Domini)| -         | -         |\n     *  | year      |   y    | -            | -                 | y (2015)  | yy (15)   |\n     *  | month     |   M    | MMM (Sep)    | MMMM (September)  | M (9)     | MM (09)   |\n     *  | day       |   d    | -            | -                 | d (3)     | dd (03)   |\n     *  | weekday   |   E    | EEE (Sun)    | EEEE (Sunday)     | -         | -         |\n     *  | hour      |   j    | -            | -                 | j (13)    | jj (13)   |\n     *  | hour12    |   h    | -            | -                 | h (1 PM)  | hh (01 PM)|\n     *  | hour24    |   H    | -            | -                 | H (13)    | HH (13)   |\n     *  | minute    |   m    | -            | -                 | m (5)     | mm (05)   |\n     *  | second    |   s    | -            | -                 | s (9)     | ss (09)   |\n     *  | timezone  |   z    | -            | z (Pacific Standard Time)| -  | -         |\n     *  | timezone  |   Z    | Z (GMT-8:00) | -                 | -         | -         |\n     *  | timezone  |   a    | a (PM)       | -                 | -         | -         |\n     *\n     * In javascript, only the components specified will be respected (not the ordering,\n     * punctuations, ...) and details of the formatting will be dependent on the locale.\n     *\n     * Timezone of the formatted text will be the local system timezone of the end-user's machine.\n     *\n     * WARNINGS:\n     * - this pipe is marked as pure hence it will not be re-evaluated when the input is mutated.\n     *   Instead users should treat the date as an immutable object and change the reference when the\n     *   pipe needs to re-run (this is to avoid reformatting the date on every change detection run\n     *   which would be an expensive operation).\n     * - this pipe uses the Internationalization API. Therefore it is only reliable in Chrome and Opera\n     *   browsers.\n     *\n     * ### Examples\n     *\n     * Assuming `dateObj` is (year: 2015, month: 6, day: 15, hour: 21, minute: 43, second: 11)\n     * in the _local_ time and locale is 'en-US':\n     *\n     * ```\n     *     {{ dateObj | date }}               // output is 'Jun 15, 2015'\n     *     {{ dateObj | date:'medium' }}      // output is 'Jun 15, 2015, 9:43:11 PM'\n     *     {{ dateObj | date:'shortTime' }}   // output is '9:43 PM'\n     *     {{ dateObj | date:'mmss' }}        // output is '43:11'\n     * ```\n     *\n     * {@example common/pipes/ts/date_pipe.ts region='DatePipe'}\n     *\n     * @stable\n     */\n    var DatePipe = (function () {\n        function DatePipe(_locale) {\n            this._locale = _locale;\n        }\n        DatePipe.prototype.transform = function (value, pattern) {\n            if (pattern === void 0) { pattern = 'mediumDate'; }\n            if (isBlank(value))\n                return null;\n            if (!this.supports(value)) {\n                throw new InvalidPipeArgumentError(DatePipe, value);\n            }\n            if (NumberWrapper.isNumeric(value)) {\n                value = parseFloat(value);\n            }\n            return DateFormatter.format(new Date(value), this._locale, DatePipe._ALIASES[pattern] || pattern);\n        };\n        DatePipe.prototype.supports = function (obj) {\n            return isDate(obj) || NumberWrapper.isNumeric(obj) ||\n                (typeof obj === 'string' && isDate(new Date(obj)));\n        };\n        /** @internal */\n        DatePipe._ALIASES = {\n            'medium': 'yMMMdjms',\n            'short': 'yMdjm',\n            'fullDate': 'yMMMMEEEEd',\n            'longDate': 'yMMMMd',\n            'mediumDate': 'yMMMd',\n            'shortDate': 'yMd',\n            'mediumTime': 'jms',\n            'shortTime': 'jm'\n        };\n        DatePipe.decorators = [\n            { type: _angular_core.Pipe, args: [{ name: 'date', pure: true },] },\n        ];\n        /** @nocollapse */\n        DatePipe.ctorParameters = [\n            { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_core.LOCALE_ID,] },] },\n        ];\n        return DatePipe;\n    }());\n\n    var _INTERPOLATION_REGEXP = /#/g;\n    /**\n     * @ngModule CommonModule\n     * @whatItDoes Maps a value to a string that pluralizes the value according to locale rules.\n     * @howToUse `expression | i18nPlural:mapping`\n     * @description\n     *\n     *  Where:\n     *  - `expression` is a number.\n     *  - `mapping` is an object that mimics the ICU format, see\n     *    http://userguide.icu-project.org/formatparse/messages\n     *\n     *  ## Example\n     *\n     * {@example common/pipes/ts/i18n_pipe.ts region='I18nPluralPipeComponent'}\n     *\n     * @experimental\n     */\n    var I18nPluralPipe = (function () {\n        function I18nPluralPipe(_localization) {\n            this._localization = _localization;\n        }\n        I18nPluralPipe.prototype.transform = function (value, pluralMap) {\n            if (isBlank(value))\n                return '';\n            if (!isStringMap(pluralMap)) {\n                throw new InvalidPipeArgumentError(I18nPluralPipe, pluralMap);\n            }\n            var key = getPluralCategory(value, Object.keys(pluralMap), this._localization);\n            return pluralMap[key].replace(_INTERPOLATION_REGEXP, value.toString());\n        };\n        I18nPluralPipe.decorators = [\n            { type: _angular_core.Pipe, args: [{ name: 'i18nPlural', pure: true },] },\n        ];\n        /** @nocollapse */\n        I18nPluralPipe.ctorParameters = [\n            { type: NgLocalization, },\n        ];\n        return I18nPluralPipe;\n    }());\n\n    /**\n     * @ngModule CommonModule\n     * @whatItDoes Generic selector that displays the string that matches the current value.\n     * @howToUse `expression | i18nSelect:mapping`\n     * @description\n     *\n     *  Where:\n     *  - `mapping`: is an object that indicates the text that should be displayed\n     *  for different values of the provided `expression`.\n     *\n     *  ## Example\n     *\n     * {@example common/pipes/ts/i18n_pipe.ts region='I18nSelectPipeComponent'}\n     *\n     *  @experimental\n     */\n    var I18nSelectPipe = (function () {\n        function I18nSelectPipe() {\n        }\n        I18nSelectPipe.prototype.transform = function (value, mapping) {\n            if (isBlank(value))\n                return '';\n            if (!isStringMap(mapping)) {\n                throw new InvalidPipeArgumentError(I18nSelectPipe, mapping);\n            }\n            return mapping.hasOwnProperty(value) ? mapping[value] : '';\n        };\n        I18nSelectPipe.decorators = [\n            { type: _angular_core.Pipe, args: [{ name: 'i18nSelect', pure: true },] },\n        ];\n        /** @nocollapse */\n        I18nSelectPipe.ctorParameters = [];\n        return I18nSelectPipe;\n    }());\n\n    /**\n     * @ngModule CommonModule\n     * @whatItDoes Converts value into JSON string.\n     * @howToUse `expression | json`\n     * @description\n     *\n     * Converts value into string using `JSON.stringify`. Useful for debugging.\n     *\n     * ### Example\n     * {@example common/pipes/ts/json_pipe.ts region='JsonPipe'}\n     *\n     * @stable\n     */\n    var JsonPipe = (function () {\n        function JsonPipe() {\n        }\n        JsonPipe.prototype.transform = function (value) { return Json.stringify(value); };\n        JsonPipe.decorators = [\n            { type: _angular_core.Pipe, args: [{ name: 'json', pure: false },] },\n        ];\n        /** @nocollapse */\n        JsonPipe.ctorParameters = [];\n        return JsonPipe;\n    }());\n\n    /**\n     * @ngModule CommonModule\n     * @whatItDoes Transforms string to lowercase.\n     * @howToUse `expression | lowercase`\n     * @description\n     *\n     * Converts value into lowercase string using `String.prototype.toLowerCase()`.\n     *\n     * ### Example\n     *\n     * {@example common/pipes/ts/lowerupper_pipe.ts region='LowerUpperPipe'}\n     *\n     * @stable\n     */\n    var LowerCasePipe = (function () {\n        function LowerCasePipe() {\n        }\n        LowerCasePipe.prototype.transform = function (value) {\n            if (isBlank(value))\n                return value;\n            if (typeof value !== 'string') {\n                throw new InvalidPipeArgumentError(LowerCasePipe, value);\n            }\n            return value.toLowerCase();\n        };\n        LowerCasePipe.decorators = [\n            { type: _angular_core.Pipe, args: [{ name: 'lowercase' },] },\n        ];\n        /** @nocollapse */\n        LowerCasePipe.ctorParameters = [];\n        return LowerCasePipe;\n    }());\n\n    var _NUMBER_FORMAT_REGEXP = /^(\\d+)?\\.((\\d+)(-(\\d+))?)?$/;\n    function formatNumber(pipe, locale, value, style, digits, currency, currencyAsSymbol) {\n        if (currency === void 0) { currency = null; }\n        if (currencyAsSymbol === void 0) { currencyAsSymbol = false; }\n        if (isBlank(value))\n            return null;\n        // Convert strings to numbers\n        value = typeof value === 'string' && NumberWrapper.isNumeric(value) ? +value : value;\n        if (typeof value !== 'number') {\n            throw new InvalidPipeArgumentError(pipe, value);\n        }\n        var minInt;\n        var minFraction;\n        var maxFraction;\n        if (style !== NumberFormatStyle.Currency) {\n            // rely on Intl default for currency\n            minInt = 1;\n            minFraction = 0;\n            maxFraction = 3;\n        }\n        if (digits) {\n            var parts = digits.match(_NUMBER_FORMAT_REGEXP);\n            if (parts === null) {\n                throw new Error(digits + \" is not a valid digit info for number pipes\");\n            }\n            if (isPresent(parts[1])) {\n                minInt = NumberWrapper.parseIntAutoRadix(parts[1]);\n            }\n            if (isPresent(parts[3])) {\n                minFraction = NumberWrapper.parseIntAutoRadix(parts[3]);\n            }\n            if (isPresent(parts[5])) {\n                maxFraction = NumberWrapper.parseIntAutoRadix(parts[5]);\n            }\n        }\n        return NumberFormatter.format(value, locale, style, {\n            minimumIntegerDigits: minInt,\n            minimumFractionDigits: minFraction,\n            maximumFractionDigits: maxFraction,\n            currency: currency,\n            currencyAsSymbol: currencyAsSymbol,\n        });\n    }\n    /**\n     * @ngModule CommonModule\n     * @whatItDoes Formats a number according to locale rules.\n     * @howToUse `number_expression | number[:digitInfo]`\n     *\n     * Formats a number as text. Group sizing and separator and other locale-specific\n     * configurations are based on the active locale.\n     *\n     * where `expression` is a number:\n     *  - `digitInfo` is a `string` which has a following format: <br>\n     *     <code>{minIntegerDigits}.{minFractionDigits}-{maxFractionDigits}</code>\n     *   - `minIntegerDigits` is the minimum number of integer digits to use. Defaults to `1`.\n     *   - `minFractionDigits` is the minimum number of digits after fraction. Defaults to `0`.\n     *   - `maxFractionDigits` is the maximum number of digits after fraction. Defaults to `3`.\n     *\n     * For more information on the acceptable range for each of these numbers and other\n     * details see your native internationalization library.\n     *\n     * WARNING: this pipe uses the Internationalization API which is not yet available in all browsers\n     * and may require a polyfill. See {@linkDocs guide/browser-support} for details.\n     *\n     * ### Example\n     *\n     * {@example common/pipes/ts/number_pipe.ts region='NumberPipe'}\n     *\n     * @stable\n     */\n    var DecimalPipe = (function () {\n        function DecimalPipe(_locale) {\n            this._locale = _locale;\n        }\n        DecimalPipe.prototype.transform = function (value, digits) {\n            if (digits === void 0) { digits = null; }\n            return formatNumber(DecimalPipe, this._locale, value, NumberFormatStyle.Decimal, digits);\n        };\n        DecimalPipe.decorators = [\n            { type: _angular_core.Pipe, args: [{ name: 'number' },] },\n        ];\n        /** @nocollapse */\n        DecimalPipe.ctorParameters = [\n            { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_core.LOCALE_ID,] },] },\n        ];\n        return DecimalPipe;\n    }());\n    /**\n     * @ngModule CommonModule\n     * @whatItDoes Formats a number as a percentage according to locale rules.\n     * @howToUse `number_expression | percent[:digitInfo]`\n     *\n     * @description\n     *\n     * Formats a number as percentage.\n     *\n     * - `digitInfo` See {@link DecimalPipe} for detailed description.\n     *\n     * WARNING: this pipe uses the Internationalization API which is not yet available in all browsers\n     * and may require a polyfill. See {@linkDocs guide/browser-support} for details.\n     *\n     * ### Example\n     *\n     * {@example common/pipes/ts/number_pipe.ts region='PercentPipe'}\n     *\n     * @stable\n     */\n    var PercentPipe = (function () {\n        function PercentPipe(_locale) {\n            this._locale = _locale;\n        }\n        PercentPipe.prototype.transform = function (value, digits) {\n            if (digits === void 0) { digits = null; }\n            return formatNumber(PercentPipe, this._locale, value, NumberFormatStyle.Percent, digits);\n        };\n        PercentPipe.decorators = [\n            { type: _angular_core.Pipe, args: [{ name: 'percent' },] },\n        ];\n        /** @nocollapse */\n        PercentPipe.ctorParameters = [\n            { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_core.LOCALE_ID,] },] },\n        ];\n        return PercentPipe;\n    }());\n    /**\n     * @ngModule CommonModule\n     * @whatItDoes Formats a number as currency using locale rules.\n     * @howToUse `number_expression | currency[:currencyCode[:symbolDisplay[:digitInfo]]]`\n     * @description\n     *\n     * Use `currency` to format a number as currency.\n     *\n     * - `currencyCode` is the [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code, such\n     *    as `USD` for the US dollar and `EUR` for the euro.\n     * - `symbolDisplay` is a boolean indicating whether to use the currency symbol or code.\n     *   - `true`: use symbol (e.g. `$`).\n     *   - `false`(default): use code (e.g. `USD`).\n     * - `digitInfo` See {@link DecimalPipe} for detailed description.\n     *\n     * WARNING: this pipe uses the Internationalization API which is not yet available in all browsers\n     * and may require a polyfill. See {@linkDocs guide/browser-support} for details.\n     *\n     * ### Example\n     *\n     * {@example common/pipes/ts/number_pipe.ts region='CurrencyPipe'}\n     *\n     * @stable\n     */\n    var CurrencyPipe = (function () {\n        function CurrencyPipe(_locale) {\n            this._locale = _locale;\n        }\n        CurrencyPipe.prototype.transform = function (value, currencyCode, symbolDisplay, digits) {\n            if (currencyCode === void 0) { currencyCode = 'USD'; }\n            if (symbolDisplay === void 0) { symbolDisplay = false; }\n            if (digits === void 0) { digits = null; }\n            return formatNumber(CurrencyPipe, this._locale, value, NumberFormatStyle.Currency, digits, currencyCode, symbolDisplay);\n        };\n        CurrencyPipe.decorators = [\n            { type: _angular_core.Pipe, args: [{ name: 'currency' },] },\n        ];\n        /** @nocollapse */\n        CurrencyPipe.ctorParameters = [\n            { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_core.LOCALE_ID,] },] },\n        ];\n        return CurrencyPipe;\n    }());\n\n    /**\n     * @ngModule CommonModule\n     * @whatItDoes Creates a new List or String containing a subset (slice) of the elements.\n     * @howToUse `array_or_string_expression | slice:start[:end]`\n     * @description\n     *\n     * Where the input expression is a `List` or `String`, and:\n     * - `start`: The starting index of the subset to return.\n     *   - **a positive integer**: return the item at `start` index and all items after\n     *     in the list or string expression.\n     *   - **a negative integer**: return the item at `start` index from the end and all items after\n     *     in the list or string expression.\n     *   - **if positive and greater than the size of the expression**: return an empty list or string.\n     *   - **if negative and greater than the size of the expression**: return entire list or string.\n     * - `end`: The ending index of the subset to return.\n     *   - **omitted**: return all items until the end.\n     *   - **if positive**: return all items before `end` index of the list or string.\n     *   - **if negative**: return all items before `end` index from the end of the list or string.\n     *\n     * All behavior is based on the expected behavior of the JavaScript API `Array.prototype.slice()`\n     * and `String.prototype.slice()`.\n     *\n     * When operating on a [List], the returned list is always a copy even when all\n     * the elements are being returned.\n     *\n     * When operating on a blank value, the pipe returns the blank value.\n     *\n     * ## List Example\n     *\n     * This `ngFor` example:\n     *\n     * {@example common/pipes/ts/slice_pipe.ts region='SlicePipe_list'}\n     *\n     * produces the following:\n     *\n     *     <li>b</li>\n     *     <li>c</li>\n     *\n     * ## String Examples\n     *\n     * {@example common/pipes/ts/slice_pipe.ts region='SlicePipe_string'}\n     *\n     * @stable\n     */\n    var SlicePipe = (function () {\n        function SlicePipe() {\n        }\n        SlicePipe.prototype.transform = function (value, start, end) {\n            if (isBlank(value))\n                return value;\n            if (!this.supports(value)) {\n                throw new InvalidPipeArgumentError(SlicePipe, value);\n            }\n            return value.slice(start, end);\n        };\n        SlicePipe.prototype.supports = function (obj) { return typeof obj === 'string' || Array.isArray(obj); };\n        SlicePipe.decorators = [\n            { type: _angular_core.Pipe, args: [{ name: 'slice', pure: false },] },\n        ];\n        /** @nocollapse */\n        SlicePipe.ctorParameters = [];\n        return SlicePipe;\n    }());\n\n    /**\n     * @ngModule CommonModule\n     * @whatItDoes Transforms string to uppercase.\n     * @howToUse `expression | uppercase`\n     * @description\n     *\n     * Converts value into lowercase string using `String.prototype.toUpperCase()`.\n     *\n     * ### Example\n     *\n     * {@example common/pipes/ts/lowerupper_pipe.ts region='LowerUpperPipe'}\n     *\n     * @stable\n     */\n    var UpperCasePipe = (function () {\n        function UpperCasePipe() {\n        }\n        UpperCasePipe.prototype.transform = function (value) {\n            if (isBlank(value))\n                return value;\n            if (typeof value !== 'string') {\n                throw new InvalidPipeArgumentError(UpperCasePipe, value);\n            }\n            return value.toUpperCase();\n        };\n        UpperCasePipe.decorators = [\n            { type: _angular_core.Pipe, args: [{ name: 'uppercase' },] },\n        ];\n        /** @nocollapse */\n        UpperCasePipe.ctorParameters = [];\n        return UpperCasePipe;\n    }());\n\n    /**\n     * A collection of Angular pipes that are likely to be used in each and every application.\n     */\n    var COMMON_PIPES = [\n        AsyncPipe,\n        UpperCasePipe,\n        LowerCasePipe,\n        JsonPipe,\n        SlicePipe,\n        DecimalPipe,\n        PercentPipe,\n        CurrencyPipe,\n        DatePipe,\n        I18nPluralPipe,\n        I18nSelectPipe,\n    ];\n\n    // Note: This does not contain the location providers,\n    // as they need some platform specific implementations to work.\n    /**\n     * The module that includes all the basic Angular directives like {@link NgIf}, {@link NgFor}, ...\n     *\n     * @stable\n     */\n    var CommonModule = (function () {\n        function CommonModule() {\n        }\n        CommonModule.decorators = [\n            { type: _angular_core.NgModule, args: [{\n                        declarations: [COMMON_DIRECTIVES, COMMON_PIPES],\n                        exports: [COMMON_DIRECTIVES, COMMON_PIPES],\n                        providers: [\n                            { provide: NgLocalization, useClass: NgLocaleLocalization },\n                        ],\n                    },] },\n        ];\n        /** @nocollapse */\n        CommonModule.ctorParameters = [];\n        return CommonModule;\n    }());\n\n    exports.NgLocalization = NgLocalization;\n    exports.CommonModule = CommonModule;\n    exports.NgClass = NgClass;\n    exports.NgFor = NgFor;\n    exports.NgIf = NgIf;\n    exports.NgPlural = NgPlural;\n    exports.NgPluralCase = NgPluralCase;\n    exports.NgStyle = NgStyle;\n    exports.NgSwitch = NgSwitch;\n    exports.NgSwitchCase = NgSwitchCase;\n    exports.NgSwitchDefault = NgSwitchDefault;\n    exports.NgTemplateOutlet = NgTemplateOutlet;\n    exports.AsyncPipe = AsyncPipe;\n    exports.DatePipe = DatePipe;\n    exports.I18nPluralPipe = I18nPluralPipe;\n    exports.I18nSelectPipe = I18nSelectPipe;\n    exports.JsonPipe = JsonPipe;\n    exports.LowerCasePipe = LowerCasePipe;\n    exports.CurrencyPipe = CurrencyPipe;\n    exports.DecimalPipe = DecimalPipe;\n    exports.PercentPipe = PercentPipe;\n    exports.SlicePipe = SlicePipe;\n    exports.UpperCasePipe = UpperCasePipe;\n    exports.PlatformLocation = PlatformLocation;\n    exports.LocationStrategy = LocationStrategy;\n    exports.APP_BASE_HREF = APP_BASE_HREF;\n    exports.HashLocationStrategy = HashLocationStrategy;\n    exports.PathLocationStrategy = PathLocationStrategy;\n    exports.Location = Location;\n\n}));\n\n/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/@angular/common/bundles/common.umd.js\n ** module id = 22\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/@angular/common/bundles/common.umd.js?");

/***/ },
/* 23 */,
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(global) {/**\n * @license Angular v2.0.1\n * (c) 2010-2016 Google, Inc. https://angular.io/\n * License: MIT\n */\n(function (global, factory) {\n     true ? factory(exports, __webpack_require__(3), __webpack_require__(5), __webpack_require__(21)) :\n    typeof define === 'function' && define.amd ? define(['exports', '@angular/core', 'rxjs/Observable', '@angular/platform-browser'], factory) :\n    (factory((global.ng = global.ng || {}, global.ng.http = global.ng.http || {}),global.ng.core,global.Rx,global.ng.platformBrowser));\n}(this, function (exports,_angular_core,rxjs_Observable,_angular_platformBrowser) { 'use strict';\n\n    /**\n     * A backend for http that uses the `XMLHttpRequest` browser API.\n     *\n     * Take care not to evaluate this in non-browser contexts.\n     *\n     * @experimental\n     */\n    var BrowserXhr = (function () {\n        function BrowserXhr() {\n        }\n        BrowserXhr.prototype.build = function () { return (new XMLHttpRequest()); };\n        BrowserXhr.decorators = [\n            { type: _angular_core.Injectable },\n        ];\n        /** @nocollapse */\n        BrowserXhr.ctorParameters = [];\n        return BrowserXhr;\n    }());\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var globalScope;\n    if (typeof window === 'undefined') {\n        if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {\n            // TODO: Replace any with WorkerGlobalScope from lib.webworker.d.ts #3492\n            globalScope = self;\n        }\n        else {\n            globalScope = global;\n        }\n    }\n    else {\n        globalScope = window;\n    }\n    // Need to declare a new variable for global here since TypeScript\n    // exports the original value of the symbol.\n    var global$1 = globalScope;\n    // TODO: remove calls to assert in production environment\n    // Note: Can't just export this and import in in other files\n    // as `assert` is a reserved keyword in Dart\n    global$1.assert = function assert(condition) {\n        // TODO: to be fixed properly via #2830, noop for now\n    };\n    function isPresent(obj) {\n        return obj !== undefined && obj !== null;\n    }\n    function isBlank(obj) {\n        return obj === undefined || obj === null;\n    }\n    function isString(obj) {\n        return typeof obj === 'string';\n    }\n    function isArray(obj) {\n        return Array.isArray(obj);\n    }\n    var StringWrapper = (function () {\n        function StringWrapper() {\n        }\n        StringWrapper.fromCharCode = function (code) { return String.fromCharCode(code); };\n        StringWrapper.charCodeAt = function (s, index) { return s.charCodeAt(index); };\n        StringWrapper.split = function (s, regExp) { return s.split(regExp); };\n        StringWrapper.equals = function (s, s2) { return s === s2; };\n        StringWrapper.stripLeft = function (s, charVal) {\n            if (s && s.length) {\n                var pos = 0;\n                for (var i = 0; i < s.length; i++) {\n                    if (s[i] != charVal)\n                        break;\n                    pos++;\n                }\n                s = s.substring(pos);\n            }\n            return s;\n        };\n        StringWrapper.stripRight = function (s, charVal) {\n            if (s && s.length) {\n                var pos = s.length;\n                for (var i = s.length - 1; i >= 0; i--) {\n                    if (s[i] != charVal)\n                        break;\n                    pos--;\n                }\n                s = s.substring(0, pos);\n            }\n            return s;\n        };\n        StringWrapper.replace = function (s, from, replace) {\n            return s.replace(from, replace);\n        };\n        StringWrapper.replaceAll = function (s, from, replace) {\n            return s.replace(from, replace);\n        };\n        StringWrapper.slice = function (s, from, to) {\n            if (from === void 0) { from = 0; }\n            if (to === void 0) { to = null; }\n            return s.slice(from, to === null ? undefined : to);\n        };\n        StringWrapper.replaceAllMapped = function (s, from, cb) {\n            return s.replace(from, function () {\n                var matches = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    matches[_i - 0] = arguments[_i];\n                }\n                // Remove offset & string from the result array\n                matches.splice(-2, 2);\n                // The callback receives match, p1, ..., pn\n                return cb(matches);\n            });\n        };\n        StringWrapper.contains = function (s, substr) { return s.indexOf(substr) != -1; };\n        StringWrapper.compare = function (a, b) {\n            if (a < b) {\n                return -1;\n            }\n            else if (a > b) {\n                return 1;\n            }\n            else {\n                return 0;\n            }\n        };\n        return StringWrapper;\n    }());\n    var NumberWrapper = (function () {\n        function NumberWrapper() {\n        }\n        NumberWrapper.toFixed = function (n, fractionDigits) { return n.toFixed(fractionDigits); };\n        NumberWrapper.equal = function (a, b) { return a === b; };\n        NumberWrapper.parseIntAutoRadix = function (text) {\n            var result = parseInt(text);\n            if (isNaN(result)) {\n                throw new Error('Invalid integer literal when parsing ' + text);\n            }\n            return result;\n        };\n        NumberWrapper.parseInt = function (text, radix) {\n            if (radix == 10) {\n                if (/^(\\-|\\+)?[0-9]+$/.test(text)) {\n                    return parseInt(text, radix);\n                }\n            }\n            else if (radix == 16) {\n                if (/^(\\-|\\+)?[0-9ABCDEFabcdef]+$/.test(text)) {\n                    return parseInt(text, radix);\n                }\n            }\n            else {\n                var result = parseInt(text, radix);\n                if (!isNaN(result)) {\n                    return result;\n                }\n            }\n            throw new Error('Invalid integer literal when parsing ' + text + ' in base ' + radix);\n        };\n        Object.defineProperty(NumberWrapper, \"NaN\", {\n            get: function () { return NaN; },\n            enumerable: true,\n            configurable: true\n        });\n        NumberWrapper.isNumeric = function (value) { return !isNaN(value - parseFloat(value)); };\n        NumberWrapper.isNaN = function (value) { return isNaN(value); };\n        NumberWrapper.isInteger = function (value) { return Number.isInteger(value); };\n        return NumberWrapper;\n    }());\n    function isJsObject(o) {\n        return o !== null && (typeof o === 'function' || typeof o === 'object');\n    }\n    // Can't be all uppercase as our transpiler would think it is a special directive...\n    var Json = (function () {\n        function Json() {\n        }\n        Json.parse = function (s) { return global$1.JSON.parse(s); };\n        Json.stringify = function (data) {\n            // Dart doesn't take 3 arguments\n            return global$1.JSON.stringify(data, null, 2);\n        };\n        return Json;\n    }());\n    var _symbolIterator = null;\n    function getSymbolIterator() {\n        if (isBlank(_symbolIterator)) {\n            if (isPresent(globalScope.Symbol) && isPresent(Symbol.iterator)) {\n                _symbolIterator = Symbol.iterator;\n            }\n            else {\n                // es6-shim specific logic\n                var keys = Object.getOwnPropertyNames(Map.prototype);\n                for (var i = 0; i < keys.length; ++i) {\n                    var key = keys[i];\n                    if (key !== 'entries' && key !== 'size' &&\n                        Map.prototype[key] === Map.prototype['entries']) {\n                        _symbolIterator = key;\n                    }\n                }\n            }\n        }\n        return _symbolIterator;\n    }\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * Supported http methods.\n     * @experimental\n     */\n    exports.RequestMethod;\n    (function (RequestMethod) {\n        RequestMethod[RequestMethod[\"Get\"] = 0] = \"Get\";\n        RequestMethod[RequestMethod[\"Post\"] = 1] = \"Post\";\n        RequestMethod[RequestMethod[\"Put\"] = 2] = \"Put\";\n        RequestMethod[RequestMethod[\"Delete\"] = 3] = \"Delete\";\n        RequestMethod[RequestMethod[\"Options\"] = 4] = \"Options\";\n        RequestMethod[RequestMethod[\"Head\"] = 5] = \"Head\";\n        RequestMethod[RequestMethod[\"Patch\"] = 6] = \"Patch\";\n    })(exports.RequestMethod || (exports.RequestMethod = {}));\n    /**\n     * All possible states in which a connection can be, based on\n     * [States](http://www.w3.org/TR/XMLHttpRequest/#states) from the `XMLHttpRequest` spec, but with an\n     * additional \"CANCELLED\" state.\n     * @experimental\n     */\n    exports.ReadyState;\n    (function (ReadyState) {\n        ReadyState[ReadyState[\"Unsent\"] = 0] = \"Unsent\";\n        ReadyState[ReadyState[\"Open\"] = 1] = \"Open\";\n        ReadyState[ReadyState[\"HeadersReceived\"] = 2] = \"HeadersReceived\";\n        ReadyState[ReadyState[\"Loading\"] = 3] = \"Loading\";\n        ReadyState[ReadyState[\"Done\"] = 4] = \"Done\";\n        ReadyState[ReadyState[\"Cancelled\"] = 5] = \"Cancelled\";\n    })(exports.ReadyState || (exports.ReadyState = {}));\n    /**\n     * Acceptable response types to be associated with a {@link Response}, based on\n     * [ResponseType](https://fetch.spec.whatwg.org/#responsetype) from the Fetch spec.\n     * @experimental\n     */\n    exports.ResponseType;\n    (function (ResponseType) {\n        ResponseType[ResponseType[\"Basic\"] = 0] = \"Basic\";\n        ResponseType[ResponseType[\"Cors\"] = 1] = \"Cors\";\n        ResponseType[ResponseType[\"Default\"] = 2] = \"Default\";\n        ResponseType[ResponseType[\"Error\"] = 3] = \"Error\";\n        ResponseType[ResponseType[\"Opaque\"] = 4] = \"Opaque\";\n    })(exports.ResponseType || (exports.ResponseType = {}));\n    /**\n     * Supported content type to be automatically associated with a {@link Request}.\n     * @experimental\n     */\n    var ContentType;\n    (function (ContentType) {\n        ContentType[ContentType[\"NONE\"] = 0] = \"NONE\";\n        ContentType[ContentType[\"JSON\"] = 1] = \"JSON\";\n        ContentType[ContentType[\"FORM\"] = 2] = \"FORM\";\n        ContentType[ContentType[\"FORM_DATA\"] = 3] = \"FORM_DATA\";\n        ContentType[ContentType[\"TEXT\"] = 4] = \"TEXT\";\n        ContentType[ContentType[\"BLOB\"] = 5] = \"BLOB\";\n        ContentType[ContentType[\"ARRAY_BUFFER\"] = 6] = \"ARRAY_BUFFER\";\n    })(ContentType || (ContentType = {}));\n    /**\n     * Define which buffer to use to store the response\n     * @experimental\n     */\n    exports.ResponseContentType;\n    (function (ResponseContentType) {\n        ResponseContentType[ResponseContentType[\"Text\"] = 0] = \"Text\";\n        ResponseContentType[ResponseContentType[\"Json\"] = 1] = \"Json\";\n        ResponseContentType[ResponseContentType[\"ArrayBuffer\"] = 2] = \"ArrayBuffer\";\n        ResponseContentType[ResponseContentType[\"Blob\"] = 3] = \"Blob\";\n    })(exports.ResponseContentType || (exports.ResponseContentType = {}));\n\n    // Safari and Internet Explorer do not support the iterable parameter to the\n    // Map constructor.  We work around that by manually adding the items.\n    var createMapFromPairs = (function () {\n        try {\n            if (new Map([[1, 2]]).size === 1) {\n                return function createMapFromPairs(pairs) { return new Map(pairs); };\n            }\n        }\n        catch (e) {\n        }\n        return function createMapAndPopulateFromPairs(pairs) {\n            var map = new Map();\n            for (var i = 0; i < pairs.length; i++) {\n                var pair = pairs[i];\n                map.set(pair[0], pair[1]);\n            }\n            return map;\n        };\n    })();\n    var _clearValues = (function () {\n        if ((new Map()).keys().next) {\n            return function _clearValues(m) {\n                var keyIterator = m.keys();\n                var k;\n                while (!((k = keyIterator.next()).done)) {\n                    m.set(k.value, null);\n                }\n            };\n        }\n        else {\n            return function _clearValuesWithForeEach(m) {\n                m.forEach(function (v, k) { m.set(k, null); });\n            };\n        }\n    })();\n    // Safari doesn't implement MapIterator.next(), which is used is Traceur's polyfill of Array.from\n    // TODO(mlaval): remove the work around once we have a working polyfill of Array.from\n    var _arrayFromMap = (function () {\n        try {\n            if ((new Map()).values().next) {\n                return function createArrayFromMap(m, getValues) {\n                    return getValues ? Array.from(m.values()) : Array.from(m.keys());\n                };\n            }\n        }\n        catch (e) {\n        }\n        return function createArrayFromMapWithForeach(m, getValues) {\n            var res = new Array(m.size), i = 0;\n            m.forEach(function (v, k) {\n                res[i] = getValues ? v : k;\n                i++;\n            });\n            return res;\n        };\n    })();\n    var MapWrapper = (function () {\n        function MapWrapper() {\n        }\n        MapWrapper.createFromStringMap = function (stringMap) {\n            var result = new Map();\n            for (var prop in stringMap) {\n                result.set(prop, stringMap[prop]);\n            }\n            return result;\n        };\n        MapWrapper.toStringMap = function (m) {\n            var r = {};\n            m.forEach(function (v, k) { return r[k] = v; });\n            return r;\n        };\n        MapWrapper.createFromPairs = function (pairs) { return createMapFromPairs(pairs); };\n        MapWrapper.iterable = function (m) { return m; };\n        MapWrapper.keys = function (m) { return _arrayFromMap(m, false); };\n        MapWrapper.values = function (m) { return _arrayFromMap(m, true); };\n        return MapWrapper;\n    }());\n    /**\n     * Wraps Javascript Objects\n     */\n    var StringMapWrapper = (function () {\n        function StringMapWrapper() {\n        }\n        StringMapWrapper.get = function (map, key) {\n            return map.hasOwnProperty(key) ? map[key] : undefined;\n        };\n        StringMapWrapper.set = function (map, key, value) { map[key] = value; };\n        StringMapWrapper.keys = function (map) { return Object.keys(map); };\n        StringMapWrapper.values = function (map) {\n            return Object.keys(map).map(function (k) { return map[k]; });\n        };\n        StringMapWrapper.isEmpty = function (map) {\n            for (var prop in map) {\n                return false;\n            }\n            return true;\n        };\n        StringMapWrapper.forEach = function (map, callback) {\n            for (var _i = 0, _a = Object.keys(map); _i < _a.length; _i++) {\n                var k = _a[_i];\n                callback(map[k], k);\n            }\n        };\n        StringMapWrapper.merge = function (m1, m2) {\n            var m = {};\n            for (var _i = 0, _a = Object.keys(m1); _i < _a.length; _i++) {\n                var k = _a[_i];\n                m[k] = m1[k];\n            }\n            for (var _b = 0, _c = Object.keys(m2); _b < _c.length; _b++) {\n                var k = _c[_b];\n                m[k] = m2[k];\n            }\n            return m;\n        };\n        StringMapWrapper.equals = function (m1, m2) {\n            var k1 = Object.keys(m1);\n            var k2 = Object.keys(m2);\n            if (k1.length != k2.length) {\n                return false;\n            }\n            for (var i = 0; i < k1.length; i++) {\n                var key = k1[i];\n                if (m1[key] !== m2[key]) {\n                    return false;\n                }\n            }\n            return true;\n        };\n        return StringMapWrapper;\n    }());\n    var ListWrapper = (function () {\n        function ListWrapper() {\n        }\n        // JS has no way to express a statically fixed size list, but dart does so we\n        // keep both methods.\n        ListWrapper.createFixedSize = function (size) { return new Array(size); };\n        ListWrapper.createGrowableSize = function (size) { return new Array(size); };\n        ListWrapper.clone = function (array) { return array.slice(0); };\n        ListWrapper.forEachWithIndex = function (array, fn) {\n            for (var i = 0; i < array.length; i++) {\n                fn(array[i], i);\n            }\n        };\n        ListWrapper.first = function (array) {\n            if (!array)\n                return null;\n            return array[0];\n        };\n        ListWrapper.last = function (array) {\n            if (!array || array.length == 0)\n                return null;\n            return array[array.length - 1];\n        };\n        ListWrapper.indexOf = function (array, value, startIndex) {\n            if (startIndex === void 0) { startIndex = 0; }\n            return array.indexOf(value, startIndex);\n        };\n        ListWrapper.contains = function (list, el) { return list.indexOf(el) !== -1; };\n        ListWrapper.reversed = function (array) {\n            var a = ListWrapper.clone(array);\n            return a.reverse();\n        };\n        ListWrapper.concat = function (a, b) { return a.concat(b); };\n        ListWrapper.insert = function (list, index, value) { list.splice(index, 0, value); };\n        ListWrapper.removeAt = function (list, index) {\n            var res = list[index];\n            list.splice(index, 1);\n            return res;\n        };\n        ListWrapper.removeAll = function (list, items) {\n            for (var i = 0; i < items.length; ++i) {\n                var index = list.indexOf(items[i]);\n                list.splice(index, 1);\n            }\n        };\n        ListWrapper.remove = function (list, el) {\n            var index = list.indexOf(el);\n            if (index > -1) {\n                list.splice(index, 1);\n                return true;\n            }\n            return false;\n        };\n        ListWrapper.clear = function (list) { list.length = 0; };\n        ListWrapper.isEmpty = function (list) { return list.length == 0; };\n        ListWrapper.fill = function (list, value, start, end) {\n            if (start === void 0) { start = 0; }\n            if (end === void 0) { end = null; }\n            list.fill(value, start, end === null ? list.length : end);\n        };\n        ListWrapper.equals = function (a, b) {\n            if (a.length != b.length)\n                return false;\n            for (var i = 0; i < a.length; ++i) {\n                if (a[i] !== b[i])\n                    return false;\n            }\n            return true;\n        };\n        ListWrapper.slice = function (l, from, to) {\n            if (from === void 0) { from = 0; }\n            if (to === void 0) { to = null; }\n            return l.slice(from, to === null ? undefined : to);\n        };\n        ListWrapper.splice = function (l, from, length) { return l.splice(from, length); };\n        ListWrapper.sort = function (l, compareFn) {\n            if (isPresent(compareFn)) {\n                l.sort(compareFn);\n            }\n            else {\n                l.sort();\n            }\n        };\n        ListWrapper.toString = function (l) { return l.toString(); };\n        ListWrapper.toJSON = function (l) { return JSON.stringify(l); };\n        ListWrapper.maximum = function (list, predicate) {\n            if (list.length == 0) {\n                return null;\n            }\n            var solution = null;\n            var maxValue = -Infinity;\n            for (var index = 0; index < list.length; index++) {\n                var candidate = list[index];\n                if (isBlank(candidate)) {\n                    continue;\n                }\n                var candidateValue = predicate(candidate);\n                if (candidateValue > maxValue) {\n                    solution = candidate;\n                    maxValue = candidateValue;\n                }\n            }\n            return solution;\n        };\n        ListWrapper.flatten = function (list) {\n            var target = [];\n            _flattenArray(list, target);\n            return target;\n        };\n        ListWrapper.addAll = function (list, source) {\n            for (var i = 0; i < source.length; i++) {\n                list.push(source[i]);\n            }\n        };\n        return ListWrapper;\n    }());\n    function _flattenArray(source, target) {\n        if (isPresent(source)) {\n            for (var i = 0; i < source.length; i++) {\n                var item = source[i];\n                if (isArray(item)) {\n                    _flattenArray(item, target);\n                }\n                else {\n                    target.push(item);\n                }\n            }\n        }\n        return target;\n    }\n    function isListLikeIterable(obj) {\n        if (!isJsObject(obj))\n            return false;\n        return isArray(obj) ||\n            (!(obj instanceof Map) &&\n                getSymbolIterator() in obj); // JS Iterable have a Symbol.iterator prop\n    }\n    function iterateListLike(obj, fn) {\n        if (isArray(obj)) {\n            for (var i = 0; i < obj.length; i++) {\n                fn(obj[i]);\n            }\n        }\n        else {\n            var iterator = obj[getSymbolIterator()]();\n            var item;\n            while (!((item = iterator.next()).done)) {\n                fn(item.value);\n            }\n        }\n    }\n\n    /**\n     * Polyfill for [Headers](https://developer.mozilla.org/en-US/docs/Web/API/Headers/Headers), as\n     * specified in the [Fetch Spec](https://fetch.spec.whatwg.org/#headers-class).\n     *\n     * The only known difference between this `Headers` implementation and the spec is the\n     * lack of an `entries` method.\n     *\n     * ### Example ([live demo](http://plnkr.co/edit/MTdwT6?p=preview))\n     *\n     * ```\n     * import {Headers} from '@angular/http';\n     *\n     * var firstHeaders = new Headers();\n     * firstHeaders.append('Content-Type', 'image/jpeg');\n     * console.log(firstHeaders.get('Content-Type')) //'image/jpeg'\n     *\n     * // Create headers from Plain Old JavaScript Object\n     * var secondHeaders = new Headers({\n     *   'X-My-Custom-Header': 'Angular'\n     * });\n     * console.log(secondHeaders.get('X-My-Custom-Header')); //'Angular'\n     *\n     * var thirdHeaders = new Headers(secondHeaders);\n     * console.log(thirdHeaders.get('X-My-Custom-Header')); //'Angular'\n     * ```\n     *\n     * @experimental\n     */\n    var Headers = (function () {\n        function Headers(headers) {\n            var _this = this;\n            if (headers instanceof Headers) {\n                this._headersMap = new Map(headers._headersMap);\n                return;\n            }\n            this._headersMap = new Map();\n            if (isBlank(headers)) {\n                return;\n            }\n            // headers instanceof StringMap\n            StringMapWrapper.forEach(headers, function (v, k) {\n                _this._headersMap.set(normalize(k), isListLikeIterable(v) ? v : [v]);\n            });\n        }\n        /**\n         * Returns a new Headers instance from the given DOMString of Response Headers\n         */\n        Headers.fromResponseHeaderString = function (headersString) {\n            var headers = new Headers();\n            headersString.split('\\n').forEach(function (line) {\n                var index = line.indexOf(':');\n                if (index > 0) {\n                    var key = line.substring(0, index);\n                    var value = line.substring(index + 1).trim();\n                    headers.set(key, value);\n                }\n            });\n            return headers;\n        };\n        /**\n         * Appends a header to existing list of header values for a given header name.\n         */\n        Headers.prototype.append = function (name, value) {\n            name = normalize(name);\n            var mapName = this._headersMap.get(name);\n            var list = isListLikeIterable(mapName) ? mapName : [];\n            list.push(value);\n            this._headersMap.set(name, list);\n        };\n        /**\n         * Deletes all header values for the given name.\n         */\n        Headers.prototype.delete = function (name) { this._headersMap.delete(normalize(name)); };\n        Headers.prototype.forEach = function (fn) {\n            this._headersMap.forEach(fn);\n        };\n        /**\n         * Returns first header that matches given name.\n         */\n        Headers.prototype.get = function (header) { return ListWrapper.first(this._headersMap.get(normalize(header))); };\n        /**\n         * Check for existence of header by given name.\n         */\n        Headers.prototype.has = function (header) { return this._headersMap.has(normalize(header)); };\n        /**\n         * Provides names of set headers\n         */\n        Headers.prototype.keys = function () { return MapWrapper.keys(this._headersMap); };\n        /**\n         * Sets or overrides header value for given name.\n         */\n        Headers.prototype.set = function (header, value) {\n            var list = [];\n            if (isListLikeIterable(value)) {\n                var pushValue = value.join(',');\n                list.push(pushValue);\n            }\n            else {\n                list.push(value);\n            }\n            this._headersMap.set(normalize(header), list);\n        };\n        /**\n         * Returns values of all headers.\n         */\n        Headers.prototype.values = function () { return MapWrapper.values(this._headersMap); };\n        /**\n         * Returns string of all headers.\n         */\n        Headers.prototype.toJSON = function () {\n            var serializableHeaders = {};\n            this._headersMap.forEach(function (values, name) {\n                var list = [];\n                iterateListLike(values, function (val /** TODO #9100 */) { return list = ListWrapper.concat(list, val.split(',')); });\n                serializableHeaders[normalize(name)] = list;\n            });\n            return serializableHeaders;\n        };\n        /**\n         * Returns list of header values for a given name.\n         */\n        Headers.prototype.getAll = function (header) {\n            var headers = this._headersMap.get(normalize(header));\n            return isListLikeIterable(headers) ? headers : [];\n        };\n        /**\n         * This method is not implemented.\n         */\n        Headers.prototype.entries = function () { throw new Error('\"entries\" method is not implemented on Headers class'); };\n        return Headers;\n    }());\n    // \"HTTP character sets are identified by case-insensitive tokens\"\n    // Spec at https://tools.ietf.org/html/rfc2616\n    // This implementation is same as NodeJS.\n    // see https://nodejs.org/dist/latest-v6.x/docs/api/http.html#http_message_headers\n    function normalize(name) {\n        return name.toLowerCase();\n    }\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$1 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    /**\n     * Creates a response options object to be optionally provided when instantiating a\n     * {@link Response}.\n     *\n     * This class is based on the `ResponseInit` description in the [Fetch\n     * Spec](https://fetch.spec.whatwg.org/#responseinit).\n     *\n     * All values are null by default. Typical defaults can be found in the\n     * {@link BaseResponseOptions} class, which sub-classes `ResponseOptions`.\n     *\n     * This class may be used in tests to build {@link Response Responses} for\n     * mock responses (see {@link MockBackend}).\n     *\n     * ### Example ([live demo](http://plnkr.co/edit/P9Jkk8e8cz6NVzbcxEsD?p=preview))\n     *\n     * ```typescript\n     * import {ResponseOptions, Response} from '@angular/http';\n     *\n     * var options = new ResponseOptions({\n     *   body: '{\"name\":\"Jeff\"}'\n     * });\n     * var res = new Response(options);\n     *\n     * console.log('res.json():', res.json()); // Object {name: \"Jeff\"}\n     * ```\n     *\n     * @experimental\n     */\n    var ResponseOptions = (function () {\n        function ResponseOptions(_a) {\n            var _b = _a === void 0 ? {} : _a, body = _b.body, status = _b.status, headers = _b.headers, statusText = _b.statusText, type = _b.type, url = _b.url;\n            this.body = isPresent(body) ? body : null;\n            this.status = isPresent(status) ? status : null;\n            this.headers = isPresent(headers) ? headers : null;\n            this.statusText = isPresent(statusText) ? statusText : null;\n            this.type = isPresent(type) ? type : null;\n            this.url = isPresent(url) ? url : null;\n        }\n        /**\n         * Creates a copy of the `ResponseOptions` instance, using the optional input as values to\n         * override\n         * existing values. This method will not change the values of the instance on which it is being\n         * called.\n         *\n         * This may be useful when sharing a base `ResponseOptions` object inside tests,\n         * where certain properties may change from test to test.\n         *\n         * ### Example ([live demo](http://plnkr.co/edit/1lXquqFfgduTFBWjNoRE?p=preview))\n         *\n         * ```typescript\n         * import {ResponseOptions, Response} from '@angular/http';\n         *\n         * var options = new ResponseOptions({\n         *   body: {name: 'Jeff'}\n         * });\n         * var res = new Response(options.merge({\n         *   url: 'https://google.com'\n         * }));\n         * console.log('options.url:', options.url); // null\n         * console.log('res.json():', res.json()); // Object {name: \"Jeff\"}\n         * console.log('res.url:', res.url); // https://google.com\n         * ```\n         */\n        ResponseOptions.prototype.merge = function (options) {\n            return new ResponseOptions({\n                body: isPresent(options) && isPresent(options.body) ? options.body : this.body,\n                status: isPresent(options) && isPresent(options.status) ? options.status : this.status,\n                headers: isPresent(options) && isPresent(options.headers) ? options.headers : this.headers,\n                statusText: isPresent(options) && isPresent(options.statusText) ? options.statusText :\n                    this.statusText,\n                type: isPresent(options) && isPresent(options.type) ? options.type : this.type,\n                url: isPresent(options) && isPresent(options.url) ? options.url : this.url,\n            });\n        };\n        return ResponseOptions;\n    }());\n    /**\n     * Subclass of {@link ResponseOptions}, with default values.\n     *\n     * Default values:\n     *  * status: 200\n     *  * headers: empty {@link Headers} object\n     *\n     * This class could be extended and bound to the {@link ResponseOptions} class\n     * when configuring an {@link Injector}, in order to override the default options\n     * used by {@link Http} to create {@link Response Responses}.\n     *\n     * ### Example ([live demo](http://plnkr.co/edit/qv8DLT?p=preview))\n     *\n     * ```typescript\n     * import {provide} from '@angular/core';\n     * import {bootstrap} from '@angular/platform-browser/browser';\n     * import {HTTP_PROVIDERS, Headers, Http, BaseResponseOptions, ResponseOptions} from\n     * '@angular/http';\n     * import {App} from './myapp';\n     *\n     * class MyOptions extends BaseResponseOptions {\n     *   headers:Headers = new Headers({network: 'github'});\n     * }\n     *\n     * bootstrap(App, [HTTP_PROVIDERS, {provide: ResponseOptions, useClass: MyOptions}]);\n     * ```\n     *\n     * The options could also be extended when manually creating a {@link Response}\n     * object.\n     *\n     * ### Example ([live demo](http://plnkr.co/edit/VngosOWiaExEtbstDoix?p=preview))\n     *\n     * ```\n     * import {BaseResponseOptions, Response} from '@angular/http';\n     *\n     * var options = new BaseResponseOptions();\n     * var res = new Response(options.merge({\n     *   body: 'Angular',\n     *   headers: new Headers({framework: 'angular'})\n     * }));\n     * console.log('res.headers.get(\"framework\"):', res.headers.get('framework')); // angular\n     * console.log('res.text():', res.text()); // Angular;\n     * ```\n     *\n     * @experimental\n     */\n    var BaseResponseOptions = (function (_super) {\n        __extends$1(BaseResponseOptions, _super);\n        function BaseResponseOptions() {\n            _super.call(this, { status: 200, statusText: 'Ok', type: exports.ResponseType.Default, headers: new Headers() });\n        }\n        BaseResponseOptions.decorators = [\n            { type: _angular_core.Injectable },\n        ];\n        /** @nocollapse */\n        BaseResponseOptions.ctorParameters = [];\n        return BaseResponseOptions;\n    }(ResponseOptions));\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * Abstract class from which real backends are derived.\n     *\n     * The primary purpose of a `ConnectionBackend` is to create new connections to fulfill a given\n     * {@link Request}.\n     *\n     * @experimental\n     */\n    var ConnectionBackend = (function () {\n        function ConnectionBackend() {\n        }\n        return ConnectionBackend;\n    }());\n    /**\n     * Abstract class from which real connections are derived.\n     *\n     * @experimental\n     */\n    var Connection = (function () {\n        function Connection() {\n        }\n        return Connection;\n    }());\n    /**\n     * An XSRFStrategy configures XSRF protection (e.g. via headers) on an HTTP request.\n     *\n     * @experimental\n     */\n    var XSRFStrategy = (function () {\n        function XSRFStrategy() {\n        }\n        return XSRFStrategy;\n    }());\n\n    function normalizeMethodName(method) {\n        if (isString(method)) {\n            var originalMethod = method;\n            method = method\n                .replace(/(\\w)(\\w*)/g, function (g0, g1, g2) { return g1.toUpperCase() + g2.toLowerCase(); });\n            method = exports.RequestMethod[method];\n            if (typeof method !== 'number')\n                throw new Error(\"Invalid request method. The method \\\"\" + originalMethod + \"\\\" is not supported.\");\n        }\n        return method;\n    }\n    var isSuccess = function (status) { return (status >= 200 && status < 300); };\n    function getResponseURL(xhr) {\n        if ('responseURL' in xhr) {\n            return xhr.responseURL;\n        }\n        if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {\n            return xhr.getResponseHeader('X-Request-URL');\n        }\n        return;\n    }\n    function stringToArrayBuffer(input) {\n        var view = new Uint16Array(input.length);\n        for (var i = 0, strLen = input.length; i < strLen; i++) {\n            view[i] = input.charCodeAt(i);\n        }\n        return view.buffer;\n    }\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    function paramParser(rawParams) {\n        if (rawParams === void 0) { rawParams = ''; }\n        var map = new Map();\n        if (rawParams.length > 0) {\n            var params = rawParams.split('&');\n            params.forEach(function (param) {\n                var eqIdx = param.indexOf('=');\n                var _a = eqIdx == -1 ? [param, ''] : [param.slice(0, eqIdx), param.slice(eqIdx + 1)], key = _a[0], val = _a[1];\n                var list = map.get(key) || [];\n                list.push(val);\n                map.set(key, list);\n            });\n        }\n        return map;\n    }\n    /**\n     * @experimental\n     **/\n    var QueryEncoder = (function () {\n        function QueryEncoder() {\n        }\n        QueryEncoder.prototype.encodeKey = function (k) { return standardEncoding(k); };\n        QueryEncoder.prototype.encodeValue = function (v) { return standardEncoding(v); };\n        return QueryEncoder;\n    }());\n    function standardEncoding(v) {\n        return encodeURIComponent(v)\n            .replace(/%40/gi, '@')\n            .replace(/%3A/gi, ':')\n            .replace(/%24/gi, '$')\n            .replace(/%2C/gi, ',')\n            .replace(/%3B/gi, ';')\n            .replace(/%2B/gi, '+')\n            .replace(/%3D/gi, '=')\n            .replace(/%3F/gi, '?')\n            .replace(/%2F/gi, '/');\n    }\n    /**\n     * Map-like representation of url search parameters, based on\n     * [URLSearchParams](https://url.spec.whatwg.org/#urlsearchparams) in the url living standard,\n     * with several extensions for merging URLSearchParams objects:\n     *   - setAll()\n     *   - appendAll()\n     *   - replaceAll()\n     *\n     * This class accepts an optional second parameter of ${@link QueryEncoder},\n     * which is used to serialize parameters before making a request. By default,\n     * `QueryEncoder` encodes keys and values of parameters using `encodeURIComponent`,\n     * and then un-encodes certain characters that are allowed to be part of the query\n     * according to IETF RFC 3986: https://tools.ietf.org/html/rfc3986.\n     *\n     * These are the characters that are not encoded: `! $ \\' ( ) * + , ; A 9 - . _ ~ ? /`\n     *\n     * If the set of allowed query characters is not acceptable for a particular backend,\n     * `QueryEncoder` can be subclassed and provided as the 2nd argument to URLSearchParams.\n     *\n     * ```\n     * import {URLSearchParams, QueryEncoder} from '@angular/http';\n     * class MyQueryEncoder extends QueryEncoder {\n     *   encodeKey(k: string): string {\n     *     return myEncodingFunction(k);\n     *   }\n     *\n     *   encodeValue(v: string): string {\n     *     return myEncodingFunction(v);\n     *   }\n     * }\n     *\n     * let params = new URLSearchParams('', new MyQueryEncoder());\n     * ```\n     * @experimental\n     */\n    var URLSearchParams = (function () {\n        function URLSearchParams(rawParams, queryEncoder) {\n            if (rawParams === void 0) { rawParams = ''; }\n            if (queryEncoder === void 0) { queryEncoder = new QueryEncoder(); }\n            this.rawParams = rawParams;\n            this.queryEncoder = queryEncoder;\n            this.paramsMap = paramParser(rawParams);\n        }\n        URLSearchParams.prototype.clone = function () {\n            var clone = new URLSearchParams('', this.queryEncoder);\n            clone.appendAll(this);\n            return clone;\n        };\n        URLSearchParams.prototype.has = function (param) { return this.paramsMap.has(param); };\n        URLSearchParams.prototype.get = function (param) {\n            var storedParam = this.paramsMap.get(param);\n            return Array.isArray(storedParam) ? storedParam[0] : null;\n        };\n        URLSearchParams.prototype.getAll = function (param) { return this.paramsMap.get(param) || []; };\n        URLSearchParams.prototype.set = function (param, val) {\n            var list = this.paramsMap.get(param) || [];\n            list.length = 0;\n            list.push(val);\n            this.paramsMap.set(param, list);\n        };\n        // A merge operation\n        // For each name-values pair in `searchParams`, perform `set(name, values[0])`\n        //\n        // E.g: \"a=[1,2,3], c=[8]\" + \"a=[4,5,6], b=[7]\" = \"a=[4], c=[8], b=[7]\"\n        //\n        // TODO(@caitp): document this better\n        URLSearchParams.prototype.setAll = function (searchParams) {\n            var _this = this;\n            searchParams.paramsMap.forEach(function (value, param) {\n                var list = _this.paramsMap.get(param) || [];\n                list.length = 0;\n                list.push(value[0]);\n                _this.paramsMap.set(param, list);\n            });\n        };\n        URLSearchParams.prototype.append = function (param, val) {\n            var list = this.paramsMap.get(param) || [];\n            list.push(val);\n            this.paramsMap.set(param, list);\n        };\n        // A merge operation\n        // For each name-values pair in `searchParams`, perform `append(name, value)`\n        // for each value in `values`.\n        //\n        // E.g: \"a=[1,2], c=[8]\" + \"a=[3,4], b=[7]\" = \"a=[1,2,3,4], c=[8], b=[7]\"\n        //\n        // TODO(@caitp): document this better\n        URLSearchParams.prototype.appendAll = function (searchParams) {\n            var _this = this;\n            searchParams.paramsMap.forEach(function (value, param) {\n                var list = _this.paramsMap.get(param) || [];\n                for (var i = 0; i < value.length; ++i) {\n                    list.push(value[i]);\n                }\n                _this.paramsMap.set(param, list);\n            });\n        };\n        // A merge operation\n        // For each name-values pair in `searchParams`, perform `delete(name)`,\n        // followed by `set(name, values)`\n        //\n        // E.g: \"a=[1,2,3], c=[8]\" + \"a=[4,5,6], b=[7]\" = \"a=[4,5,6], c=[8], b=[7]\"\n        //\n        // TODO(@caitp): document this better\n        URLSearchParams.prototype.replaceAll = function (searchParams) {\n            var _this = this;\n            searchParams.paramsMap.forEach(function (value, param) {\n                var list = _this.paramsMap.get(param) || [];\n                list.length = 0;\n                for (var i = 0; i < value.length; ++i) {\n                    list.push(value[i]);\n                }\n                _this.paramsMap.set(param, list);\n            });\n        };\n        URLSearchParams.prototype.toString = function () {\n            var _this = this;\n            var paramsList = [];\n            this.paramsMap.forEach(function (values, k) {\n                values.forEach(function (v) { return paramsList.push(_this.queryEncoder.encodeKey(k) + '=' + _this.queryEncoder.encodeValue(v)); });\n            });\n            return paramsList.join('&');\n        };\n        URLSearchParams.prototype.delete = function (param) { this.paramsMap.delete(param); };\n        return URLSearchParams;\n    }());\n\n    /**\n     * HTTP request body used by both {@link Request} and {@link Response}\n     * https://fetch.spec.whatwg.org/#body\n     */\n    var Body = (function () {\n        function Body() {\n        }\n        /**\n         * Attempts to return body as parsed `JSON` object, or raises an exception.\n         */\n        Body.prototype.json = function () {\n            if (isString(this._body)) {\n                return Json.parse(this._body);\n            }\n            if (this._body instanceof ArrayBuffer) {\n                return Json.parse(this.text());\n            }\n            return this._body;\n        };\n        /**\n         * Returns the body as a string, presuming `toString()` can be called on the response body.\n         */\n        Body.prototype.text = function () {\n            if (this._body instanceof URLSearchParams) {\n                return this._body.toString();\n            }\n            if (this._body instanceof ArrayBuffer) {\n                return String.fromCharCode.apply(null, new Uint16Array(this._body));\n            }\n            if (this._body === null) {\n                return '';\n            }\n            if (isJsObject(this._body)) {\n                return Json.stringify(this._body);\n            }\n            return this._body.toString();\n        };\n        /**\n         * Return the body as an ArrayBuffer\n         */\n        Body.prototype.arrayBuffer = function () {\n            if (this._body instanceof ArrayBuffer) {\n                return this._body;\n            }\n            return stringToArrayBuffer(this.text());\n        };\n        /**\n          * Returns the request's body as a Blob, assuming that body exists.\n          */\n        Body.prototype.blob = function () {\n            if (this._body instanceof Blob) {\n                return this._body;\n            }\n            if (this._body instanceof ArrayBuffer) {\n                return new Blob([this._body]);\n            }\n            throw new Error('The request body isn\\'t either a blob or an array buffer');\n        };\n        return Body;\n    }());\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$2 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    /**\n     * Creates `Response` instances from provided values.\n     *\n     * Though this object isn't\n     * usually instantiated by end-users, it is the primary object interacted with when it comes time to\n     * add data to a view.\n     *\n     * ### Example\n     *\n     * ```\n     * http.request('my-friends.txt').subscribe(response => this.friends = response.text());\n     * ```\n     *\n     * The Response's interface is inspired by the Response constructor defined in the [Fetch\n     * Spec](https://fetch.spec.whatwg.org/#response-class), but is considered a static value whose body\n     * can be accessed many times. There are other differences in the implementation, but this is the\n     * most significant.\n     *\n     * @experimental\n     */\n    var Response = (function (_super) {\n        __extends$2(Response, _super);\n        function Response(responseOptions) {\n            _super.call(this);\n            this._body = responseOptions.body;\n            this.status = responseOptions.status;\n            this.ok = (this.status >= 200 && this.status <= 299);\n            this.statusText = responseOptions.statusText;\n            this.headers = responseOptions.headers;\n            this.type = responseOptions.type;\n            this.url = responseOptions.url;\n        }\n        Response.prototype.toString = function () {\n            return \"Response with status: \" + this.status + \" \" + this.statusText + \" for URL: \" + this.url;\n        };\n        return Response;\n    }(Body));\n\n    var _nextRequestId = 0;\n    var JSONP_HOME = '__ng_jsonp__';\n    var _jsonpConnections = null;\n    function _getJsonpConnections() {\n        if (_jsonpConnections === null) {\n            _jsonpConnections = global$1[JSONP_HOME] = {};\n        }\n        return _jsonpConnections;\n    }\n    // Make sure not to evaluate this in a non-browser environment!\n    var BrowserJsonp = (function () {\n        function BrowserJsonp() {\n        }\n        // Construct a <script> element with the specified URL\n        BrowserJsonp.prototype.build = function (url) {\n            var node = document.createElement('script');\n            node.src = url;\n            return node;\n        };\n        BrowserJsonp.prototype.nextRequestID = function () { return \"__req\" + _nextRequestId++; };\n        BrowserJsonp.prototype.requestCallback = function (id) { return JSONP_HOME + \".\" + id + \".finished\"; };\n        BrowserJsonp.prototype.exposeConnection = function (id, connection) {\n            var connections = _getJsonpConnections();\n            connections[id] = connection;\n        };\n        BrowserJsonp.prototype.removeConnection = function (id) {\n            var connections = _getJsonpConnections();\n            connections[id] = null;\n        };\n        // Attach the <script> element to the DOM\n        BrowserJsonp.prototype.send = function (node) { document.body.appendChild((node)); };\n        // Remove <script> element from the DOM\n        BrowserJsonp.prototype.cleanup = function (node) {\n            if (node.parentNode) {\n                node.parentNode.removeChild((node));\n            }\n        };\n        BrowserJsonp.decorators = [\n            { type: _angular_core.Injectable },\n        ];\n        /** @nocollapse */\n        BrowserJsonp.ctorParameters = [];\n        return BrowserJsonp;\n    }());\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    var JSONP_ERR_NO_CALLBACK = 'JSONP injected script did not invoke callback.';\n    var JSONP_ERR_WRONG_METHOD = 'JSONP requests must use GET request method.';\n    /**\n     * Abstract base class for an in-flight JSONP request.\n     *\n     * @experimental\n     */\n    var JSONPConnection = (function () {\n        function JSONPConnection() {\n        }\n        return JSONPConnection;\n    }());\n    var JSONPConnection_ = (function (_super) {\n        __extends(JSONPConnection_, _super);\n        function JSONPConnection_(req, _dom, baseResponseOptions) {\n            var _this = this;\n            _super.call(this);\n            this._dom = _dom;\n            this.baseResponseOptions = baseResponseOptions;\n            this._finished = false;\n            if (req.method !== exports.RequestMethod.Get) {\n                throw new TypeError(JSONP_ERR_WRONG_METHOD);\n            }\n            this.request = req;\n            this.response = new rxjs_Observable.Observable(function (responseObserver) {\n                _this.readyState = exports.ReadyState.Loading;\n                var id = _this._id = _dom.nextRequestID();\n                _dom.exposeConnection(id, _this);\n                // Workaround Dart\n                // url = url.replace(/=JSONP_CALLBACK(&|$)/, `generated method`);\n                var callback = _dom.requestCallback(_this._id);\n                var url = req.url;\n                if (url.indexOf('=JSONP_CALLBACK&') > -1) {\n                    url = StringWrapper.replace(url, '=JSONP_CALLBACK&', \"=\" + callback + \"&\");\n                }\n                else if (url.lastIndexOf('=JSONP_CALLBACK') === url.length - '=JSONP_CALLBACK'.length) {\n                    url = url.substring(0, url.length - '=JSONP_CALLBACK'.length) + (\"=\" + callback);\n                }\n                var script = _this._script = _dom.build(url);\n                var onLoad = function (event) {\n                    if (_this.readyState === exports.ReadyState.Cancelled)\n                        return;\n                    _this.readyState = exports.ReadyState.Done;\n                    _dom.cleanup(script);\n                    if (!_this._finished) {\n                        var responseOptions_1 = new ResponseOptions({ body: JSONP_ERR_NO_CALLBACK, type: exports.ResponseType.Error, url: url });\n                        if (isPresent(baseResponseOptions)) {\n                            responseOptions_1 = baseResponseOptions.merge(responseOptions_1);\n                        }\n                        responseObserver.error(new Response(responseOptions_1));\n                        return;\n                    }\n                    var responseOptions = new ResponseOptions({ body: _this._responseData, url: url });\n                    if (isPresent(_this.baseResponseOptions)) {\n                        responseOptions = _this.baseResponseOptions.merge(responseOptions);\n                    }\n                    responseObserver.next(new Response(responseOptions));\n                    responseObserver.complete();\n                };\n                var onError = function (error) {\n                    if (_this.readyState === exports.ReadyState.Cancelled)\n                        return;\n                    _this.readyState = exports.ReadyState.Done;\n                    _dom.cleanup(script);\n                    var responseOptions = new ResponseOptions({ body: error.message, type: exports.ResponseType.Error });\n                    if (isPresent(baseResponseOptions)) {\n                        responseOptions = baseResponseOptions.merge(responseOptions);\n                    }\n                    responseObserver.error(new Response(responseOptions));\n                };\n                script.addEventListener('load', onLoad);\n                script.addEventListener('error', onError);\n                _dom.send(script);\n                return function () {\n                    _this.readyState = exports.ReadyState.Cancelled;\n                    script.removeEventListener('load', onLoad);\n                    script.removeEventListener('error', onError);\n                    if (isPresent(script)) {\n                        _this._dom.cleanup(script);\n                    }\n                };\n            });\n        }\n        JSONPConnection_.prototype.finished = function (data) {\n            // Don't leak connections\n            this._finished = true;\n            this._dom.removeConnection(this._id);\n            if (this.readyState === exports.ReadyState.Cancelled)\n                return;\n            this._responseData = data;\n        };\n        return JSONPConnection_;\n    }(JSONPConnection));\n    /**\n     * A {@link ConnectionBackend} that uses the JSONP strategy of making requests.\n     *\n     * @experimental\n     */\n    var JSONPBackend = (function (_super) {\n        __extends(JSONPBackend, _super);\n        function JSONPBackend() {\n            _super.apply(this, arguments);\n        }\n        return JSONPBackend;\n    }(ConnectionBackend));\n    var JSONPBackend_ = (function (_super) {\n        __extends(JSONPBackend_, _super);\n        function JSONPBackend_(_browserJSONP, _baseResponseOptions) {\n            _super.call(this);\n            this._browserJSONP = _browserJSONP;\n            this._baseResponseOptions = _baseResponseOptions;\n        }\n        JSONPBackend_.prototype.createConnection = function (request) {\n            return new JSONPConnection_(request, this._browserJSONP, this._baseResponseOptions);\n        };\n        JSONPBackend_.decorators = [\n            { type: _angular_core.Injectable },\n        ];\n        /** @nocollapse */\n        JSONPBackend_.ctorParameters = [\n            { type: BrowserJsonp, },\n            { type: ResponseOptions, },\n        ];\n        return JSONPBackend_;\n    }(JSONPBackend));\n\n    var XSSI_PREFIX = /^\\)\\]\\}',?\\n/;\n    /**\n     * Creates connections using `XMLHttpRequest`. Given a fully-qualified\n     * request, an `XHRConnection` will immediately create an `XMLHttpRequest` object and send the\n     * request.\n     *\n     * This class would typically not be created or interacted with directly inside applications, though\n     * the {@link MockConnection} may be interacted with in tests.\n     *\n     * @experimental\n     */\n    var XHRConnection = (function () {\n        function XHRConnection(req, browserXHR, baseResponseOptions) {\n            var _this = this;\n            this.request = req;\n            this.response = new rxjs_Observable.Observable(function (responseObserver) {\n                var _xhr = browserXHR.build();\n                _xhr.open(exports.RequestMethod[req.method].toUpperCase(), req.url);\n                if (isPresent(req.withCredentials)) {\n                    _xhr.withCredentials = req.withCredentials;\n                }\n                // load event handler\n                var onLoad = function () {\n                    // responseText is the old-school way of retrieving response (supported by IE8 & 9)\n                    // response/responseType properties were introduced in ResourceLoader Level2 spec (supported\n                    // by\n                    // IE10)\n                    var body = isPresent(_xhr.response) ? _xhr.response : _xhr.responseText;\n                    // Implicitly strip a potential XSSI prefix.\n                    if (isString(body))\n                        body = body.replace(XSSI_PREFIX, '');\n                    var headers = Headers.fromResponseHeaderString(_xhr.getAllResponseHeaders());\n                    var url = getResponseURL(_xhr);\n                    // normalize IE9 bug (http://bugs.jquery.com/ticket/1450)\n                    var status = _xhr.status === 1223 ? 204 : _xhr.status;\n                    // fix status code when it is 0 (0 status is undocumented).\n                    // Occurs when accessing file resources or on Android 4.1 stock browser\n                    // while retrieving files from application cache.\n                    if (status === 0) {\n                        status = body ? 200 : 0;\n                    }\n                    var statusText = _xhr.statusText || 'OK';\n                    var responseOptions = new ResponseOptions({ body: body, status: status, headers: headers, statusText: statusText, url: url });\n                    if (isPresent(baseResponseOptions)) {\n                        responseOptions = baseResponseOptions.merge(responseOptions);\n                    }\n                    var response = new Response(responseOptions);\n                    response.ok = isSuccess(status);\n                    if (response.ok) {\n                        responseObserver.next(response);\n                        // TODO(gdi2290): defer complete if array buffer until done\n                        responseObserver.complete();\n                        return;\n                    }\n                    responseObserver.error(response);\n                };\n                // error event handler\n                var onError = function (err) {\n                    var responseOptions = new ResponseOptions({\n                        body: err,\n                        type: exports.ResponseType.Error,\n                        status: _xhr.status,\n                        statusText: _xhr.statusText,\n                    });\n                    if (isPresent(baseResponseOptions)) {\n                        responseOptions = baseResponseOptions.merge(responseOptions);\n                    }\n                    responseObserver.error(new Response(responseOptions));\n                };\n                _this.setDetectedContentType(req, _xhr);\n                if (isPresent(req.headers)) {\n                    req.headers.forEach(function (values, name) { return _xhr.setRequestHeader(name, values.join(',')); });\n                }\n                // Select the correct buffer type to store the response\n                if (isPresent(req.responseType) && isPresent(_xhr.responseType)) {\n                    switch (req.responseType) {\n                        case exports.ResponseContentType.ArrayBuffer:\n                            _xhr.responseType = 'arraybuffer';\n                            break;\n                        case exports.ResponseContentType.Json:\n                            _xhr.responseType = 'json';\n                            break;\n                        case exports.ResponseContentType.Text:\n                            _xhr.responseType = 'text';\n                            break;\n                        case exports.ResponseContentType.Blob:\n                            _xhr.responseType = 'blob';\n                            break;\n                        default:\n                            throw new Error('The selected responseType is not supported');\n                    }\n                }\n                _xhr.addEventListener('load', onLoad);\n                _xhr.addEventListener('error', onError);\n                _xhr.send(_this.request.getBody());\n                return function () {\n                    _xhr.removeEventListener('load', onLoad);\n                    _xhr.removeEventListener('error', onError);\n                    _xhr.abort();\n                };\n            });\n        }\n        XHRConnection.prototype.setDetectedContentType = function (req /** TODO #9100 */, _xhr /** TODO #9100 */) {\n            // Skip if a custom Content-Type header is provided\n            if (isPresent(req.headers) && isPresent(req.headers.get('Content-Type'))) {\n                return;\n            }\n            // Set the detected content type\n            switch (req.contentType) {\n                case ContentType.NONE:\n                    break;\n                case ContentType.JSON:\n                    _xhr.setRequestHeader('content-type', 'application/json');\n                    break;\n                case ContentType.FORM:\n                    _xhr.setRequestHeader('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');\n                    break;\n                case ContentType.TEXT:\n                    _xhr.setRequestHeader('content-type', 'text/plain');\n                    break;\n                case ContentType.BLOB:\n                    var blob = req.blob();\n                    if (blob.type) {\n                        _xhr.setRequestHeader('content-type', blob.type);\n                    }\n                    break;\n            }\n        };\n        return XHRConnection;\n    }());\n    /**\n     * `XSRFConfiguration` sets up Cross Site Request Forgery (XSRF) protection for the application\n     * using a cookie. See {@link https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)}\n     * for more information on XSRF.\n     *\n     * Applications can configure custom cookie and header names by binding an instance of this class\n     * with different `cookieName` and `headerName` values. See the main HTTP documentation for more\n     * details.\n     *\n     * @experimental\n     */\n    var CookieXSRFStrategy = (function () {\n        function CookieXSRFStrategy(_cookieName, _headerName) {\n            if (_cookieName === void 0) { _cookieName = 'XSRF-TOKEN'; }\n            if (_headerName === void 0) { _headerName = 'X-XSRF-TOKEN'; }\n            this._cookieName = _cookieName;\n            this._headerName = _headerName;\n        }\n        CookieXSRFStrategy.prototype.configureRequest = function (req) {\n            var xsrfToken = _angular_platformBrowser.__platform_browser_private__.getDOM().getCookie(this._cookieName);\n            if (xsrfToken && !req.headers.has(this._headerName)) {\n                req.headers.set(this._headerName, xsrfToken);\n            }\n        };\n        return CookieXSRFStrategy;\n    }());\n    /**\n     * Creates {@link XHRConnection} instances.\n     *\n     * This class would typically not be used by end users, but could be\n     * overridden if a different backend implementation should be used,\n     * such as in a node backend.\n     *\n     * ### Example\n     *\n     * ```\n     * import {Http, MyNodeBackend, HTTP_PROVIDERS, BaseRequestOptions} from '@angular/http';\n     * @Component({\n     *   viewProviders: [\n     *     HTTP_PROVIDERS,\n     *     {provide: Http, useFactory: (backend, options) => {\n     *       return new Http(backend, options);\n     *     }, deps: [MyNodeBackend, BaseRequestOptions]}]\n     * })\n     * class MyComponent {\n     *   constructor(http:Http) {\n     *     http.request('people.json').subscribe(res => this.people = res.json());\n     *   }\n     * }\n     * ```\n     * @experimental\n     */\n    var XHRBackend = (function () {\n        function XHRBackend(_browserXHR, _baseResponseOptions, _xsrfStrategy) {\n            this._browserXHR = _browserXHR;\n            this._baseResponseOptions = _baseResponseOptions;\n            this._xsrfStrategy = _xsrfStrategy;\n        }\n        XHRBackend.prototype.createConnection = function (request) {\n            this._xsrfStrategy.configureRequest(request);\n            return new XHRConnection(request, this._browserXHR, this._baseResponseOptions);\n        };\n        XHRBackend.decorators = [\n            { type: _angular_core.Injectable },\n        ];\n        /** @nocollapse */\n        XHRBackend.ctorParameters = [\n            { type: BrowserXhr, },\n            { type: ResponseOptions, },\n            { type: XSRFStrategy, },\n        ];\n        return XHRBackend;\n    }());\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$3 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    /**\n     * Creates a request options object to be optionally provided when instantiating a\n     * {@link Request}.\n     *\n     * This class is based on the `RequestInit` description in the [Fetch\n     * Spec](https://fetch.spec.whatwg.org/#requestinit).\n     *\n     * All values are null by default. Typical defaults can be found in the {@link BaseRequestOptions}\n     * class, which sub-classes `RequestOptions`.\n     *\n     * ### Example ([live demo](http://plnkr.co/edit/7Wvi3lfLq41aQPKlxB4O?p=preview))\n     *\n     * ```typescript\n     * import {RequestOptions, Request, RequestMethod} from '@angular/http';\n     *\n     * var options = new RequestOptions({\n     *   method: RequestMethod.Post,\n     *   url: 'https://google.com'\n     * });\n     * var req = new Request(options);\n     * console.log('req.method:', RequestMethod[req.method]); // Post\n     * console.log('options.url:', options.url); // https://google.com\n     * ```\n     *\n     * @experimental\n     */\n    var RequestOptions = (function () {\n        function RequestOptions(_a) {\n            var _b = _a === void 0 ? {} : _a, method = _b.method, headers = _b.headers, body = _b.body, url = _b.url, search = _b.search, withCredentials = _b.withCredentials, responseType = _b.responseType;\n            this.method = isPresent(method) ? normalizeMethodName(method) : null;\n            this.headers = isPresent(headers) ? headers : null;\n            this.body = isPresent(body) ? body : null;\n            this.url = isPresent(url) ? url : null;\n            this.search = isPresent(search) ?\n                (isString(search) ? new URLSearchParams((search)) : (search)) :\n                null;\n            this.withCredentials = isPresent(withCredentials) ? withCredentials : null;\n            this.responseType = isPresent(responseType) ? responseType : null;\n        }\n        /**\n         * Creates a copy of the `RequestOptions` instance, using the optional input as values to override\n         * existing values. This method will not change the values of the instance on which it is being\n         * called.\n         *\n         * Note that `headers` and `search` will override existing values completely if present in\n         * the `options` object. If these values should be merged, it should be done prior to calling\n         * `merge` on the `RequestOptions` instance.\n         *\n         * ### Example ([live demo](http://plnkr.co/edit/6w8XA8YTkDRcPYpdB9dk?p=preview))\n         *\n         * ```typescript\n         * import {RequestOptions, Request, RequestMethod} from '@angular/http';\n         *\n         * var options = new RequestOptions({\n         *   method: RequestMethod.Post\n         * });\n         * var req = new Request(options.merge({\n         *   url: 'https://google.com'\n         * }));\n         * console.log('req.method:', RequestMethod[req.method]); // Post\n         * console.log('options.url:', options.url); // null\n         * console.log('req.url:', req.url); // https://google.com\n         * ```\n         */\n        RequestOptions.prototype.merge = function (options) {\n            return new RequestOptions({\n                method: isPresent(options) && isPresent(options.method) ? options.method : this.method,\n                headers: isPresent(options) && isPresent(options.headers) ? options.headers : this.headers,\n                body: isPresent(options) && isPresent(options.body) ? options.body : this.body,\n                url: isPresent(options) && isPresent(options.url) ? options.url : this.url,\n                search: isPresent(options) && isPresent(options.search) ?\n                    (isString(options.search) ? new URLSearchParams((options.search)) :\n                        (options.search).clone()) :\n                    this.search,\n                withCredentials: isPresent(options) && isPresent(options.withCredentials) ?\n                    options.withCredentials :\n                    this.withCredentials,\n                responseType: isPresent(options) && isPresent(options.responseType) ? options.responseType :\n                    this.responseType\n            });\n        };\n        return RequestOptions;\n    }());\n    /**\n     * Subclass of {@link RequestOptions}, with default values.\n     *\n     * Default values:\n     *  * method: {@link RequestMethod RequestMethod.Get}\n     *  * headers: empty {@link Headers} object\n     *\n     * This class could be extended and bound to the {@link RequestOptions} class\n     * when configuring an {@link Injector}, in order to override the default options\n     * used by {@link Http} to create and send {@link Request Requests}.\n     *\n     * ### Example ([live demo](http://plnkr.co/edit/LEKVSx?p=preview))\n     *\n     * ```typescript\n     * import {provide} from '@angular/core';\n     * import {bootstrap} from '@angular/platform-browser/browser';\n     * import {HTTP_PROVIDERS, Http, BaseRequestOptions, RequestOptions} from '@angular/http';\n     * import {App} from './myapp';\n     *\n     * class MyOptions extends BaseRequestOptions {\n     *   search: string = 'coreTeam=true';\n     * }\n     *\n     * bootstrap(App, [HTTP_PROVIDERS, {provide: RequestOptions, useClass: MyOptions}]);\n     * ```\n     *\n     * The options could also be extended when manually creating a {@link Request}\n     * object.\n     *\n     * ### Example ([live demo](http://plnkr.co/edit/oyBoEvNtDhOSfi9YxaVb?p=preview))\n     *\n     * ```\n     * import {BaseRequestOptions, Request, RequestMethod} from '@angular/http';\n     *\n     * var options = new BaseRequestOptions();\n     * var req = new Request(options.merge({\n     *   method: RequestMethod.Post,\n     *   url: 'https://google.com'\n     * }));\n     * console.log('req.method:', RequestMethod[req.method]); // Post\n     * console.log('options.url:', options.url); // null\n     * console.log('req.url:', req.url); // https://google.com\n     * ```\n     *\n     * @experimental\n     */\n    var BaseRequestOptions = (function (_super) {\n        __extends$3(BaseRequestOptions, _super);\n        function BaseRequestOptions() {\n            _super.call(this, { method: exports.RequestMethod.Get, headers: new Headers() });\n        }\n        BaseRequestOptions.decorators = [\n            { type: _angular_core.Injectable },\n        ];\n        /** @nocollapse */\n        BaseRequestOptions.ctorParameters = [];\n        return BaseRequestOptions;\n    }(RequestOptions));\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$5 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    // TODO(jeffbcross): properly implement body accessors\n    /**\n     * Creates `Request` instances from provided values.\n     *\n     * The Request's interface is inspired by the Request constructor defined in the [Fetch\n     * Spec](https://fetch.spec.whatwg.org/#request-class),\n     * but is considered a static value whose body can be accessed many times. There are other\n     * differences in the implementation, but this is the most significant.\n     *\n     * `Request` instances are typically created by higher-level classes, like {@link Http} and\n     * {@link Jsonp}, but it may occasionally be useful to explicitly create `Request` instances.\n     * One such example is when creating services that wrap higher-level services, like {@link Http},\n     * where it may be useful to generate a `Request` with arbitrary headers and search params.\n     *\n     * ```typescript\n     * import {Injectable, Injector} from '@angular/core';\n     * import {HTTP_PROVIDERS, Http, Request, RequestMethod} from '@angular/http';\n     *\n     * @Injectable()\n     * class AutoAuthenticator {\n     *   constructor(public http:Http) {}\n     *   request(url:string) {\n     *     return this.http.request(new Request({\n     *       method: RequestMethod.Get,\n     *       url: url,\n     *       search: 'password=123'\n     *     }));\n     *   }\n     * }\n     *\n     * var injector = Injector.resolveAndCreate([HTTP_PROVIDERS, AutoAuthenticator]);\n     * var authenticator = injector.get(AutoAuthenticator);\n     * authenticator.request('people.json').subscribe(res => {\n     *   //URL should have included '?password=123'\n     *   console.log('people', res.json());\n     * });\n     * ```\n     *\n     * @experimental\n     */\n    var Request = (function (_super) {\n        __extends$5(Request, _super);\n        function Request(requestOptions) {\n            _super.call(this);\n            // TODO: assert that url is present\n            var url = requestOptions.url;\n            this.url = requestOptions.url;\n            if (isPresent(requestOptions.search)) {\n                var search = requestOptions.search.toString();\n                if (search.length > 0) {\n                    var prefix = '?';\n                    if (StringWrapper.contains(this.url, '?')) {\n                        prefix = (this.url[this.url.length - 1] == '&') ? '' : '&';\n                    }\n                    // TODO: just delete search-query-looking string in url?\n                    this.url = url + prefix + search;\n                }\n            }\n            this._body = requestOptions.body;\n            this.method = normalizeMethodName(requestOptions.method);\n            // TODO(jeffbcross): implement behavior\n            // Defaults to 'omit', consistent with browser\n            // TODO(jeffbcross): implement behavior\n            this.headers = new Headers(requestOptions.headers);\n            this.contentType = this.detectContentType();\n            this.withCredentials = requestOptions.withCredentials;\n            this.responseType = requestOptions.responseType;\n        }\n        /**\n         * Returns the content type enum based on header options.\n         */\n        Request.prototype.detectContentType = function () {\n            switch (this.headers.get('content-type')) {\n                case 'application/json':\n                    return ContentType.JSON;\n                case 'application/x-www-form-urlencoded':\n                    return ContentType.FORM;\n                case 'multipart/form-data':\n                    return ContentType.FORM_DATA;\n                case 'text/plain':\n                case 'text/html':\n                    return ContentType.TEXT;\n                case 'application/octet-stream':\n                    return ContentType.BLOB;\n                default:\n                    return this.detectContentTypeFromBody();\n            }\n        };\n        /**\n         * Returns the content type of request's body based on its type.\n         */\n        Request.prototype.detectContentTypeFromBody = function () {\n            if (this._body == null) {\n                return ContentType.NONE;\n            }\n            else if (this._body instanceof URLSearchParams) {\n                return ContentType.FORM;\n            }\n            else if (this._body instanceof FormData) {\n                return ContentType.FORM_DATA;\n            }\n            else if (this._body instanceof Blob$1) {\n                return ContentType.BLOB;\n            }\n            else if (this._body instanceof ArrayBuffer$1) {\n                return ContentType.ARRAY_BUFFER;\n            }\n            else if (this._body && typeof this._body == 'object') {\n                return ContentType.JSON;\n            }\n            else {\n                return ContentType.TEXT;\n            }\n        };\n        /**\n         * Returns the request's body according to its type. If body is undefined, return\n         * null.\n         */\n        Request.prototype.getBody = function () {\n            switch (this.contentType) {\n                case ContentType.JSON:\n                    return this.text();\n                case ContentType.FORM:\n                    return this.text();\n                case ContentType.FORM_DATA:\n                    return this._body;\n                case ContentType.TEXT:\n                    return this.text();\n                case ContentType.BLOB:\n                    return this.blob();\n                case ContentType.ARRAY_BUFFER:\n                    return this.arrayBuffer();\n                default:\n                    return null;\n            }\n        };\n        return Request;\n    }(Body));\n    var noop$1 = function () { };\n    var w = typeof window == 'object' ? window : noop$1;\n    var FormData = w['FormData'] || noop$1;\n    var Blob$1 = w['Blob'] || noop$1;\n    var ArrayBuffer$1 = w['ArrayBuffer'] || noop$1;\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$4 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    function httpRequest(backend, request) {\n        return backend.createConnection(request).response;\n    }\n    function mergeOptions(defaultOpts, providedOpts, method, url) {\n        var newOptions = defaultOpts;\n        if (isPresent(providedOpts)) {\n            // Hack so Dart can used named parameters\n            return newOptions.merge(new RequestOptions({\n                method: providedOpts.method || method,\n                url: providedOpts.url || url,\n                search: providedOpts.search,\n                headers: providedOpts.headers,\n                body: providedOpts.body,\n                withCredentials: providedOpts.withCredentials,\n                responseType: providedOpts.responseType\n            }));\n        }\n        if (isPresent(method)) {\n            return newOptions.merge(new RequestOptions({ method: method, url: url }));\n        }\n        else {\n            return newOptions.merge(new RequestOptions({ url: url }));\n        }\n    }\n    /**\n     * Performs http requests using `XMLHttpRequest` as the default backend.\n     *\n     * `Http` is available as an injectable class, with methods to perform http requests. Calling\n     * `request` returns an `Observable` which will emit a single {@link Response} when a\n     * response is received.\n     *\n     * ### Example\n     *\n     * ```typescript\n     * import {Http, HTTP_PROVIDERS} from '@angular/http';\n     * import 'rxjs/add/operator/map'\n     * @Component({\n     *   selector: 'http-app',\n     *   viewProviders: [HTTP_PROVIDERS],\n     *   templateUrl: 'people.html'\n     * })\n     * class PeopleComponent {\n     *   constructor(http: Http) {\n     *     http.get('people.json')\n     *       // Call map on the response observable to get the parsed people object\n     *       .map(res => res.json())\n     *       // Subscribe to the observable to get the parsed people object and attach it to the\n     *       // component\n     *       .subscribe(people => this.people = people);\n     *   }\n     * }\n     * ```\n     *\n     *\n     * ### Example\n     *\n     * ```\n     * http.get('people.json').subscribe((res:Response) => this.people = res.json());\n     * ```\n     *\n     * The default construct used to perform requests, `XMLHttpRequest`, is abstracted as a \"Backend\" (\n     * {@link XHRBackend} in this case), which could be mocked with dependency injection by replacing\n     * the {@link XHRBackend} provider, as in the following example:\n     *\n     * ### Example\n     *\n     * ```typescript\n     * import {BaseRequestOptions, Http} from '@angular/http';\n     * import {MockBackend} from '@angular/http/testing';\n     * var injector = Injector.resolveAndCreate([\n     *   BaseRequestOptions,\n     *   MockBackend,\n     *   {provide: Http, useFactory:\n     *       function(backend, defaultOptions) {\n     *         return new Http(backend, defaultOptions);\n     *       },\n     *       deps: [MockBackend, BaseRequestOptions]}\n     * ]);\n     * var http = injector.get(Http);\n     * http.get('request-from-mock-backend.json').subscribe((res:Response) => doSomething(res));\n     * ```\n     *\n     * @experimental\n     */\n    var Http = (function () {\n        function Http(_backend, _defaultOptions) {\n            this._backend = _backend;\n            this._defaultOptions = _defaultOptions;\n        }\n        /**\n         * Performs any type of http request. First argument is required, and can either be a url or\n         * a {@link Request} instance. If the first argument is a url, an optional {@link RequestOptions}\n         * object can be provided as the 2nd argument. The options object will be merged with the values\n         * of {@link BaseRequestOptions} before performing the request.\n         */\n        Http.prototype.request = function (url, options) {\n            var responseObservable;\n            if (isString(url)) {\n                responseObservable = httpRequest(this._backend, new Request(mergeOptions(this._defaultOptions, options, exports.RequestMethod.Get, url)));\n            }\n            else if (url instanceof Request) {\n                responseObservable = httpRequest(this._backend, url);\n            }\n            else {\n                throw new Error('First argument must be a url string or Request instance.');\n            }\n            return responseObservable;\n        };\n        /**\n         * Performs a request with `get` http method.\n         */\n        Http.prototype.get = function (url, options) {\n            return httpRequest(this._backend, new Request(mergeOptions(this._defaultOptions, options, exports.RequestMethod.Get, url)));\n        };\n        /**\n         * Performs a request with `post` http method.\n         */\n        Http.prototype.post = function (url, body, options) {\n            return httpRequest(this._backend, new Request(mergeOptions(this._defaultOptions.merge(new RequestOptions({ body: body })), options, exports.RequestMethod.Post, url)));\n        };\n        /**\n         * Performs a request with `put` http method.\n         */\n        Http.prototype.put = function (url, body, options) {\n            return httpRequest(this._backend, new Request(mergeOptions(this._defaultOptions.merge(new RequestOptions({ body: body })), options, exports.RequestMethod.Put, url)));\n        };\n        /**\n         * Performs a request with `delete` http method.\n         */\n        Http.prototype.delete = function (url, options) {\n            return httpRequest(this._backend, new Request(mergeOptions(this._defaultOptions, options, exports.RequestMethod.Delete, url)));\n        };\n        /**\n         * Performs a request with `patch` http method.\n         */\n        Http.prototype.patch = function (url, body, options) {\n            return httpRequest(this._backend, new Request(mergeOptions(this._defaultOptions.merge(new RequestOptions({ body: body })), options, exports.RequestMethod.Patch, url)));\n        };\n        /**\n         * Performs a request with `head` http method.\n         */\n        Http.prototype.head = function (url, options) {\n            return httpRequest(this._backend, new Request(mergeOptions(this._defaultOptions, options, exports.RequestMethod.Head, url)));\n        };\n        /**\n         * Performs a request with `options` http method.\n         */\n        Http.prototype.options = function (url, options) {\n            return httpRequest(this._backend, new Request(mergeOptions(this._defaultOptions, options, exports.RequestMethod.Options, url)));\n        };\n        Http.decorators = [\n            { type: _angular_core.Injectable },\n        ];\n        /** @nocollapse */\n        Http.ctorParameters = [\n            { type: ConnectionBackend, },\n            { type: RequestOptions, },\n        ];\n        return Http;\n    }());\n    /**\n     * @experimental\n     */\n    var Jsonp = (function (_super) {\n        __extends$4(Jsonp, _super);\n        function Jsonp(backend, defaultOptions) {\n            _super.call(this, backend, defaultOptions);\n        }\n        /**\n         * Performs any type of http request. First argument is required, and can either be a url or\n         * a {@link Request} instance. If the first argument is a url, an optional {@link RequestOptions}\n         * object can be provided as the 2nd argument. The options object will be merged with the values\n         * of {@link BaseRequestOptions} before performing the request.\n         *\n         * @security Regular XHR is the safest alternative to JSONP for most applications, and is\n         * supported by all current browsers. Because JSONP creates a `<script>` element with\n         * contents retrieved from a remote source, attacker-controlled data introduced by an untrusted\n         * source could expose your application to XSS risks. Data exposed by JSONP may also be\n         * readable by malicious third-party websites. In addition, JSONP introduces potential risk for\n         * future security issues (e.g. content sniffing).  For more detail, see the\n         * [Security Guide](http://g.co/ng/security).\n         */\n        Jsonp.prototype.request = function (url, options) {\n            var responseObservable;\n            if (isString(url)) {\n                url =\n                    new Request(mergeOptions(this._defaultOptions, options, exports.RequestMethod.Get, url));\n            }\n            if (url instanceof Request) {\n                if (url.method !== exports.RequestMethod.Get) {\n                    throw new Error('JSONP requests must use GET request method.');\n                }\n                responseObservable = httpRequest(this._backend, url);\n            }\n            else {\n                throw new Error('First argument must be a url string or Request instance.');\n            }\n            return responseObservable;\n        };\n        Jsonp.decorators = [\n            { type: _angular_core.Injectable },\n        ];\n        /** @nocollapse */\n        Jsonp.ctorParameters = [\n            { type: ConnectionBackend, },\n            { type: RequestOptions, },\n        ];\n        return Jsonp;\n    }(Http));\n\n    function _createDefaultCookieXSRFStrategy() {\n        return new CookieXSRFStrategy();\n    }\n    function httpFactory(xhrBackend, requestOptions) {\n        return new Http(xhrBackend, requestOptions);\n    }\n    function jsonpFactory(jsonpBackend, requestOptions) {\n        return new Jsonp(jsonpBackend, requestOptions);\n    }\n    /**\n     * The module that includes http's providers\n     *\n     * @experimental\n     */\n    var HttpModule = (function () {\n        function HttpModule() {\n        }\n        HttpModule.decorators = [\n            { type: _angular_core.NgModule, args: [{\n                        providers: [\n                            // TODO(pascal): use factory type annotations once supported in DI\n                            // issue: https://github.com/angular/angular/issues/3183\n                            { provide: Http, useFactory: httpFactory, deps: [XHRBackend, RequestOptions] },\n                            BrowserXhr,\n                            { provide: RequestOptions, useClass: BaseRequestOptions },\n                            { provide: ResponseOptions, useClass: BaseResponseOptions },\n                            XHRBackend,\n                            { provide: XSRFStrategy, useFactory: _createDefaultCookieXSRFStrategy },\n                        ],\n                    },] },\n        ];\n        /** @nocollapse */\n        HttpModule.ctorParameters = [];\n        return HttpModule;\n    }());\n    /**\n     * The module that includes jsonp's providers\n     *\n     * @experimental\n     */\n    var JsonpModule = (function () {\n        function JsonpModule() {\n        }\n        JsonpModule.decorators = [\n            { type: _angular_core.NgModule, args: [{\n                        providers: [\n                            // TODO(pascal): use factory type annotations once supported in DI\n                            // issue: https://github.com/angular/angular/issues/3183\n                            { provide: Jsonp, useFactory: jsonpFactory, deps: [JSONPBackend, RequestOptions] },\n                            BrowserJsonp,\n                            { provide: RequestOptions, useClass: BaseRequestOptions },\n                            { provide: ResponseOptions, useClass: BaseResponseOptions },\n                            { provide: JSONPBackend, useClass: JSONPBackend_ },\n                        ],\n                    },] },\n        ];\n        /** @nocollapse */\n        JsonpModule.ctorParameters = [];\n        return JsonpModule;\n    }());\n\n    exports.BrowserXhr = BrowserXhr;\n    exports.JSONPBackend = JSONPBackend;\n    exports.JSONPConnection = JSONPConnection;\n    exports.CookieXSRFStrategy = CookieXSRFStrategy;\n    exports.XHRBackend = XHRBackend;\n    exports.XHRConnection = XHRConnection;\n    exports.BaseRequestOptions = BaseRequestOptions;\n    exports.RequestOptions = RequestOptions;\n    exports.BaseResponseOptions = BaseResponseOptions;\n    exports.ResponseOptions = ResponseOptions;\n    exports.Headers = Headers;\n    exports.Http = Http;\n    exports.Jsonp = Jsonp;\n    exports.HttpModule = HttpModule;\n    exports.JsonpModule = JsonpModule;\n    exports.Connection = Connection;\n    exports.ConnectionBackend = ConnectionBackend;\n    exports.XSRFStrategy = XSRFStrategy;\n    exports.Request = Request;\n    exports.Response = Response;\n    exports.QueryEncoder = QueryEncoder;\n    exports.URLSearchParams = URLSearchParams;\n\n}));\n\n/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/@angular/http/bundles/http.umd.js\n ** module id = 24\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/@angular/http/bundles/http.umd.js?");

/***/ },
/* 25 */,
/* 26 */,
/* 27 */,
/* 28 */,
/* 29 */,
/* 30 */,
/* 31 */,
/* 32 */,
/* 33 */,
/* 34 */,
/* 35 */,
/* 36 */,
/* 37 */,
/* 38 */,
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n/* tslint:disable:no-unused-variable */\n// Subject imported before Observable to bypass circular dependency issue since\n// Subject extends Observable and Observable references Subject in it's\n// definition\nvar Subject_1 = __webpack_require__(4);\nexports.Subject = Subject_1.Subject;\n/* tslint:enable:no-unused-variable */\nvar Observable_1 = __webpack_require__(5);\nexports.Observable = Observable_1.Observable;\n// statics\n/* tslint:disable:no-use-before-declare */\n__webpack_require__(40);\n__webpack_require__(44);\n__webpack_require__(47);\n__webpack_require__(59);\n__webpack_require__(63);\n__webpack_require__(66);\n__webpack_require__(68);\n__webpack_require__(71);\n__webpack_require__(79);\n__webpack_require__(82);\n__webpack_require__(85);\n__webpack_require__(87);\n__webpack_require__(89);\n__webpack_require__(92);\n__webpack_require__(101);\n__webpack_require__(104);\n__webpack_require__(106);\n__webpack_require__(110);\n__webpack_require__(112);\n__webpack_require__(114);\n__webpack_require__(117);\n__webpack_require__(120);\n__webpack_require__(123);\n__webpack_require__(126);\n__webpack_require__(130);\n//dom\n__webpack_require__(133);\n__webpack_require__(137);\n//operators\n__webpack_require__(145);\n__webpack_require__(147);\n__webpack_require__(149);\n__webpack_require__(151);\n__webpack_require__(153);\n__webpack_require__(155);\n__webpack_require__(157);\n__webpack_require__(159);\n__webpack_require__(161);\n__webpack_require__(162);\n__webpack_require__(163);\n__webpack_require__(165);\n__webpack_require__(168);\n__webpack_require__(171);\n__webpack_require__(173);\n__webpack_require__(175);\n__webpack_require__(177);\n__webpack_require__(179);\n__webpack_require__(181);\n__webpack_require__(183);\n__webpack_require__(185);\n__webpack_require__(187);\n__webpack_require__(189);\n__webpack_require__(191);\n__webpack_require__(193);\n__webpack_require__(195);\n__webpack_require__(197);\n__webpack_require__(199);\n__webpack_require__(201);\n__webpack_require__(204);\n__webpack_require__(206);\n__webpack_require__(208);\n__webpack_require__(210);\n__webpack_require__(212);\n__webpack_require__(215);\n__webpack_require__(220);\n__webpack_require__(222);\n__webpack_require__(224);\n__webpack_require__(226);\n__webpack_require__(228);\n__webpack_require__(230);\n__webpack_require__(232);\n__webpack_require__(234);\n__webpack_require__(235);\n__webpack_require__(237);\n__webpack_require__(239);\n__webpack_require__(242);\n__webpack_require__(243);\n__webpack_require__(244);\n__webpack_require__(245);\n__webpack_require__(246);\n__webpack_require__(248);\n__webpack_require__(250);\n__webpack_require__(254);\n__webpack_require__(255);\n__webpack_require__(256);\n__webpack_require__(258);\n__webpack_require__(261);\n__webpack_require__(263);\n__webpack_require__(265);\n__webpack_require__(268);\n__webpack_require__(270);\n__webpack_require__(272);\n__webpack_require__(273);\n__webpack_require__(274);\n__webpack_require__(276);\n__webpack_require__(278);\n__webpack_require__(280);\n__webpack_require__(282);\n__webpack_require__(284);\n__webpack_require__(286);\n__webpack_require__(288);\n__webpack_require__(290);\n__webpack_require__(292);\n__webpack_require__(294);\n__webpack_require__(296);\n__webpack_require__(298);\n__webpack_require__(300);\n__webpack_require__(302);\n__webpack_require__(310);\n__webpack_require__(312);\n__webpack_require__(314);\n__webpack_require__(316);\n__webpack_require__(318);\n__webpack_require__(320);\n__webpack_require__(322);\n__webpack_require__(324);\n__webpack_require__(326);\n__webpack_require__(328);\n__webpack_require__(330);\n__webpack_require__(332);\n__webpack_require__(334);\n__webpack_require__(336);\n__webpack_require__(338);\n__webpack_require__(340);\n__webpack_require__(342);\n__webpack_require__(344);\n__webpack_require__(346);\n__webpack_require__(348);\n__webpack_require__(350);\n__webpack_require__(352);\n__webpack_require__(353);\n/* tslint:disable:no-unused-variable */\nvar Subscription_1 = __webpack_require__(10);\nexports.Subscription = Subscription_1.Subscription;\nvar Subscriber_1 = __webpack_require__(8);\nexports.Subscriber = Subscriber_1.Subscriber;\nvar AsyncSubject_1 = __webpack_require__(43);\nexports.AsyncSubject = AsyncSubject_1.AsyncSubject;\nvar ReplaySubject_1 = __webpack_require__(140);\nexports.ReplaySubject = ReplaySubject_1.ReplaySubject;\nvar BehaviorSubject_1 = __webpack_require__(267);\nexports.BehaviorSubject = BehaviorSubject_1.BehaviorSubject;\nvar MulticastObservable_1 = __webpack_require__(252);\nexports.MulticastObservable = MulticastObservable_1.MulticastObservable;\nvar ConnectableObservable_1 = __webpack_require__(253);\nexports.ConnectableObservable = ConnectableObservable_1.ConnectableObservable;\nvar Notification_1 = __webpack_require__(78);\nexports.Notification = Notification_1.Notification;\nvar EmptyError_1 = __webpack_require__(214);\nexports.EmptyError = EmptyError_1.EmptyError;\nvar ArgumentOutOfRangeError_1 = __webpack_require__(203);\nexports.ArgumentOutOfRangeError = ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;\nvar ObjectUnsubscribedError_1 = __webpack_require__(19);\nexports.ObjectUnsubscribedError = ObjectUnsubscribedError_1.ObjectUnsubscribedError;\nvar UnsubscriptionError_1 = __webpack_require__(15);\nexports.UnsubscriptionError = UnsubscriptionError_1.UnsubscriptionError;\nvar timeInterval_1 = __webpack_require__(329);\nexports.TimeInterval = timeInterval_1.TimeInterval;\nvar timestamp_1 = __webpack_require__(335);\nexports.Timestamp = timestamp_1.Timestamp;\nvar TestScheduler_1 = __webpack_require__(355);\nexports.TestScheduler = TestScheduler_1.TestScheduler;\nvar VirtualTimeScheduler_1 = __webpack_require__(361);\nexports.VirtualTimeScheduler = VirtualTimeScheduler_1.VirtualTimeScheduler;\nvar AjaxObservable_1 = __webpack_require__(135);\nexports.AjaxResponse = AjaxObservable_1.AjaxResponse;\nexports.AjaxError = AjaxObservable_1.AjaxError;\nexports.AjaxTimeoutError = AjaxObservable_1.AjaxTimeoutError;\nvar asap_1 = __webpack_require__(305);\nvar async_1 = __webpack_require__(96);\nvar queue_1 = __webpack_require__(141);\nvar animationFrame_1 = __webpack_require__(362);\nvar rxSubscriber_1 = __webpack_require__(17);\nvar iterator_1 = __webpack_require__(57);\nvar observable_1 = __webpack_require__(18);\n/* tslint:enable:no-unused-variable */\n/**\n * @typedef {Object} Rx.Scheduler\n * @property {Scheduler} queue Schedules on a queue in the current event frame\n * (trampoline scheduler). Use this for iteration operations.\n * @property {Scheduler} asap Schedules on the micro task queue, which uses the\n * fastest transport mechanism available, either Node.js' `process.nextTick()`\n * or Web Worker MessageChannel or setTimeout or others. Use this for\n * asynchronous conversions.\n * @property {Scheduler} async Schedules work with `setInterval`. Use this for\n * time-based operations.\n * @property {Scheduler} animationFrame Schedules work with `requestAnimationFrame`.\n * Use this for synchronizing with the platform's painting\n */\nvar Scheduler = {\n    asap: asap_1.asap,\n    queue: queue_1.queue,\n    animationFrame: animationFrame_1.animationFrame,\n    async: async_1.async\n};\nexports.Scheduler = Scheduler;\n/**\n * @typedef {Object} Rx.Symbol\n * @property {Symbol|string} rxSubscriber A symbol to use as a property name to\n * retrieve an \"Rx safe\" Observer from an object. \"Rx safety\" can be defined as\n * an object that has all of the traits of an Rx Subscriber, including the\n * ability to add and remove subscriptions to the subscription chain and\n * guarantees involving event triggering (can't \"next\" after unsubscription,\n * etc).\n * @property {Symbol|string} observable A symbol to use as a property name to\n * retrieve an Observable as defined by the [ECMAScript \"Observable\" spec](https://github.com/zenparsing/es-observable).\n * @property {Symbol|string} iterator The ES6 symbol to use as a property name\n * to retrieve an iterator from an object.\n */\nvar Symbol = {\n    rxSubscriber: rxSubscriber_1.$$rxSubscriber,\n    observable: observable_1.$$observable,\n    iterator: iterator_1.$$iterator\n};\nexports.Symbol = Symbol;\n//# sourceMappingURL=Rx.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/Rx.js\n ** module id = 39\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/Rx.js?");

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar bindCallback_1 = __webpack_require__(41);\nObservable_1.Observable.bindCallback = bindCallback_1.bindCallback;\n//# sourceMappingURL=bindCallback.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/observable/bindCallback.js\n ** module id = 40\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/observable/bindCallback.js?");

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar BoundCallbackObservable_1 = __webpack_require__(42);\nexports.bindCallback = BoundCallbackObservable_1.BoundCallbackObservable.create;\n//# sourceMappingURL=bindCallback.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/observable/bindCallback.js\n ** module id = 41\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/observable/bindCallback.js?");

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = __webpack_require__(5);\nvar tryCatch_1 = __webpack_require__(13);\nvar errorObject_1 = __webpack_require__(14);\nvar AsyncSubject_1 = __webpack_require__(43);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar BoundCallbackObservable = (function (_super) {\n    __extends(BoundCallbackObservable, _super);\n    function BoundCallbackObservable(callbackFunc, selector, args, scheduler) {\n        _super.call(this);\n        this.callbackFunc = callbackFunc;\n        this.selector = selector;\n        this.args = args;\n        this.scheduler = scheduler;\n    }\n    /* tslint:enable:max-line-length */\n    /**\n     * Converts a callback API to a function that returns an Observable.\n     *\n     * <span class=\"informal\">Give it a function `f` of type `f(x, callback)` and\n     * it will return a function `g` that when called as `g(x)` will output an\n     * Observable.</span>\n     *\n     * `bindCallback` is not an operator because its input and output are not\n     * Observables. The input is a function `func` with some parameters, but the\n     * last parameter must be a callback function that `func` calls when it is\n     * done. The output of `bindCallback` is a function that takes the same\n     * parameters as `func`, except the last one (the callback). When the output\n     * function is called with arguments, it will return an Observable where the\n     * results will be delivered to.\n     *\n     * @example <caption>Convert jQuery's getJSON to an Observable API</caption>\n     * // Suppose we have jQuery.getJSON('/my/url', callback)\n     * var getJSONAsObservable = Rx.Observable.bindCallback(jQuery.getJSON);\n     * var result = getJSONAsObservable('/my/url');\n     * result.subscribe(x => console.log(x), e => console.error(e));\n     *\n     * @see {@link bindNodeCallback}\n     * @see {@link from}\n     * @see {@link fromPromise}\n     *\n     * @param {function} func Function with a callback as the last parameter.\n     * @param {function} selector A function which takes the arguments from the\n     * callback and maps those a value to emit on the output Observable.\n     * @param {Scheduler} [scheduler] The scheduler on which to schedule the\n     * callbacks.\n     * @return {function(...params: *): Observable} A function which returns the\n     * Observable that delivers the same values the callback would deliver.\n     * @static true\n     * @name bindCallback\n     * @owner Observable\n     */\n    BoundCallbackObservable.create = function (func, selector, scheduler) {\n        if (selector === void 0) { selector = undefined; }\n        return function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i - 0] = arguments[_i];\n            }\n            return new BoundCallbackObservable(func, selector, args, scheduler);\n        };\n    };\n    BoundCallbackObservable.prototype._subscribe = function (subscriber) {\n        var callbackFunc = this.callbackFunc;\n        var args = this.args;\n        var scheduler = this.scheduler;\n        var subject = this.subject;\n        if (!scheduler) {\n            if (!subject) {\n                subject = this.subject = new AsyncSubject_1.AsyncSubject();\n                var handler = function handlerFn() {\n                    var innerArgs = [];\n                    for (var _i = 0; _i < arguments.length; _i++) {\n                        innerArgs[_i - 0] = arguments[_i];\n                    }\n                    var source = handlerFn.source;\n                    var selector = source.selector, subject = source.subject;\n                    if (selector) {\n                        var result_1 = tryCatch_1.tryCatch(selector).apply(this, innerArgs);\n                        if (result_1 === errorObject_1.errorObject) {\n                            subject.error(errorObject_1.errorObject.e);\n                        }\n                        else {\n                            subject.next(result_1);\n                            subject.complete();\n                        }\n                    }\n                    else {\n                        subject.next(innerArgs.length === 1 ? innerArgs[0] : innerArgs);\n                        subject.complete();\n                    }\n                };\n                // use named function instance to avoid closure.\n                handler.source = this;\n                var result = tryCatch_1.tryCatch(callbackFunc).apply(this, args.concat(handler));\n                if (result === errorObject_1.errorObject) {\n                    subject.error(errorObject_1.errorObject.e);\n                }\n            }\n            return subject.subscribe(subscriber);\n        }\n        else {\n            return scheduler.schedule(BoundCallbackObservable.dispatch, 0, { source: this, subscriber: subscriber });\n        }\n    };\n    BoundCallbackObservable.dispatch = function (state) {\n        var self = this;\n        var source = state.source, subscriber = state.subscriber;\n        var callbackFunc = source.callbackFunc, args = source.args, scheduler = source.scheduler;\n        var subject = source.subject;\n        if (!subject) {\n            subject = source.subject = new AsyncSubject_1.AsyncSubject();\n            var handler = function handlerFn() {\n                var innerArgs = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    innerArgs[_i - 0] = arguments[_i];\n                }\n                var source = handlerFn.source;\n                var selector = source.selector, subject = source.subject;\n                if (selector) {\n                    var result_2 = tryCatch_1.tryCatch(selector).apply(this, innerArgs);\n                    if (result_2 === errorObject_1.errorObject) {\n                        self.add(scheduler.schedule(dispatchError, 0, { err: errorObject_1.errorObject.e, subject: subject }));\n                    }\n                    else {\n                        self.add(scheduler.schedule(dispatchNext, 0, { value: result_2, subject: subject }));\n                    }\n                }\n                else {\n                    var value = innerArgs.length === 1 ? innerArgs[0] : innerArgs;\n                    self.add(scheduler.schedule(dispatchNext, 0, { value: value, subject: subject }));\n                }\n            };\n            // use named function to pass values in without closure\n            handler.source = source;\n            var result = tryCatch_1.tryCatch(callbackFunc).apply(this, args.concat(handler));\n            if (result === errorObject_1.errorObject) {\n                subject.error(errorObject_1.errorObject.e);\n            }\n        }\n        self.add(subject.subscribe(subscriber));\n    };\n    return BoundCallbackObservable;\n}(Observable_1.Observable));\nexports.BoundCallbackObservable = BoundCallbackObservable;\nfunction dispatchNext(arg) {\n    var value = arg.value, subject = arg.subject;\n    subject.next(value);\n    subject.complete();\n}\nfunction dispatchError(arg) {\n    var err = arg.err, subject = arg.subject;\n    subject.error(err);\n}\n//# sourceMappingURL=BoundCallbackObservable.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/observable/BoundCallbackObservable.js\n ** module id = 42\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/observable/BoundCallbackObservable.js?");

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = __webpack_require__(4);\nvar Subscription_1 = __webpack_require__(10);\n/**\n * @class AsyncSubject<T>\n */\nvar AsyncSubject = (function (_super) {\n    __extends(AsyncSubject, _super);\n    function AsyncSubject() {\n        _super.apply(this, arguments);\n        this.value = null;\n        this.hasNext = false;\n        this.hasCompleted = false;\n    }\n    AsyncSubject.prototype._subscribe = function (subscriber) {\n        if (this.hasCompleted && this.hasNext) {\n            subscriber.next(this.value);\n            subscriber.complete();\n            return Subscription_1.Subscription.EMPTY;\n        }\n        else if (this.hasError) {\n            subscriber.error(this.thrownError);\n            return Subscription_1.Subscription.EMPTY;\n        }\n        return _super.prototype._subscribe.call(this, subscriber);\n    };\n    AsyncSubject.prototype.next = function (value) {\n        if (!this.hasCompleted) {\n            this.value = value;\n            this.hasNext = true;\n        }\n    };\n    AsyncSubject.prototype.complete = function () {\n        this.hasCompleted = true;\n        if (this.hasNext) {\n            _super.prototype.next.call(this, this.value);\n        }\n        _super.prototype.complete.call(this);\n    };\n    return AsyncSubject;\n}(Subject_1.Subject));\nexports.AsyncSubject = AsyncSubject;\n//# sourceMappingURL=AsyncSubject.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/AsyncSubject.js\n ** module id = 43\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/AsyncSubject.js?");

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar bindNodeCallback_1 = __webpack_require__(45);\nObservable_1.Observable.bindNodeCallback = bindNodeCallback_1.bindNodeCallback;\n//# sourceMappingURL=bindNodeCallback.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/observable/bindNodeCallback.js\n ** module id = 44\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/observable/bindNodeCallback.js?");

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar BoundNodeCallbackObservable_1 = __webpack_require__(46);\nexports.bindNodeCallback = BoundNodeCallbackObservable_1.BoundNodeCallbackObservable.create;\n//# sourceMappingURL=bindNodeCallback.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/observable/bindNodeCallback.js\n ** module id = 45\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/observable/bindNodeCallback.js?");

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = __webpack_require__(5);\nvar tryCatch_1 = __webpack_require__(13);\nvar errorObject_1 = __webpack_require__(14);\nvar AsyncSubject_1 = __webpack_require__(43);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar BoundNodeCallbackObservable = (function (_super) {\n    __extends(BoundNodeCallbackObservable, _super);\n    function BoundNodeCallbackObservable(callbackFunc, selector, args, scheduler) {\n        _super.call(this);\n        this.callbackFunc = callbackFunc;\n        this.selector = selector;\n        this.args = args;\n        this.scheduler = scheduler;\n    }\n    /* tslint:enable:max-line-length */\n    /**\n     * Converts a Node.js-style callback API to a function that returns an\n     * Observable.\n     *\n     * <span class=\"informal\">It's just like {@link bindCallback}, but the\n     * callback is expected to be of type `callback(error, result)`.</span>\n     *\n     * `bindNodeCallback` is not an operator because its input and output are not\n     * Observables. The input is a function `func` with some parameters, but the\n     * last parameter must be a callback function that `func` calls when it is\n     * done. The callback function is expected to follow Node.js conventions,\n     * where the first argument to the callback is an error, while remaining\n     * arguments are the callback result. The output of `bindNodeCallback` is a\n     * function that takes the same parameters as `func`, except the last one (the\n     * callback). When the output function is called with arguments, it will\n     * return an Observable where the results will be delivered to.\n     *\n     * @example <caption>Read a file from the filesystem and get the data as an Observable</caption>\n     * import * as fs from 'fs';\n     * var readFileAsObservable = Rx.Observable.bindNodeCallback(fs.readFile);\n     * var result = readFileAsObservable('./roadNames.txt', 'utf8');\n     * result.subscribe(x => console.log(x), e => console.error(e));\n     *\n     * @see {@link bindCallback}\n     * @see {@link from}\n     * @see {@link fromPromise}\n     *\n     * @param {function} func Function with a callback as the last parameter.\n     * @param {function} selector A function which takes the arguments from the\n     * callback and maps those a value to emit on the output Observable.\n     * @param {Scheduler} [scheduler] The scheduler on which to schedule the\n     * callbacks.\n     * @return {function(...params: *): Observable} A function which returns the\n     * Observable that delivers the same values the Node.js callback would\n     * deliver.\n     * @static true\n     * @name bindNodeCallback\n     * @owner Observable\n     */\n    BoundNodeCallbackObservable.create = function (func, selector, scheduler) {\n        if (selector === void 0) { selector = undefined; }\n        return function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i - 0] = arguments[_i];\n            }\n            return new BoundNodeCallbackObservable(func, selector, args, scheduler);\n        };\n    };\n    BoundNodeCallbackObservable.prototype._subscribe = function (subscriber) {\n        var callbackFunc = this.callbackFunc;\n        var args = this.args;\n        var scheduler = this.scheduler;\n        var subject = this.subject;\n        if (!scheduler) {\n            if (!subject) {\n                subject = this.subject = new AsyncSubject_1.AsyncSubject();\n                var handler = function handlerFn() {\n                    var innerArgs = [];\n                    for (var _i = 0; _i < arguments.length; _i++) {\n                        innerArgs[_i - 0] = arguments[_i];\n                    }\n                    var source = handlerFn.source;\n                    var selector = source.selector, subject = source.subject;\n                    var err = innerArgs.shift();\n                    if (err) {\n                        subject.error(err);\n                    }\n                    else if (selector) {\n                        var result_1 = tryCatch_1.tryCatch(selector).apply(this, innerArgs);\n                        if (result_1 === errorObject_1.errorObject) {\n                            subject.error(errorObject_1.errorObject.e);\n                        }\n                        else {\n                            subject.next(result_1);\n                            subject.complete();\n                        }\n                    }\n                    else {\n                        subject.next(innerArgs.length === 1 ? innerArgs[0] : innerArgs);\n                        subject.complete();\n                    }\n                };\n                // use named function instance to avoid closure.\n                handler.source = this;\n                var result = tryCatch_1.tryCatch(callbackFunc).apply(this, args.concat(handler));\n                if (result === errorObject_1.errorObject) {\n                    subject.error(errorObject_1.errorObject.e);\n                }\n            }\n            return subject.subscribe(subscriber);\n        }\n        else {\n            return scheduler.schedule(dispatch, 0, { source: this, subscriber: subscriber });\n        }\n    };\n    return BoundNodeCallbackObservable;\n}(Observable_1.Observable));\nexports.BoundNodeCallbackObservable = BoundNodeCallbackObservable;\nfunction dispatch(state) {\n    var self = this;\n    var source = state.source, subscriber = state.subscriber;\n    // XXX: cast to `any` to access to the private field in `source`.\n    var _a = source, callbackFunc = _a.callbackFunc, args = _a.args, scheduler = _a.scheduler;\n    var subject = source.subject;\n    if (!subject) {\n        subject = source.subject = new AsyncSubject_1.AsyncSubject();\n        var handler = function handlerFn() {\n            var innerArgs = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                innerArgs[_i - 0] = arguments[_i];\n            }\n            var source = handlerFn.source;\n            var selector = source.selector, subject = source.subject;\n            var err = innerArgs.shift();\n            if (err) {\n                subject.error(err);\n            }\n            else if (selector) {\n                var result_2 = tryCatch_1.tryCatch(selector).apply(this, innerArgs);\n                if (result_2 === errorObject_1.errorObject) {\n                    self.add(scheduler.schedule(dispatchError, 0, { err: errorObject_1.errorObject.e, subject: subject }));\n                }\n                else {\n                    self.add(scheduler.schedule(dispatchNext, 0, { value: result_2, subject: subject }));\n                }\n            }\n            else {\n                var value = innerArgs.length === 1 ? innerArgs[0] : innerArgs;\n                self.add(scheduler.schedule(dispatchNext, 0, { value: value, subject: subject }));\n            }\n        };\n        // use named function to pass values in without closure\n        handler.source = source;\n        var result = tryCatch_1.tryCatch(callbackFunc).apply(this, args.concat(handler));\n        if (result === errorObject_1.errorObject) {\n            subject.error(errorObject_1.errorObject.e);\n        }\n    }\n    self.add(subject.subscribe(subscriber));\n}\nfunction dispatchNext(arg) {\n    var value = arg.value, subject = arg.subject;\n    subject.next(value);\n    subject.complete();\n}\nfunction dispatchError(arg) {\n    var err = arg.err, subject = arg.subject;\n    subject.error(err);\n}\n//# sourceMappingURL=BoundNodeCallbackObservable.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/observable/BoundNodeCallbackObservable.js\n ** module id = 46\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/observable/BoundNodeCallbackObservable.js?");

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar combineLatest_1 = __webpack_require__(48);\nObservable_1.Observable.combineLatest = combineLatest_1.combineLatest;\n//# sourceMappingURL=combineLatest.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/observable/combineLatest.js\n ** module id = 47\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/observable/combineLatest.js?");

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar isScheduler_1 = __webpack_require__(49);\nvar isArray_1 = __webpack_require__(11);\nvar ArrayObservable_1 = __webpack_require__(50);\nvar combineLatest_1 = __webpack_require__(53);\n/* tslint:enable:max-line-length */\n/**\n * Combines multiple Observables to create an Observable whose values are\n * calculated from the latest values of each of its input Observables.\n *\n * <span class=\"informal\">Whenever any input Observable emits a value, it\n * computes a formula using the latest values from all the inputs, then emits\n * the output of that formula.</span>\n *\n * <img src=\"./img/combineLatest.png\" width=\"100%\">\n *\n * `combineLatest` combines the values from all the Observables passed as\n * arguments. This is done by subscribing to each Observable, in order, and\n * collecting an array of each of the most recent values any time any of the\n * input Observables emits, then either taking that array and passing it as\n * arguments to an optional `project` function and emitting the return value of\n * that, or just emitting the array of recent values directly if there is no\n * `project` function.\n *\n * @example <caption>Dynamically calculate the Body-Mass Index from an Observable of weight and one for height</caption>\n * var weight = Rx.Observable.of(70, 72, 76, 79, 75);\n * var height = Rx.Observable.of(1.76, 1.77, 1.78);\n * var bmi = Rx.Observable.combineLatest(weight, height, (w, h) => w / (h * h));\n * bmi.subscribe(x => console.log('BMI is ' + x));\n *\n * @see {@link combineAll}\n * @see {@link merge}\n * @see {@link withLatestFrom}\n *\n * @param {Observable} observable1 An input Observable to combine with the\n * source Observable.\n * @param {Observable} observable2 An input Observable to combine with the\n * source Observable. More than one input Observables may be given as argument.\n * @param {function} [project] An optional function to project the values from\n * the combined latest values into a new value on the output Observable.\n * @param {Scheduler} [scheduler=null] The Scheduler to use for subscribing to\n * each input Observable.\n * @return {Observable} An Observable of projected values from the most recent\n * values from each input Observable, or an array of the most recent values from\n * each input Observable.\n * @static true\n * @name combineLatest\n * @owner Observable\n */\nfunction combineLatest() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    var project = null;\n    var scheduler = null;\n    if (isScheduler_1.isScheduler(observables[observables.length - 1])) {\n        scheduler = observables.pop();\n    }\n    if (typeof observables[observables.length - 1] === 'function') {\n        project = observables.pop();\n    }\n    // if the first and only other argument besides the resultSelector is an array\n    // assume it's been called with `combineLatest([obs1, obs2, obs3], project)`\n    if (observables.length === 1 && isArray_1.isArray(observables[0])) {\n        observables = observables[0];\n    }\n    return new ArrayObservable_1.ArrayObservable(observables, scheduler).lift(new combineLatest_1.CombineLatestOperator(project));\n}\nexports.combineLatest = combineLatest;\n//# sourceMappingURL=combineLatest.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/observable/combineLatest.js\n ** module id = 48\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/observable/combineLatest.js?");

/***/ },
/* 49 */
/***/ function(module, exports) {

	eval("\"use strict\";\nfunction isScheduler(value) {\n    return value && typeof value.schedule === 'function';\n}\nexports.isScheduler = isScheduler;\n//# sourceMappingURL=isScheduler.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/util/isScheduler.js\n ** module id = 49\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/util/isScheduler.js?");

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = __webpack_require__(5);\nvar ScalarObservable_1 = __webpack_require__(51);\nvar EmptyObservable_1 = __webpack_require__(52);\nvar isScheduler_1 = __webpack_require__(49);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar ArrayObservable = (function (_super) {\n    __extends(ArrayObservable, _super);\n    function ArrayObservable(array, scheduler) {\n        _super.call(this);\n        this.array = array;\n        this.scheduler = scheduler;\n        if (!scheduler && array.length === 1) {\n            this._isScalar = true;\n            this.value = array[0];\n        }\n    }\n    ArrayObservable.create = function (array, scheduler) {\n        return new ArrayObservable(array, scheduler);\n    };\n    /**\n     * Creates an Observable that emits some values you specify as arguments,\n     * immediately one after the other, and then emits a complete notification.\n     *\n     * <span class=\"informal\">Emits the arguments you provide, then completes.\n     * </span>\n     *\n     * <img src=\"./img/of.png\" width=\"100%\">\n     *\n     * This static operator is useful for creating a simple Observable that only\n     * emits the arguments given, and the complete notification thereafter. It can\n     * be used for composing with other Observables, such as with {@link concat}.\n     * By default, it uses a `null` Scheduler, which means the `next`\n     * notifications are sent synchronously, although with a different Scheduler\n     * it is possible to determine when those notifications will be delivered.\n     *\n     * @example <caption>Emit 10, 20, 30, then 'a', 'b', 'c', then start ticking every second.</caption>\n     * var numbers = Rx.Observable.of(10, 20, 30);\n     * var letters = Rx.Observable.of('a', 'b', 'c');\n     * var interval = Rx.Observable.interval(1000);\n     * var result = numbers.concat(letters).concat(interval);\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link create}\n     * @see {@link empty}\n     * @see {@link never}\n     * @see {@link throw}\n     *\n     * @param {...T} values Arguments that represent `next` values to be emitted.\n     * @param {Scheduler} [scheduler] A {@link Scheduler} to use for scheduling\n     * the emissions of the `next` notifications.\n     * @return {Observable<T>} An Observable that emits each given input value.\n     * @static true\n     * @name of\n     * @owner Observable\n     */\n    ArrayObservable.of = function () {\n        var array = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            array[_i - 0] = arguments[_i];\n        }\n        var scheduler = array[array.length - 1];\n        if (isScheduler_1.isScheduler(scheduler)) {\n            array.pop();\n        }\n        else {\n            scheduler = null;\n        }\n        var len = array.length;\n        if (len > 1) {\n            return new ArrayObservable(array, scheduler);\n        }\n        else if (len === 1) {\n            return new ScalarObservable_1.ScalarObservable(array[0], scheduler);\n        }\n        else {\n            return new EmptyObservable_1.EmptyObservable(scheduler);\n        }\n    };\n    ArrayObservable.dispatch = function (state) {\n        var array = state.array, index = state.index, count = state.count, subscriber = state.subscriber;\n        if (index >= count) {\n            subscriber.complete();\n            return;\n        }\n        subscriber.next(array[index]);\n        if (subscriber.closed) {\n            return;\n        }\n        state.index = index + 1;\n        this.schedule(state);\n    };\n    ArrayObservable.prototype._subscribe = function (subscriber) {\n        var index = 0;\n        var array = this.array;\n        var count = array.length;\n        var scheduler = this.scheduler;\n        if (scheduler) {\n            return scheduler.schedule(ArrayObservable.dispatch, 0, {\n                array: array, index: index, count: count, subscriber: subscriber\n            });\n        }\n        else {\n            for (var i = 0; i < count && !subscriber.closed; i++) {\n                subscriber.next(array[i]);\n            }\n            subscriber.complete();\n        }\n    };\n    return ArrayObservable;\n}(Observable_1.Observable));\nexports.ArrayObservable = ArrayObservable;\n//# sourceMappingURL=ArrayObservable.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/observable/ArrayObservable.js\n ** module id = 50\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/observable/ArrayObservable.js?");

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = __webpack_require__(5);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar ScalarObservable = (function (_super) {\n    __extends(ScalarObservable, _super);\n    function ScalarObservable(value, scheduler) {\n        _super.call(this);\n        this.value = value;\n        this.scheduler = scheduler;\n        this._isScalar = true;\n        if (scheduler) {\n            this._isScalar = false;\n        }\n    }\n    ScalarObservable.create = function (value, scheduler) {\n        return new ScalarObservable(value, scheduler);\n    };\n    ScalarObservable.dispatch = function (state) {\n        var done = state.done, value = state.value, subscriber = state.subscriber;\n        if (done) {\n            subscriber.complete();\n            return;\n        }\n        subscriber.next(value);\n        if (subscriber.closed) {\n            return;\n        }\n        state.done = true;\n        this.schedule(state);\n    };\n    ScalarObservable.prototype._subscribe = function (subscriber) {\n        var value = this.value;\n        var scheduler = this.scheduler;\n        if (scheduler) {\n            return scheduler.schedule(ScalarObservable.dispatch, 0, {\n                done: false, value: value, subscriber: subscriber\n            });\n        }\n        else {\n            subscriber.next(value);\n            if (!subscriber.closed) {\n                subscriber.complete();\n            }\n        }\n    };\n    return ScalarObservable;\n}(Observable_1.Observable));\nexports.ScalarObservable = ScalarObservable;\n//# sourceMappingURL=ScalarObservable.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/observable/ScalarObservable.js\n ** module id = 51\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/observable/ScalarObservable.js?");

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = __webpack_require__(5);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar EmptyObservable = (function (_super) {\n    __extends(EmptyObservable, _super);\n    function EmptyObservable(scheduler) {\n        _super.call(this);\n        this.scheduler = scheduler;\n    }\n    /**\n     * Creates an Observable that emits no items to the Observer and immediately\n     * emits a complete notification.\n     *\n     * <span class=\"informal\">Just emits 'complete', and nothing else.\n     * </span>\n     *\n     * <img src=\"./img/empty.png\" width=\"100%\">\n     *\n     * This static operator is useful for creating a simple Observable that only\n     * emits the complete notification. It can be used for composing with other\n     * Observables, such as in a {@link mergeMap}.\n     *\n     * @example <caption>Emit the number 7, then complete.</caption>\n     * var result = Rx.Observable.empty().startWith(7);\n     * result.subscribe(x => console.log(x));\n     *\n     * @example <caption>Map and flatten only odd numbers to the sequence 'a', 'b', 'c'</caption>\n     * var interval = Rx.Observable.interval(1000);\n     * var result = interval.mergeMap(x =>\n     *   x % 2 === 1 ? Rx.Observable.of('a', 'b', 'c') : Rx.Observable.empty()\n     * );\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link create}\n     * @see {@link never}\n     * @see {@link of}\n     * @see {@link throw}\n     *\n     * @param {Scheduler} [scheduler] A {@link Scheduler} to use for scheduling\n     * the emission of the complete notification.\n     * @return {Observable} An \"empty\" Observable: emits only the complete\n     * notification.\n     * @static true\n     * @name empty\n     * @owner Observable\n     */\n    EmptyObservable.create = function (scheduler) {\n        return new EmptyObservable(scheduler);\n    };\n    EmptyObservable.dispatch = function (arg) {\n        var subscriber = arg.subscriber;\n        subscriber.complete();\n    };\n    EmptyObservable.prototype._subscribe = function (subscriber) {\n        var scheduler = this.scheduler;\n        if (scheduler) {\n            return scheduler.schedule(EmptyObservable.dispatch, 0, { subscriber: subscriber });\n        }\n        else {\n            subscriber.complete();\n        }\n    };\n    return EmptyObservable;\n}(Observable_1.Observable));\nexports.EmptyObservable = EmptyObservable;\n//# sourceMappingURL=EmptyObservable.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/observable/EmptyObservable.js\n ** module id = 52\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/observable/EmptyObservable.js?");

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar ArrayObservable_1 = __webpack_require__(50);\nvar isArray_1 = __webpack_require__(11);\nvar OuterSubscriber_1 = __webpack_require__(54);\nvar subscribeToResult_1 = __webpack_require__(55);\nvar none = {};\n/**\n * Combines multiple Observables to create an Observable whose values are\n * calculated from the latest values of each of its input Observables.\n *\n * <span class=\"informal\">Whenever any input Observable emits a value, it\n * computes a formula using the latest values from all the inputs, then emits\n * the output of that formula.</span>\n *\n * <img src=\"./img/combineLatest.png\" width=\"100%\">\n *\n * `combineLatest` combines the values from this Observable with values from\n * Observables passed as arguments. This is done by subscribing to each\n * Observable, in order, and collecting an array of each of the most recent\n * values any time any of the input Observables emits, then either taking that\n * array and passing it as arguments to an optional `project` function and\n * emitting the return value of that, or just emitting the array of recent\n * values directly if there is no `project` function.\n *\n * @example <caption>Dynamically calculate the Body-Mass Index from an Observable of weight and one for height</caption>\n * var weight = Rx.Observable.of(70, 72, 76, 79, 75);\n * var height = Rx.Observable.of(1.76, 1.77, 1.78);\n * var bmi = weight.combineLatest(height, (w, h) => w / (h * h));\n * bmi.subscribe(x => console.log('BMI is ' + x));\n *\n * @see {@link combineAll}\n * @see {@link merge}\n * @see {@link withLatestFrom}\n *\n * @param {Observable} other An input Observable to combine with the source\n * Observable. More than one input Observables may be given as argument.\n * @param {function} [project] An optional function to project the values from\n * the combined latest values into a new value on the output Observable.\n * @return {Observable} An Observable of projected values from the most recent\n * values from each input Observable, or an array of the most recent values from\n * each input Observable.\n * @method combineLatest\n * @owner Observable\n */\nfunction combineLatest() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    var project = null;\n    if (typeof observables[observables.length - 1] === 'function') {\n        project = observables.pop();\n    }\n    // if the first and only other argument besides the resultSelector is an array\n    // assume it's been called with `combineLatest([obs1, obs2, obs3], project)`\n    if (observables.length === 1 && isArray_1.isArray(observables[0])) {\n        observables = observables[0];\n    }\n    observables.unshift(this);\n    return new ArrayObservable_1.ArrayObservable(observables).lift(new CombineLatestOperator(project));\n}\nexports.combineLatest = combineLatest;\n/* tslint:enable:max-line-length */\nvar CombineLatestOperator = (function () {\n    function CombineLatestOperator(project) {\n        this.project = project;\n    }\n    CombineLatestOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new CombineLatestSubscriber(subscriber, this.project));\n    };\n    return CombineLatestOperator;\n}());\nexports.CombineLatestOperator = CombineLatestOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar CombineLatestSubscriber = (function (_super) {\n    __extends(CombineLatestSubscriber, _super);\n    function CombineLatestSubscriber(destination, project) {\n        _super.call(this, destination);\n        this.project = project;\n        this.active = 0;\n        this.values = [];\n        this.observables = [];\n    }\n    CombineLatestSubscriber.prototype._next = function (observable) {\n        this.values.push(none);\n        this.observables.push(observable);\n    };\n    CombineLatestSubscriber.prototype._complete = function () {\n        var observables = this.observables;\n        var len = observables.length;\n        if (len === 0) {\n            this.destination.complete();\n        }\n        else {\n            this.active = len;\n            this.toRespond = len;\n            for (var i = 0; i < len; i++) {\n                var observable = observables[i];\n                this.add(subscribeToResult_1.subscribeToResult(this, observable, observable, i));\n            }\n        }\n    };\n    CombineLatestSubscriber.prototype.notifyComplete = function (unused) {\n        if ((this.active -= 1) === 0) {\n            this.destination.complete();\n        }\n    };\n    CombineLatestSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        var values = this.values;\n        var oldVal = values[outerIndex];\n        var toRespond = !this.toRespond\n            ? 0\n            : oldVal === none ? --this.toRespond : this.toRespond;\n        values[outerIndex] = innerValue;\n        if (toRespond === 0) {\n            if (this.project) {\n                this._tryProject(values);\n            }\n            else {\n                this.destination.next(values.slice());\n            }\n        }\n    };\n    CombineLatestSubscriber.prototype._tryProject = function (values) {\n        var result;\n        try {\n            result = this.project.apply(this, values);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.destination.next(result);\n    };\n    return CombineLatestSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\nexports.CombineLatestSubscriber = CombineLatestSubscriber;\n//# sourceMappingURL=combineLatest.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/combineLatest.js\n ** module id = 53\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/combineLatest.js?");

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(8);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar OuterSubscriber = (function (_super) {\n    __extends(OuterSubscriber, _super);\n    function OuterSubscriber() {\n        _super.apply(this, arguments);\n    }\n    OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.destination.next(innerValue);\n    };\n    OuterSubscriber.prototype.notifyError = function (error, innerSub) {\n        this.destination.error(error);\n    };\n    OuterSubscriber.prototype.notifyComplete = function (innerSub) {\n        this.destination.complete();\n    };\n    return OuterSubscriber;\n}(Subscriber_1.Subscriber));\nexports.OuterSubscriber = OuterSubscriber;\n//# sourceMappingURL=OuterSubscriber.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/OuterSubscriber.js\n ** module id = 54\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/OuterSubscriber.js?");

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar root_1 = __webpack_require__(6);\nvar isArray_1 = __webpack_require__(11);\nvar isPromise_1 = __webpack_require__(56);\nvar Observable_1 = __webpack_require__(5);\nvar iterator_1 = __webpack_require__(57);\nvar InnerSubscriber_1 = __webpack_require__(58);\nvar observable_1 = __webpack_require__(18);\nfunction subscribeToResult(outerSubscriber, result, outerValue, outerIndex) {\n    var destination = new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex);\n    if (destination.closed) {\n        return null;\n    }\n    if (result instanceof Observable_1.Observable) {\n        if (result._isScalar) {\n            destination.next(result.value);\n            destination.complete();\n            return null;\n        }\n        else {\n            return result.subscribe(destination);\n        }\n    }\n    if (isArray_1.isArray(result)) {\n        for (var i = 0, len = result.length; i < len && !destination.closed; i++) {\n            destination.next(result[i]);\n        }\n        if (!destination.closed) {\n            destination.complete();\n        }\n    }\n    else if (isPromise_1.isPromise(result)) {\n        result.then(function (value) {\n            if (!destination.closed) {\n                destination.next(value);\n                destination.complete();\n            }\n        }, function (err) { return destination.error(err); })\n            .then(null, function (err) {\n            // Escaping the Promise trap: globally throw unhandled errors\n            root_1.root.setTimeout(function () { throw err; });\n        });\n        return destination;\n    }\n    else if (typeof result[iterator_1.$$iterator] === 'function') {\n        var iterator = result[iterator_1.$$iterator]();\n        do {\n            var item = iterator.next();\n            if (item.done) {\n                destination.complete();\n                break;\n            }\n            destination.next(item.value);\n            if (destination.closed) {\n                break;\n            }\n        } while (true);\n    }\n    else if (typeof result[observable_1.$$observable] === 'function') {\n        var obs = result[observable_1.$$observable]();\n        if (typeof obs.subscribe !== 'function') {\n            destination.error(new Error('invalid observable'));\n        }\n        else {\n            return obs.subscribe(new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex));\n        }\n    }\n    else {\n        destination.error(new TypeError('unknown type returned'));\n    }\n    return null;\n}\nexports.subscribeToResult = subscribeToResult;\n//# sourceMappingURL=subscribeToResult.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/util/subscribeToResult.js\n ** module id = 55\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/util/subscribeToResult.js?");

/***/ },
/* 56 */
/***/ function(module, exports) {

	eval("\"use strict\";\nfunction isPromise(value) {\n    return value && typeof value.subscribe !== 'function' && typeof value.then === 'function';\n}\nexports.isPromise = isPromise;\n//# sourceMappingURL=isPromise.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/util/isPromise.js\n ** module id = 56\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/util/isPromise.js?");

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar root_1 = __webpack_require__(6);\nvar Symbol = root_1.root.Symbol;\nif (typeof Symbol === 'function') {\n    if (Symbol.iterator) {\n        exports.$$iterator = Symbol.iterator;\n    }\n    else if (typeof Symbol.for === 'function') {\n        exports.$$iterator = Symbol.for('iterator');\n    }\n}\nelse {\n    if (root_1.root.Set && typeof new root_1.root.Set()['@@iterator'] === 'function') {\n        // Bug for mozilla version\n        exports.$$iterator = '@@iterator';\n    }\n    else if (root_1.root.Map) {\n        // es6-shim specific logic\n        var keys = Object.getOwnPropertyNames(root_1.root.Map.prototype);\n        for (var i = 0; i < keys.length; ++i) {\n            var key = keys[i];\n            if (key !== 'entries' && key !== 'size' && root_1.root.Map.prototype[key] === root_1.root.Map.prototype['entries']) {\n                exports.$$iterator = key;\n                break;\n            }\n        }\n    }\n    else {\n        exports.$$iterator = '@@iterator';\n    }\n}\n//# sourceMappingURL=iterator.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/symbol/iterator.js\n ** module id = 57\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/symbol/iterator.js?");

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(8);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar InnerSubscriber = (function (_super) {\n    __extends(InnerSubscriber, _super);\n    function InnerSubscriber(parent, outerValue, outerIndex) {\n        _super.call(this);\n        this.parent = parent;\n        this.outerValue = outerValue;\n        this.outerIndex = outerIndex;\n        this.index = 0;\n    }\n    InnerSubscriber.prototype._next = function (value) {\n        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);\n    };\n    InnerSubscriber.prototype._error = function (error) {\n        this.parent.notifyError(error, this);\n        this.unsubscribe();\n    };\n    InnerSubscriber.prototype._complete = function () {\n        this.parent.notifyComplete(this);\n        this.unsubscribe();\n    };\n    return InnerSubscriber;\n}(Subscriber_1.Subscriber));\nexports.InnerSubscriber = InnerSubscriber;\n//# sourceMappingURL=InnerSubscriber.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/InnerSubscriber.js\n ** module id = 58\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/InnerSubscriber.js?");

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar concat_1 = __webpack_require__(60);\nObservable_1.Observable.concat = concat_1.concat;\n//# sourceMappingURL=concat.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/observable/concat.js\n ** module id = 59\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/observable/concat.js?");

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar concat_1 = __webpack_require__(61);\nexports.concat = concat_1.concatStatic;\n//# sourceMappingURL=concat.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/observable/concat.js\n ** module id = 60\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/observable/concat.js?");

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar isScheduler_1 = __webpack_require__(49);\nvar ArrayObservable_1 = __webpack_require__(50);\nvar mergeAll_1 = __webpack_require__(62);\n/**\n * Creates an output Observable which sequentially emits all values from every\n * given input Observable after the current Observable.\n *\n * <span class=\"informal\">Concatenates multiple Observables together by\n * sequentially emitting their values, one Observable after the other.</span>\n *\n * <img src=\"./img/concat.png\" width=\"100%\">\n *\n * Joins this Observable with multiple other Observables by subscribing to them\n * one at a time, starting with the source, and merging their results into the\n * output Observable. Will wait for each Observable to complete before moving\n * on to the next.\n *\n * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>\n * var timer = Rx.Observable.interval(1000).take(4);\n * var sequence = Rx.Observable.range(1, 10);\n * var result = timer.concat(sequence);\n * result.subscribe(x => console.log(x));\n *\n * @example <caption>Concatenate 3 Observables</caption>\n * var timer1 = Rx.Observable.interval(1000).take(10);\n * var timer2 = Rx.Observable.interval(2000).take(6);\n * var timer3 = Rx.Observable.interval(500).take(10);\n * var result = timer1.concat(timer2, timer3);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatAll}\n * @see {@link concatMap}\n * @see {@link concatMapTo}\n *\n * @param {Observable} other An input Observable to concatenate after the source\n * Observable. More than one input Observables may be given as argument.\n * @param {Scheduler} [scheduler=null] An optional Scheduler to schedule each\n * Observable subscription on.\n * @return {Observable} All values of each passed Observable merged into a\n * single Observable, in order, in serial fashion.\n * @method concat\n * @owner Observable\n */\nfunction concat() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    return concatStatic.apply(void 0, [this].concat(observables));\n}\nexports.concat = concat;\n/* tslint:enable:max-line-length */\n/**\n * Creates an output Observable which sequentially emits all values from every\n * given input Observable after the current Observable.\n *\n * <span class=\"informal\">Concatenates multiple Observables together by\n * sequentially emitting their values, one Observable after the other.</span>\n *\n * <img src=\"./img/concat.png\" width=\"100%\">\n *\n * Joins multiple Observables together by subscribing to them one at a time and\n * merging their results into the output Observable. Will wait for each\n * Observable to complete before moving on to the next.\n *\n * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>\n * var timer = Rx.Observable.interval(1000).take(4);\n * var sequence = Rx.Observable.range(1, 10);\n * var result = Rx.Observable.concat(timer, sequence);\n * result.subscribe(x => console.log(x));\n *\n * @example <caption>Concatenate 3 Observables</caption>\n * var timer1 = Rx.Observable.interval(1000).take(10);\n * var timer2 = Rx.Observable.interval(2000).take(6);\n * var timer3 = Rx.Observable.interval(500).take(10);\n * var result = Rx.Observable.concat(timer1, timer2, timer3);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatAll}\n * @see {@link concatMap}\n * @see {@link concatMapTo}\n *\n * @param {Observable} input1 An input Observable to concatenate with others.\n * @param {Observable} input2 An input Observable to concatenate with others.\n * More than one input Observables may be given as argument.\n * @param {Scheduler} [scheduler=null] An optional Scheduler to schedule each\n * Observable subscription on.\n * @return {Observable} All values of each passed Observable merged into a\n * single Observable, in order, in serial fashion.\n * @static true\n * @name concat\n * @owner Observable\n */\nfunction concatStatic() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    var scheduler = null;\n    var args = observables;\n    if (isScheduler_1.isScheduler(args[observables.length - 1])) {\n        scheduler = args.pop();\n    }\n    return new ArrayObservable_1.ArrayObservable(observables, scheduler).lift(new mergeAll_1.MergeAllOperator(1));\n}\nexports.concatStatic = concatStatic;\n//# sourceMappingURL=concat.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/concat.js\n ** module id = 61\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/concat.js?");

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = __webpack_require__(54);\nvar subscribeToResult_1 = __webpack_require__(55);\n/**\n * Converts a higher-order Observable into a first-order Observable which\n * concurrently delivers all values that are emitted on the inner Observables.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables.</span>\n *\n * <img src=\"./img/mergeAll.png\" width=\"100%\">\n *\n * `mergeAll` subscribes to an Observable that emits Observables, also known as\n * a higher-order Observable. Each time it observes one of these emitted inner\n * Observables, it subscribes to that and delivers all the values from the\n * inner Observable on the output Observable. The output Observable only\n * completes once all inner Observables have completed. Any error delivered by\n * a inner Observable will be immediately emitted on the output Observable.\n *\n * @example <caption>Spawn a new interval Observable for each click event, and blend their outputs as one Observable</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));\n * var firstOrder = higherOrder.mergeAll();\n * firstOrder.subscribe(x => console.log(x));\n *\n * @example <caption>Count from 0 to 9 every second for each click, but only allow 2 concurrent timers</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000).take(10));\n * var firstOrder = higherOrder.mergeAll(2);\n * firstOrder.subscribe(x => console.log(x));\n *\n * @see {@link combineAll}\n * @see {@link concatAll}\n * @see {@link exhaust}\n * @see {@link merge}\n * @see {@link mergeMap}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n * @see {@link switch}\n * @see {@link zipAll}\n *\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of inner\n * Observables being subscribed to concurrently.\n * @return {Observable} An Observable that emits values coming from all the\n * inner Observables emitted by the source Observable.\n * @method mergeAll\n * @owner Observable\n */\nfunction mergeAll(concurrent) {\n    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n    return this.lift(new MergeAllOperator(concurrent));\n}\nexports.mergeAll = mergeAll;\nvar MergeAllOperator = (function () {\n    function MergeAllOperator(concurrent) {\n        this.concurrent = concurrent;\n    }\n    MergeAllOperator.prototype.call = function (observer, source) {\n        return source._subscribe(new MergeAllSubscriber(observer, this.concurrent));\n    };\n    return MergeAllOperator;\n}());\nexports.MergeAllOperator = MergeAllOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar MergeAllSubscriber = (function (_super) {\n    __extends(MergeAllSubscriber, _super);\n    function MergeAllSubscriber(destination, concurrent) {\n        _super.call(this, destination);\n        this.concurrent = concurrent;\n        this.hasCompleted = false;\n        this.buffer = [];\n        this.active = 0;\n    }\n    MergeAllSubscriber.prototype._next = function (observable) {\n        if (this.active < this.concurrent) {\n            this.active++;\n            this.add(subscribeToResult_1.subscribeToResult(this, observable));\n        }\n        else {\n            this.buffer.push(observable);\n        }\n    };\n    MergeAllSubscriber.prototype._complete = function () {\n        this.hasCompleted = true;\n        if (this.active === 0 && this.buffer.length === 0) {\n            this.destination.complete();\n        }\n    };\n    MergeAllSubscriber.prototype.notifyComplete = function (innerSub) {\n        var buffer = this.buffer;\n        this.remove(innerSub);\n        this.active--;\n        if (buffer.length > 0) {\n            this._next(buffer.shift());\n        }\n        else if (this.active === 0 && this.hasCompleted) {\n            this.destination.complete();\n        }\n    };\n    return MergeAllSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\nexports.MergeAllSubscriber = MergeAllSubscriber;\n//# sourceMappingURL=mergeAll.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/mergeAll.js\n ** module id = 62\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/mergeAll.js?");

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar defer_1 = __webpack_require__(64);\nObservable_1.Observable.defer = defer_1.defer;\n//# sourceMappingURL=defer.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/observable/defer.js\n ** module id = 63\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/observable/defer.js?");

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar DeferObservable_1 = __webpack_require__(65);\nexports.defer = DeferObservable_1.DeferObservable.create;\n//# sourceMappingURL=defer.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/observable/defer.js\n ** module id = 64\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/observable/defer.js?");

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = __webpack_require__(5);\nvar subscribeToResult_1 = __webpack_require__(55);\nvar OuterSubscriber_1 = __webpack_require__(54);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar DeferObservable = (function (_super) {\n    __extends(DeferObservable, _super);\n    function DeferObservable(observableFactory) {\n        _super.call(this);\n        this.observableFactory = observableFactory;\n    }\n    /**\n     * Creates an Observable that, on subscribe, calls an Observable factory to\n     * make an Observable for each new Observer.\n     *\n     * <span class=\"informal\">Creates the Observable lazily, that is, only when it\n     * is subscribed.\n     * </span>\n     *\n     * <img src=\"./img/defer.png\" width=\"100%\">\n     *\n     * `defer` allows you to create the Observable only when the Observer\n     * subscribes, and create a fresh Observable for each Observer. It waits until\n     * an Observer subscribes to it, and then it generates an Observable,\n     * typically with an Observable factory function. It does this afresh for each\n     * subscriber, so although each subscriber may think it is subscribing to the\n     * same Observable, in fact each subscriber gets its own individual\n     * Observable.\n     *\n     * @example <caption>Subscribe to either an Observable of clicks or an Observable of interval, at random</caption>\n     * var clicksOrInterval = Rx.Observable.defer(function () {\n     *   if (Math.random() > 0.5) {\n     *     return Rx.Observable.fromEvent(document, 'click');\n     *   } else {\n     *     return Rx.Observable.interval(1000);\n     *   }\n     * });\n     * clicksOrInterval.subscribe(x => console.log(x));\n     *\n     * @see {@link create}\n     *\n     * @param {function(): Observable|Promise} observableFactory The Observable\n     * factory function to invoke for each Observer that subscribes to the output\n     * Observable. May also return a Promise, which will be converted on the fly\n     * to an Observable.\n     * @return {Observable} An Observable whose Observers' subscriptions trigger\n     * an invocation of the given Observable factory function.\n     * @static true\n     * @name defer\n     * @owner Observable\n     */\n    DeferObservable.create = function (observableFactory) {\n        return new DeferObservable(observableFactory);\n    };\n    DeferObservable.prototype._subscribe = function (subscriber) {\n        return new DeferSubscriber(subscriber, this.observableFactory);\n    };\n    return DeferObservable;\n}(Observable_1.Observable));\nexports.DeferObservable = DeferObservable;\nvar DeferSubscriber = (function (_super) {\n    __extends(DeferSubscriber, _super);\n    function DeferSubscriber(destination, factory) {\n        _super.call(this, destination);\n        this.factory = factory;\n        this.tryDefer();\n    }\n    DeferSubscriber.prototype.tryDefer = function () {\n        try {\n            this._callFactory();\n        }\n        catch (err) {\n            this._error(err);\n        }\n    };\n    DeferSubscriber.prototype._callFactory = function () {\n        var result = this.factory();\n        if (result) {\n            this.add(subscribeToResult_1.subscribeToResult(this, result));\n        }\n    };\n    return DeferSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=DeferObservable.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/observable/DeferObservable.js\n ** module id = 65\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/observable/DeferObservable.js?");

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar empty_1 = __webpack_require__(67);\nObservable_1.Observable.empty = empty_1.empty;\n//# sourceMappingURL=empty.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/observable/empty.js\n ** module id = 66\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/observable/empty.js?");

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar EmptyObservable_1 = __webpack_require__(52);\nexports.empty = EmptyObservable_1.EmptyObservable.create;\n//# sourceMappingURL=empty.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/observable/empty.js\n ** module id = 67\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/observable/empty.js?");

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar forkJoin_1 = __webpack_require__(69);\nObservable_1.Observable.forkJoin = forkJoin_1.forkJoin;\n//# sourceMappingURL=forkJoin.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/observable/forkJoin.js\n ** module id = 68\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/observable/forkJoin.js?");

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar ForkJoinObservable_1 = __webpack_require__(70);\nexports.forkJoin = ForkJoinObservable_1.ForkJoinObservable.create;\n//# sourceMappingURL=forkJoin.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/observable/forkJoin.js\n ** module id = 69\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/observable/forkJoin.js?");

/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = __webpack_require__(5);\nvar EmptyObservable_1 = __webpack_require__(52);\nvar isArray_1 = __webpack_require__(11);\nvar subscribeToResult_1 = __webpack_require__(55);\nvar OuterSubscriber_1 = __webpack_require__(54);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar ForkJoinObservable = (function (_super) {\n    __extends(ForkJoinObservable, _super);\n    function ForkJoinObservable(sources, resultSelector) {\n        _super.call(this);\n        this.sources = sources;\n        this.resultSelector = resultSelector;\n    }\n    /* tslint:enable:max-line-length */\n    /**\n     * @param sources\n     * @return {any}\n     * @static true\n     * @name forkJoin\n     * @owner Observable\n     */\n    ForkJoinObservable.create = function () {\n        var sources = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            sources[_i - 0] = arguments[_i];\n        }\n        if (sources === null || arguments.length === 0) {\n            return new EmptyObservable_1.EmptyObservable();\n        }\n        var resultSelector = null;\n        if (typeof sources[sources.length - 1] === 'function') {\n            resultSelector = sources.pop();\n        }\n        // if the first and only other argument besides the resultSelector is an array\n        // assume it's been called with `forkJoin([obs1, obs2, obs3], resultSelector)`\n        if (sources.length === 1 && isArray_1.isArray(sources[0])) {\n            sources = sources[0];\n        }\n        if (sources.length === 0) {\n            return new EmptyObservable_1.EmptyObservable();\n        }\n        return new ForkJoinObservable(sources, resultSelector);\n    };\n    ForkJoinObservable.prototype._subscribe = function (subscriber) {\n        return new ForkJoinSubscriber(subscriber, this.sources, this.resultSelector);\n    };\n    return ForkJoinObservable;\n}(Observable_1.Observable));\nexports.ForkJoinObservable = ForkJoinObservable;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar ForkJoinSubscriber = (function (_super) {\n    __extends(ForkJoinSubscriber, _super);\n    function ForkJoinSubscriber(destination, sources, resultSelector) {\n        _super.call(this, destination);\n        this.sources = sources;\n        this.resultSelector = resultSelector;\n        this.completed = 0;\n        this.haveValues = 0;\n        var len = sources.length;\n        this.total = len;\n        this.values = new Array(len);\n        for (var i = 0; i < len; i++) {\n            var source = sources[i];\n            var innerSubscription = subscribeToResult_1.subscribeToResult(this, source, null, i);\n            if (innerSubscription) {\n                innerSubscription.outerIndex = i;\n                this.add(innerSubscription);\n            }\n        }\n    }\n    ForkJoinSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.values[outerIndex] = innerValue;\n        if (!innerSub._hasValue) {\n            innerSub._hasValue = true;\n            this.haveValues++;\n        }\n    };\n    ForkJoinSubscriber.prototype.notifyComplete = function (innerSub) {\n        var destination = this.destination;\n        var _a = this, haveValues = _a.haveValues, resultSelector = _a.resultSelector, values = _a.values;\n        var len = values.length;\n        if (!innerSub._hasValue) {\n            destination.complete();\n            return;\n        }\n        this.completed++;\n        if (this.completed !== len) {\n            return;\n        }\n        if (haveValues === len) {\n            var value = resultSelector ? resultSelector.apply(this, values) : values;\n            destination.next(value);\n        }\n        destination.complete();\n    };\n    return ForkJoinSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=ForkJoinObservable.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/observable/ForkJoinObservable.js\n ** module id = 70\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/observable/ForkJoinObservable.js?");

/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar from_1 = __webpack_require__(72);\nObservable_1.Observable.from = from_1.from;\n//# sourceMappingURL=from.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/observable/from.js\n ** module id = 71\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/observable/from.js?");

/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar FromObservable_1 = __webpack_require__(73);\nexports.from = FromObservable_1.FromObservable.create;\n//# sourceMappingURL=from.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/observable/from.js\n ** module id = 72\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/observable/from.js?");

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar isArray_1 = __webpack_require__(11);\nvar isPromise_1 = __webpack_require__(56);\nvar PromiseObservable_1 = __webpack_require__(74);\nvar IteratorObservable_1 = __webpack_require__(75);\nvar ArrayObservable_1 = __webpack_require__(50);\nvar ArrayLikeObservable_1 = __webpack_require__(76);\nvar iterator_1 = __webpack_require__(57);\nvar Observable_1 = __webpack_require__(5);\nvar observeOn_1 = __webpack_require__(77);\nvar observable_1 = __webpack_require__(18);\nvar isArrayLike = (function (x) { return x && typeof x.length === 'number'; });\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar FromObservable = (function (_super) {\n    __extends(FromObservable, _super);\n    function FromObservable(ish, scheduler) {\n        _super.call(this, null);\n        this.ish = ish;\n        this.scheduler = scheduler;\n    }\n    /**\n     * Creates an Observable from an Array, an array-like object, a Promise, an\n     * iterable object, or an Observable-like object.\n     *\n     * <span class=\"informal\">Converts almost anything to an Observable.</span>\n     *\n     * <img src=\"./img/from.png\" width=\"100%\">\n     *\n     * Convert various other objects and data types into Observables. `from`\n     * converts a Promise or an array-like or an\n     * [iterable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable)\n     * object into an Observable that emits the items in that promise or array or\n     * iterable. A String, in this context, is treated as an array of characters.\n     * Observable-like objects (contains a function named with the ES2015 Symbol\n     * for Observable) can also be converted through this operator.\n     *\n     * @example <caption>Converts an array to an Observable</caption>\n     * var array = [10, 20, 30];\n     * var result = Rx.Observable.from(array);\n     * result.subscribe(x => console.log(x));\n     *\n     * @example <caption>Convert an infinite iterable (from a generator) to an Observable</caption>\n     * function* generateDoubles(seed) {\n     *   var i = seed;\n     *   while (true) {\n     *     yield i;\n     *     i = 2 * i; // double it\n     *   }\n     * }\n     *\n     * var iterator = generateDoubles(3);\n     * var result = Rx.Observable.from(iterator).take(10);\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link create}\n     * @see {@link fromEvent}\n     * @see {@link fromEventPattern}\n     * @see {@link fromPromise}\n     *\n     * @param {ObservableInput<T>} ish A subscribable object, a Promise, an\n     * Observable-like, an Array, an iterable or an array-like object to be\n     * converted.\n     * @param {Scheduler} [scheduler] The scheduler on which to schedule the\n     * emissions of values.\n     * @return {Observable<T>} The Observable whose values are originally from the\n     * input object that was converted.\n     * @static true\n     * @name from\n     * @owner Observable\n     */\n    FromObservable.create = function (ish, scheduler) {\n        if (ish != null) {\n            if (typeof ish[observable_1.$$observable] === 'function') {\n                if (ish instanceof Observable_1.Observable && !scheduler) {\n                    return ish;\n                }\n                return new FromObservable(ish, scheduler);\n            }\n            else if (isArray_1.isArray(ish)) {\n                return new ArrayObservable_1.ArrayObservable(ish, scheduler);\n            }\n            else if (isPromise_1.isPromise(ish)) {\n                return new PromiseObservable_1.PromiseObservable(ish, scheduler);\n            }\n            else if (typeof ish[iterator_1.$$iterator] === 'function' || typeof ish === 'string') {\n                return new IteratorObservable_1.IteratorObservable(ish, scheduler);\n            }\n            else if (isArrayLike(ish)) {\n                return new ArrayLikeObservable_1.ArrayLikeObservable(ish, scheduler);\n            }\n        }\n        throw new TypeError((ish !== null && typeof ish || ish) + ' is not observable');\n    };\n    FromObservable.prototype._subscribe = function (subscriber) {\n        var ish = this.ish;\n        var scheduler = this.scheduler;\n        if (scheduler == null) {\n            return ish[observable_1.$$observable]().subscribe(subscriber);\n        }\n        else {\n            return ish[observable_1.$$observable]().subscribe(new observeOn_1.ObserveOnSubscriber(subscriber, scheduler, 0));\n        }\n    };\n    return FromObservable;\n}(Observable_1.Observable));\nexports.FromObservable = FromObservable;\n//# sourceMappingURL=FromObservable.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/observable/FromObservable.js\n ** module id = 73\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/observable/FromObservable.js?");

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar root_1 = __webpack_require__(6);\nvar Observable_1 = __webpack_require__(5);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar PromiseObservable = (function (_super) {\n    __extends(PromiseObservable, _super);\n    function PromiseObservable(promise, scheduler) {\n        _super.call(this);\n        this.promise = promise;\n        this.scheduler = scheduler;\n    }\n    /**\n     * Converts a Promise to an Observable.\n     *\n     * <span class=\"informal\">Returns an Observable that just emits the Promise's\n     * resolved value, then completes.</span>\n     *\n     * Converts an ES2015 Promise or a Promises/A+ spec compliant Promise to an\n     * Observable. If the Promise resolves with a value, the output Observable\n     * emits that resolved value as a `next`, and then completes. If the Promise\n     * is rejected, then the output Observable emits the corresponding Error.\n     *\n     * @example <caption>Convert the Promise returned by Fetch to an Observable</caption>\n     * var result = Rx.Observable.fromPromise(fetch('http://myserver.com/'));\n     * result.subscribe(x => console.log(x), e => console.error(e));\n     *\n     * @see {@link bindCallback}\n     * @see {@link from}\n     *\n     * @param {Promise<T>} promise The promise to be converted.\n     * @param {Scheduler} [scheduler] An optional Scheduler to use for scheduling\n     * the delivery of the resolved value (or the rejection).\n     * @return {Observable<T>} An Observable which wraps the Promise.\n     * @static true\n     * @name fromPromise\n     * @owner Observable\n     */\n    PromiseObservable.create = function (promise, scheduler) {\n        return new PromiseObservable(promise, scheduler);\n    };\n    PromiseObservable.prototype._subscribe = function (subscriber) {\n        var _this = this;\n        var promise = this.promise;\n        var scheduler = this.scheduler;\n        if (scheduler == null) {\n            if (this._isScalar) {\n                if (!subscriber.closed) {\n                    subscriber.next(this.value);\n                    subscriber.complete();\n                }\n            }\n            else {\n                promise.then(function (value) {\n                    _this.value = value;\n                    _this._isScalar = true;\n                    if (!subscriber.closed) {\n                        subscriber.next(value);\n                        subscriber.complete();\n                    }\n                }, function (err) {\n                    if (!subscriber.closed) {\n                        subscriber.error(err);\n                    }\n                })\n                    .then(null, function (err) {\n                    // escape the promise trap, throw unhandled errors\n                    root_1.root.setTimeout(function () { throw err; });\n                });\n            }\n        }\n        else {\n            if (this._isScalar) {\n                if (!subscriber.closed) {\n                    return scheduler.schedule(dispatchNext, 0, { value: this.value, subscriber: subscriber });\n                }\n            }\n            else {\n                promise.then(function (value) {\n                    _this.value = value;\n                    _this._isScalar = true;\n                    if (!subscriber.closed) {\n                        subscriber.add(scheduler.schedule(dispatchNext, 0, { value: value, subscriber: subscriber }));\n                    }\n                }, function (err) {\n                    if (!subscriber.closed) {\n                        subscriber.add(scheduler.schedule(dispatchError, 0, { err: err, subscriber: subscriber }));\n                    }\n                })\n                    .then(null, function (err) {\n                    // escape the promise trap, throw unhandled errors\n                    root_1.root.setTimeout(function () { throw err; });\n                });\n            }\n        }\n    };\n    return PromiseObservable;\n}(Observable_1.Observable));\nexports.PromiseObservable = PromiseObservable;\nfunction dispatchNext(arg) {\n    var value = arg.value, subscriber = arg.subscriber;\n    if (!subscriber.closed) {\n        subscriber.next(value);\n        subscriber.complete();\n    }\n}\nfunction dispatchError(arg) {\n    var err = arg.err, subscriber = arg.subscriber;\n    if (!subscriber.closed) {\n        subscriber.error(err);\n    }\n}\n//# sourceMappingURL=PromiseObservable.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/observable/PromiseObservable.js\n ** module id = 74\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/observable/PromiseObservable.js?");

/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar root_1 = __webpack_require__(6);\nvar Observable_1 = __webpack_require__(5);\nvar iterator_1 = __webpack_require__(57);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar IteratorObservable = (function (_super) {\n    __extends(IteratorObservable, _super);\n    function IteratorObservable(iterator, scheduler) {\n        _super.call(this);\n        this.scheduler = scheduler;\n        if (iterator == null) {\n            throw new Error('iterator cannot be null.');\n        }\n        this.iterator = getIterator(iterator);\n    }\n    IteratorObservable.create = function (iterator, scheduler) {\n        return new IteratorObservable(iterator, scheduler);\n    };\n    IteratorObservable.dispatch = function (state) {\n        var index = state.index, hasError = state.hasError, iterator = state.iterator, subscriber = state.subscriber;\n        if (hasError) {\n            subscriber.error(state.error);\n            return;\n        }\n        var result = iterator.next();\n        if (result.done) {\n            subscriber.complete();\n            return;\n        }\n        subscriber.next(result.value);\n        state.index = index + 1;\n        if (subscriber.closed) {\n            return;\n        }\n        this.schedule(state);\n    };\n    IteratorObservable.prototype._subscribe = function (subscriber) {\n        var index = 0;\n        var _a = this, iterator = _a.iterator, scheduler = _a.scheduler;\n        if (scheduler) {\n            return scheduler.schedule(IteratorObservable.dispatch, 0, {\n                index: index, iterator: iterator, subscriber: subscriber\n            });\n        }\n        else {\n            do {\n                var result = iterator.next();\n                if (result.done) {\n                    subscriber.complete();\n                    break;\n                }\n                else {\n                    subscriber.next(result.value);\n                }\n                if (subscriber.closed) {\n                    break;\n                }\n            } while (true);\n        }\n    };\n    return IteratorObservable;\n}(Observable_1.Observable));\nexports.IteratorObservable = IteratorObservable;\nvar StringIterator = (function () {\n    function StringIterator(str, idx, len) {\n        if (idx === void 0) { idx = 0; }\n        if (len === void 0) { len = str.length; }\n        this.str = str;\n        this.idx = idx;\n        this.len = len;\n    }\n    StringIterator.prototype[iterator_1.$$iterator] = function () { return (this); };\n    StringIterator.prototype.next = function () {\n        return this.idx < this.len ? {\n            done: false,\n            value: this.str.charAt(this.idx++)\n        } : {\n            done: true,\n            value: undefined\n        };\n    };\n    return StringIterator;\n}());\nvar ArrayIterator = (function () {\n    function ArrayIterator(arr, idx, len) {\n        if (idx === void 0) { idx = 0; }\n        if (len === void 0) { len = toLength(arr); }\n        this.arr = arr;\n        this.idx = idx;\n        this.len = len;\n    }\n    ArrayIterator.prototype[iterator_1.$$iterator] = function () { return this; };\n    ArrayIterator.prototype.next = function () {\n        return this.idx < this.len ? {\n            done: false,\n            value: this.arr[this.idx++]\n        } : {\n            done: true,\n            value: undefined\n        };\n    };\n    return ArrayIterator;\n}());\nfunction getIterator(obj) {\n    var i = obj[iterator_1.$$iterator];\n    if (!i && typeof obj === 'string') {\n        return new StringIterator(obj);\n    }\n    if (!i && obj.length !== undefined) {\n        return new ArrayIterator(obj);\n    }\n    if (!i) {\n        throw new TypeError('object is not iterable');\n    }\n    return obj[iterator_1.$$iterator]();\n}\nvar maxSafeInteger = Math.pow(2, 53) - 1;\nfunction toLength(o) {\n    var len = +o.length;\n    if (isNaN(len)) {\n        return 0;\n    }\n    if (len === 0 || !numberIsFinite(len)) {\n        return len;\n    }\n    len = sign(len) * Math.floor(Math.abs(len));\n    if (len <= 0) {\n        return 0;\n    }\n    if (len > maxSafeInteger) {\n        return maxSafeInteger;\n    }\n    return len;\n}\nfunction numberIsFinite(value) {\n    return typeof value === 'number' && root_1.root.isFinite(value);\n}\nfunction sign(value) {\n    var valueAsNumber = +value;\n    if (valueAsNumber === 0) {\n        return valueAsNumber;\n    }\n    if (isNaN(valueAsNumber)) {\n        return valueAsNumber;\n    }\n    return valueAsNumber < 0 ? -1 : 1;\n}\n//# sourceMappingURL=IteratorObservable.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/observable/IteratorObservable.js\n ** module id = 75\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/observable/IteratorObservable.js?");

/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = __webpack_require__(5);\nvar ScalarObservable_1 = __webpack_require__(51);\nvar EmptyObservable_1 = __webpack_require__(52);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar ArrayLikeObservable = (function (_super) {\n    __extends(ArrayLikeObservable, _super);\n    function ArrayLikeObservable(arrayLike, scheduler) {\n        _super.call(this);\n        this.arrayLike = arrayLike;\n        this.scheduler = scheduler;\n        if (!scheduler && arrayLike.length === 1) {\n            this._isScalar = true;\n            this.value = arrayLike[0];\n        }\n    }\n    ArrayLikeObservable.create = function (arrayLike, scheduler) {\n        var length = arrayLike.length;\n        if (length === 0) {\n            return new EmptyObservable_1.EmptyObservable();\n        }\n        else if (length === 1) {\n            return new ScalarObservable_1.ScalarObservable(arrayLike[0], scheduler);\n        }\n        else {\n            return new ArrayLikeObservable(arrayLike, scheduler);\n        }\n    };\n    ArrayLikeObservable.dispatch = function (state) {\n        var arrayLike = state.arrayLike, index = state.index, length = state.length, subscriber = state.subscriber;\n        if (subscriber.closed) {\n            return;\n        }\n        if (index >= length) {\n            subscriber.complete();\n            return;\n        }\n        subscriber.next(arrayLike[index]);\n        state.index = index + 1;\n        this.schedule(state);\n    };\n    ArrayLikeObservable.prototype._subscribe = function (subscriber) {\n        var index = 0;\n        var _a = this, arrayLike = _a.arrayLike, scheduler = _a.scheduler;\n        var length = arrayLike.length;\n        if (scheduler) {\n            return scheduler.schedule(ArrayLikeObservable.dispatch, 0, {\n                arrayLike: arrayLike, index: index, length: length, subscriber: subscriber\n            });\n        }\n        else {\n            for (var i = 0; i < length && !subscriber.closed; i++) {\n                subscriber.next(arrayLike[i]);\n            }\n            subscriber.complete();\n        }\n    };\n    return ArrayLikeObservable;\n}(Observable_1.Observable));\nexports.ArrayLikeObservable = ArrayLikeObservable;\n//# sourceMappingURL=ArrayLikeObservable.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/observable/ArrayLikeObservable.js\n ** module id = 76\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/observable/ArrayLikeObservable.js?");

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(8);\nvar Notification_1 = __webpack_require__(78);\n/**\n * @see {@link Notification}\n *\n * @param scheduler\n * @param delay\n * @return {Observable<R>|WebSocketSubject<T>|Observable<T>}\n * @method observeOn\n * @owner Observable\n */\nfunction observeOn(scheduler, delay) {\n    if (delay === void 0) { delay = 0; }\n    return this.lift(new ObserveOnOperator(scheduler, delay));\n}\nexports.observeOn = observeOn;\nvar ObserveOnOperator = (function () {\n    function ObserveOnOperator(scheduler, delay) {\n        if (delay === void 0) { delay = 0; }\n        this.scheduler = scheduler;\n        this.delay = delay;\n    }\n    ObserveOnOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));\n    };\n    return ObserveOnOperator;\n}());\nexports.ObserveOnOperator = ObserveOnOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar ObserveOnSubscriber = (function (_super) {\n    __extends(ObserveOnSubscriber, _super);\n    function ObserveOnSubscriber(destination, scheduler, delay) {\n        if (delay === void 0) { delay = 0; }\n        _super.call(this, destination);\n        this.scheduler = scheduler;\n        this.delay = delay;\n    }\n    ObserveOnSubscriber.dispatch = function (arg) {\n        var notification = arg.notification, destination = arg.destination;\n        notification.observe(destination);\n    };\n    ObserveOnSubscriber.prototype.scheduleMessage = function (notification) {\n        this.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));\n    };\n    ObserveOnSubscriber.prototype._next = function (value) {\n        this.scheduleMessage(Notification_1.Notification.createNext(value));\n    };\n    ObserveOnSubscriber.prototype._error = function (err) {\n        this.scheduleMessage(Notification_1.Notification.createError(err));\n    };\n    ObserveOnSubscriber.prototype._complete = function () {\n        this.scheduleMessage(Notification_1.Notification.createComplete());\n    };\n    return ObserveOnSubscriber;\n}(Subscriber_1.Subscriber));\nexports.ObserveOnSubscriber = ObserveOnSubscriber;\nvar ObserveOnMessage = (function () {\n    function ObserveOnMessage(notification, destination) {\n        this.notification = notification;\n        this.destination = destination;\n    }\n    return ObserveOnMessage;\n}());\nexports.ObserveOnMessage = ObserveOnMessage;\n//# sourceMappingURL=observeOn.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/observeOn.js\n ** module id = 77\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/observeOn.js?");

/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\n/**\n * Represents a push-based event or value that an {@link Observable} can emit.\n * This class is particularly useful for operators that manage notifications,\n * like {@link materialize}, {@link dematerialize}, {@link observeOn}, and\n * others. Besides wrapping the actual delivered value, it also annotates it\n * with metadata of, for instance, what type of push message it is (`next`,\n * `error`, or `complete`).\n *\n * @see {@link materialize}\n * @see {@link dematerialize}\n * @see {@link observeOn}\n *\n * @class Notification<T>\n */\nvar Notification = (function () {\n    function Notification(kind, value, exception) {\n        this.kind = kind;\n        this.value = value;\n        this.exception = exception;\n        this.hasValue = kind === 'N';\n    }\n    /**\n     * Delivers to the given `observer` the value wrapped by this Notification.\n     * @param {Observer} observer\n     * @return\n     */\n    Notification.prototype.observe = function (observer) {\n        switch (this.kind) {\n            case 'N':\n                return observer.next && observer.next(this.value);\n            case 'E':\n                return observer.error && observer.error(this.exception);\n            case 'C':\n                return observer.complete && observer.complete();\n        }\n    };\n    /**\n     * Given some {@link Observer} callbacks, deliver the value represented by the\n     * current Notification to the correctly corresponding callback.\n     * @param {function(value: T): void} next An Observer `next` callback.\n     * @param {function(err: any): void} [error] An Observer `error` callback.\n     * @param {function(): void} [complete] An Observer `complete` callback.\n     * @return {any}\n     */\n    Notification.prototype.do = function (next, error, complete) {\n        var kind = this.kind;\n        switch (kind) {\n            case 'N':\n                return next && next(this.value);\n            case 'E':\n                return error && error(this.exception);\n            case 'C':\n                return complete && complete();\n        }\n    };\n    /**\n     * Takes an Observer or its individual callback functions, and calls `observe`\n     * or `do` methods accordingly.\n     * @param {Observer|function(value: T): void} nextOrObserver An Observer or\n     * the `next` callback.\n     * @param {function(err: any): void} [error] An Observer `error` callback.\n     * @param {function(): void} [complete] An Observer `complete` callback.\n     * @return {any}\n     */\n    Notification.prototype.accept = function (nextOrObserver, error, complete) {\n        if (nextOrObserver && typeof nextOrObserver.next === 'function') {\n            return this.observe(nextOrObserver);\n        }\n        else {\n            return this.do(nextOrObserver, error, complete);\n        }\n    };\n    /**\n     * Returns a simple Observable that just delivers the notification represented\n     * by this Notification instance.\n     * @return {any}\n     */\n    Notification.prototype.toObservable = function () {\n        var kind = this.kind;\n        switch (kind) {\n            case 'N':\n                return Observable_1.Observable.of(this.value);\n            case 'E':\n                return Observable_1.Observable.throw(this.exception);\n            case 'C':\n                return Observable_1.Observable.empty();\n        }\n        throw new Error('unexpected notification kind value');\n    };\n    /**\n     * A shortcut to create a Notification instance of the type `next` from a\n     * given value.\n     * @param {T} value The `next` value.\n     * @return {Notification<T>} The \"next\" Notification representing the\n     * argument.\n     */\n    Notification.createNext = function (value) {\n        if (typeof value !== 'undefined') {\n            return new Notification('N', value);\n        }\n        return this.undefinedValueNotification;\n    };\n    /**\n     * A shortcut to create a Notification instance of the type `error` from a\n     * given error.\n     * @param {any} [err] The `error` exception.\n     * @return {Notification<T>} The \"error\" Notification representing the\n     * argument.\n     */\n    Notification.createError = function (err) {\n        return new Notification('E', undefined, err);\n    };\n    /**\n     * A shortcut to create a Notification instance of the type `complete`.\n     * @return {Notification<any>} The valueless \"complete\" Notification.\n     */\n    Notification.createComplete = function () {\n        return this.completeNotification;\n    };\n    Notification.completeNotification = new Notification('C');\n    Notification.undefinedValueNotification = new Notification('N', undefined);\n    return Notification;\n}());\nexports.Notification = Notification;\n//# sourceMappingURL=Notification.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/Notification.js\n ** module id = 78\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/Notification.js?");

/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar fromEvent_1 = __webpack_require__(80);\nObservable_1.Observable.fromEvent = fromEvent_1.fromEvent;\n//# sourceMappingURL=fromEvent.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/observable/fromEvent.js\n ** module id = 79\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/observable/fromEvent.js?");

/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar FromEventObservable_1 = __webpack_require__(81);\nexports.fromEvent = FromEventObservable_1.FromEventObservable.create;\n//# sourceMappingURL=fromEvent.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/observable/fromEvent.js\n ** module id = 80\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/observable/fromEvent.js?");

/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = __webpack_require__(5);\nvar tryCatch_1 = __webpack_require__(13);\nvar isFunction_1 = __webpack_require__(9);\nvar errorObject_1 = __webpack_require__(14);\nvar Subscription_1 = __webpack_require__(10);\nfunction isNodeStyleEventEmmitter(sourceObj) {\n    return !!sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';\n}\nfunction isJQueryStyleEventEmitter(sourceObj) {\n    return !!sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';\n}\nfunction isNodeList(sourceObj) {\n    return !!sourceObj && sourceObj.toString() === '[object NodeList]';\n}\nfunction isHTMLCollection(sourceObj) {\n    return !!sourceObj && sourceObj.toString() === '[object HTMLCollection]';\n}\nfunction isEventTarget(sourceObj) {\n    return !!sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';\n}\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar FromEventObservable = (function (_super) {\n    __extends(FromEventObservable, _super);\n    function FromEventObservable(sourceObj, eventName, selector, options) {\n        _super.call(this);\n        this.sourceObj = sourceObj;\n        this.eventName = eventName;\n        this.selector = selector;\n        this.options = options;\n    }\n    /* tslint:enable:max-line-length */\n    /**\n     * Creates an Observable that emits events of a specific type coming from the\n     * given event target.\n     *\n     * <span class=\"informal\">Creates an Observable from DOM events, or Node\n     * EventEmitter events or others.</span>\n     *\n     * <img src=\"./img/fromEvent.png\" width=\"100%\">\n     *\n     * Creates an Observable by attaching an event listener to an \"event target\",\n     * which may be an object with `addEventListener` and `removeEventListener`,\n     * a Node.js EventEmitter, a jQuery style EventEmitter, a NodeList from the\n     * DOM, or an HTMLCollection from the DOM. The event handler is attached when\n     * the output Observable is subscribed, and removed when the Subscription is\n     * unsubscribed.\n     *\n     * @example <caption>Emits clicks happening on the DOM document</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * clicks.subscribe(x => console.log(x));\n     *\n     * @see {@link from}\n     * @see {@link fromEventPattern}\n     *\n     * @param {EventTargetLike} target The DOMElement, event target, Node.js\n     * EventEmitter, NodeList or HTMLCollection to attach the event handler to.\n     * @param {string} eventName The event name of interest, being emitted by the\n     * `target`.\n     * @parm {EventListenerOptions} [options] Options to pass through to addEventListener\n     * @param {SelectorMethodSignature<T>} [selector] An optional function to\n     * post-process results. It takes the arguments from the event handler and\n     * should return a single value.\n     * @return {Observable<T>}\n     * @static true\n     * @name fromEvent\n     * @owner Observable\n     */\n    FromEventObservable.create = function (target, eventName, options, selector) {\n        if (isFunction_1.isFunction(options)) {\n            selector = options;\n            options = undefined;\n        }\n        return new FromEventObservable(target, eventName, selector, options);\n    };\n    FromEventObservable.setupSubscription = function (sourceObj, eventName, handler, subscriber, options) {\n        var unsubscribe;\n        if (isNodeList(sourceObj) || isHTMLCollection(sourceObj)) {\n            for (var i = 0, len = sourceObj.length; i < len; i++) {\n                FromEventObservable.setupSubscription(sourceObj[i], eventName, handler, subscriber, options);\n            }\n        }\n        else if (isEventTarget(sourceObj)) {\n            var source_1 = sourceObj;\n            sourceObj.addEventListener(eventName, handler, options);\n            unsubscribe = function () { return source_1.removeEventListener(eventName, handler); };\n        }\n        else if (isJQueryStyleEventEmitter(sourceObj)) {\n            var source_2 = sourceObj;\n            sourceObj.on(eventName, handler);\n            unsubscribe = function () { return source_2.off(eventName, handler); };\n        }\n        else if (isNodeStyleEventEmmitter(sourceObj)) {\n            var source_3 = sourceObj;\n            sourceObj.addListener(eventName, handler);\n            unsubscribe = function () { return source_3.removeListener(eventName, handler); };\n        }\n        subscriber.add(new Subscription_1.Subscription(unsubscribe));\n    };\n    FromEventObservable.prototype._subscribe = function (subscriber) {\n        var sourceObj = this.sourceObj;\n        var eventName = this.eventName;\n        var options = this.options;\n        var selector = this.selector;\n        var handler = selector ? function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i - 0] = arguments[_i];\n            }\n            var result = tryCatch_1.tryCatch(selector).apply(void 0, args);\n            if (result === errorObject_1.errorObject) {\n                subscriber.error(errorObject_1.errorObject.e);\n            }\n            else {\n                subscriber.next(result);\n            }\n        } : function (e) { return subscriber.next(e); };\n        FromEventObservable.setupSubscription(sourceObj, eventName, handler, subscriber, options);\n    };\n    return FromEventObservable;\n}(Observable_1.Observable));\nexports.FromEventObservable = FromEventObservable;\n//# sourceMappingURL=FromEventObservable.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/observable/FromEventObservable.js\n ** module id = 81\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/observable/FromEventObservable.js?");

/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar fromEventPattern_1 = __webpack_require__(83);\nObservable_1.Observable.fromEventPattern = fromEventPattern_1.fromEventPattern;\n//# sourceMappingURL=fromEventPattern.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/observable/fromEventPattern.js\n ** module id = 82\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/observable/fromEventPattern.js?");

/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar FromEventPatternObservable_1 = __webpack_require__(84);\nexports.fromEventPattern = FromEventPatternObservable_1.FromEventPatternObservable.create;\n//# sourceMappingURL=fromEventPattern.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/observable/fromEventPattern.js\n ** module id = 83\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/observable/fromEventPattern.js?");

/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = __webpack_require__(5);\nvar Subscription_1 = __webpack_require__(10);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar FromEventPatternObservable = (function (_super) {\n    __extends(FromEventPatternObservable, _super);\n    function FromEventPatternObservable(addHandler, removeHandler, selector) {\n        _super.call(this);\n        this.addHandler = addHandler;\n        this.removeHandler = removeHandler;\n        this.selector = selector;\n    }\n    /**\n     * Creates an Observable from an API based on addHandler/removeHandler\n     * functions.\n     *\n     * <span class=\"informal\">Converts any addHandler/removeHandler API to an\n     * Observable.</span>\n     *\n     * <img src=\"./img/fromEventPattern.png\" width=\"100%\">\n     *\n     * Creates an Observable by using the `addHandler` and `removeHandler`\n     * functions to add and remove the handlers, with an optional selector\n     * function to project the event arguments to a result. The `addHandler` is\n     * called when the output Observable is subscribed, and `removeHandler` is\n     * called when the Subscription is unsubscribed.\n     *\n     * @example <caption>Emits clicks happening on the DOM document</caption>\n     * function addClickHandler(handler) {\n     *   document.addEventListener('click', handler);\n     * }\n     *\n     * function removeClickHandler(handler) {\n     *   document.removeEventListener('click', handler);\n     * }\n     *\n     * var clicks = Rx.Observable.fromEventPattern(\n     *   addClickHandler,\n     *   removeClickHandler\n     * );\n     * clicks.subscribe(x => console.log(x));\n     *\n     * @see {@link from}\n     * @see {@link fromEvent}\n     *\n     * @param {function(handler: Function): any} addHandler A function that takes\n     * a `handler` function as argument and attaches it somehow to the actual\n     * source of events.\n     * @param {function(handler: Function): void} removeHandler A function that\n     * takes a `handler` function as argument and removes it in case it was\n     * previously attached using `addHandler`.\n     * @param {function(...args: any): T} [selector] An optional function to\n     * post-process results. It takes the arguments from the event handler and\n     * should return a single value.\n     * @return {Observable<T>}\n     * @static true\n     * @name fromEventPattern\n     * @owner Observable\n     */\n    FromEventPatternObservable.create = function (addHandler, removeHandler, selector) {\n        return new FromEventPatternObservable(addHandler, removeHandler, selector);\n    };\n    FromEventPatternObservable.prototype._subscribe = function (subscriber) {\n        var _this = this;\n        var removeHandler = this.removeHandler;\n        var handler = !!this.selector ? function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i - 0] = arguments[_i];\n            }\n            _this._callSelector(subscriber, args);\n        } : function (e) { subscriber.next(e); };\n        this._callAddHandler(handler, subscriber);\n        subscriber.add(new Subscription_1.Subscription(function () {\n            //TODO: determine whether or not to forward to error handler\n            removeHandler(handler);\n        }));\n    };\n    FromEventPatternObservable.prototype._callSelector = function (subscriber, args) {\n        try {\n            var result = this.selector.apply(this, args);\n            subscriber.next(result);\n        }\n        catch (e) {\n            subscriber.error(e);\n        }\n    };\n    FromEventPatternObservable.prototype._callAddHandler = function (handler, errorSubscriber) {\n        try {\n            this.addHandler(handler);\n        }\n        catch (e) {\n            errorSubscriber.error(e);\n        }\n    };\n    return FromEventPatternObservable;\n}(Observable_1.Observable));\nexports.FromEventPatternObservable = FromEventPatternObservable;\n//# sourceMappingURL=FromEventPatternObservable.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/observable/FromEventPatternObservable.js\n ** module id = 84\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/observable/FromEventPatternObservable.js?");

/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar fromPromise_1 = __webpack_require__(86);\nObservable_1.Observable.fromPromise = fromPromise_1.fromPromise;\n//# sourceMappingURL=fromPromise.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/observable/fromPromise.js\n ** module id = 85\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/observable/fromPromise.js?");

/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar PromiseObservable_1 = __webpack_require__(74);\nexports.fromPromise = PromiseObservable_1.PromiseObservable.create;\n//# sourceMappingURL=fromPromise.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/observable/fromPromise.js\n ** module id = 86\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/observable/fromPromise.js?");

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar GenerateObservable_1 = __webpack_require__(88);\nObservable_1.Observable.generate = GenerateObservable_1.GenerateObservable.create;\n//# sourceMappingURL=generate.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/observable/generate.js\n ** module id = 87\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/observable/generate.js?");

/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = __webpack_require__(5);\nvar isScheduler_1 = __webpack_require__(49);\nvar selfSelector = function (value) { return value; };\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar GenerateObservable = (function (_super) {\n    __extends(GenerateObservable, _super);\n    function GenerateObservable(initialState, condition, iterate, resultSelector, scheduler) {\n        _super.call(this);\n        this.initialState = initialState;\n        this.condition = condition;\n        this.iterate = iterate;\n        this.resultSelector = resultSelector;\n        this.scheduler = scheduler;\n    }\n    GenerateObservable.create = function (initialStateOrOptions, condition, iterate, resultSelectorOrObservable, scheduler) {\n        if (arguments.length == 1) {\n            return new GenerateObservable(initialStateOrOptions.initialState, initialStateOrOptions.condition, initialStateOrOptions.iterate, initialStateOrOptions.resultSelector || selfSelector, initialStateOrOptions.scheduler);\n        }\n        if (resultSelectorOrObservable === undefined || isScheduler_1.isScheduler(resultSelectorOrObservable)) {\n            return new GenerateObservable(initialStateOrOptions, condition, iterate, selfSelector, resultSelectorOrObservable);\n        }\n        return new GenerateObservable(initialStateOrOptions, condition, iterate, resultSelectorOrObservable, scheduler);\n    };\n    GenerateObservable.prototype._subscribe = function (subscriber) {\n        var state = this.initialState;\n        if (this.scheduler) {\n            return this.scheduler.schedule(GenerateObservable.dispatch, 0, {\n                subscriber: subscriber,\n                iterate: this.iterate,\n                condition: this.condition,\n                resultSelector: this.resultSelector,\n                state: state });\n        }\n        var _a = this, condition = _a.condition, resultSelector = _a.resultSelector, iterate = _a.iterate;\n        do {\n            if (condition) {\n                var conditionResult = void 0;\n                try {\n                    conditionResult = condition(state);\n                }\n                catch (err) {\n                    subscriber.error(err);\n                    return;\n                }\n                if (!conditionResult) {\n                    subscriber.complete();\n                    break;\n                }\n            }\n            var value = void 0;\n            try {\n                value = resultSelector(state);\n            }\n            catch (err) {\n                subscriber.error(err);\n                return;\n            }\n            subscriber.next(value);\n            if (subscriber.closed) {\n                break;\n            }\n            try {\n                state = iterate(state);\n            }\n            catch (err) {\n                subscriber.error(err);\n                return;\n            }\n        } while (true);\n    };\n    GenerateObservable.dispatch = function (state) {\n        var subscriber = state.subscriber, condition = state.condition;\n        if (subscriber.closed) {\n            return;\n        }\n        if (state.needIterate) {\n            try {\n                state.state = state.iterate(state.state);\n            }\n            catch (err) {\n                subscriber.error(err);\n                return;\n            }\n        }\n        else {\n            state.needIterate = true;\n        }\n        if (condition) {\n            var conditionResult = void 0;\n            try {\n                conditionResult = condition(state.state);\n            }\n            catch (err) {\n                subscriber.error(err);\n                return;\n            }\n            if (!conditionResult) {\n                subscriber.complete();\n                return;\n            }\n            if (subscriber.closed) {\n                return;\n            }\n        }\n        var value;\n        try {\n            value = state.resultSelector(state.state);\n        }\n        catch (err) {\n            subscriber.error(err);\n            return;\n        }\n        if (subscriber.closed) {\n            return;\n        }\n        subscriber.next(value);\n        if (subscriber.closed) {\n            return;\n        }\n        return this.schedule(state);\n    };\n    return GenerateObservable;\n}(Observable_1.Observable));\nexports.GenerateObservable = GenerateObservable;\n//# sourceMappingURL=GenerateObservable.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/observable/GenerateObservable.js\n ** module id = 88\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/observable/GenerateObservable.js?");

/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar if_1 = __webpack_require__(90);\nObservable_1.Observable.if = if_1._if;\n//# sourceMappingURL=if.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/observable/if.js\n ** module id = 89\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/observable/if.js?");

/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar IfObservable_1 = __webpack_require__(91);\nexports._if = IfObservable_1.IfObservable.create;\n//# sourceMappingURL=if.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/observable/if.js\n ** module id = 90\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/observable/if.js?");

/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = __webpack_require__(5);\nvar subscribeToResult_1 = __webpack_require__(55);\nvar OuterSubscriber_1 = __webpack_require__(54);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar IfObservable = (function (_super) {\n    __extends(IfObservable, _super);\n    function IfObservable(condition, thenSource, elseSource) {\n        _super.call(this);\n        this.condition = condition;\n        this.thenSource = thenSource;\n        this.elseSource = elseSource;\n    }\n    IfObservable.create = function (condition, thenSource, elseSource) {\n        return new IfObservable(condition, thenSource, elseSource);\n    };\n    IfObservable.prototype._subscribe = function (subscriber) {\n        var _a = this, condition = _a.condition, thenSource = _a.thenSource, elseSource = _a.elseSource;\n        return new IfSubscriber(subscriber, condition, thenSource, elseSource);\n    };\n    return IfObservable;\n}(Observable_1.Observable));\nexports.IfObservable = IfObservable;\nvar IfSubscriber = (function (_super) {\n    __extends(IfSubscriber, _super);\n    function IfSubscriber(destination, condition, thenSource, elseSource) {\n        _super.call(this, destination);\n        this.condition = condition;\n        this.thenSource = thenSource;\n        this.elseSource = elseSource;\n        this.tryIf();\n    }\n    IfSubscriber.prototype.tryIf = function () {\n        var _a = this, condition = _a.condition, thenSource = _a.thenSource, elseSource = _a.elseSource;\n        var result;\n        try {\n            result = condition();\n            var source = result ? thenSource : elseSource;\n            if (source) {\n                this.add(subscribeToResult_1.subscribeToResult(this, source));\n            }\n            else {\n                this._complete();\n            }\n        }\n        catch (err) {\n            this._error(err);\n        }\n    };\n    return IfSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=IfObservable.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/observable/IfObservable.js\n ** module id = 91\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/observable/IfObservable.js?");

/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar interval_1 = __webpack_require__(93);\nObservable_1.Observable.interval = interval_1.interval;\n//# sourceMappingURL=interval.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/observable/interval.js\n ** module id = 92\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/observable/interval.js?");

/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar IntervalObservable_1 = __webpack_require__(94);\nexports.interval = IntervalObservable_1.IntervalObservable.create;\n//# sourceMappingURL=interval.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/observable/interval.js\n ** module id = 93\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/observable/interval.js?");

/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar isNumeric_1 = __webpack_require__(95);\nvar Observable_1 = __webpack_require__(5);\nvar async_1 = __webpack_require__(96);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar IntervalObservable = (function (_super) {\n    __extends(IntervalObservable, _super);\n    function IntervalObservable(period, scheduler) {\n        if (period === void 0) { period = 0; }\n        if (scheduler === void 0) { scheduler = async_1.async; }\n        _super.call(this);\n        this.period = period;\n        this.scheduler = scheduler;\n        if (!isNumeric_1.isNumeric(period) || period < 0) {\n            this.period = 0;\n        }\n        if (!scheduler || typeof scheduler.schedule !== 'function') {\n            this.scheduler = async_1.async;\n        }\n    }\n    /**\n     * Creates an Observable that emits sequential numbers every specified\n     * interval of time, on a specified Scheduler.\n     *\n     * <span class=\"informal\">Emits incremental numbers periodically in time.\n     * </span>\n     *\n     * <img src=\"./img/interval.png\" width=\"100%\">\n     *\n     * `interval` returns an Observable that emits an infinite sequence of\n     * ascending integers, with a constant interval of time of your choosing\n     * between those emissions. The first emission is not sent immediately, but\n     * only after the first period has passed. By default, this operator uses the\n     * `async` Scheduler to provide a notion of time, but you may pass any\n     * Scheduler to it.\n     *\n     * @example <caption>Emits ascending numbers, one every second (1000ms)</caption>\n     * var numbers = Rx.Observable.interval(1000);\n     * numbers.subscribe(x => console.log(x));\n     *\n     * @see {@link timer}\n     * @see {@link delay}\n     *\n     * @param {number} [period=0] The interval size in milliseconds (by default)\n     * or the time unit determined by the scheduler's clock.\n     * @param {Scheduler} [scheduler=async] The Scheduler to use for scheduling\n     * the emission of values, and providing a notion of \"time\".\n     * @return {Observable} An Observable that emits a sequential number each time\n     * interval.\n     * @static true\n     * @name interval\n     * @owner Observable\n     */\n    IntervalObservable.create = function (period, scheduler) {\n        if (period === void 0) { period = 0; }\n        if (scheduler === void 0) { scheduler = async_1.async; }\n        return new IntervalObservable(period, scheduler);\n    };\n    IntervalObservable.dispatch = function (state) {\n        var index = state.index, subscriber = state.subscriber, period = state.period;\n        subscriber.next(index);\n        if (subscriber.closed) {\n            return;\n        }\n        state.index += 1;\n        this.schedule(state, period);\n    };\n    IntervalObservable.prototype._subscribe = function (subscriber) {\n        var index = 0;\n        var period = this.period;\n        var scheduler = this.scheduler;\n        subscriber.add(scheduler.schedule(IntervalObservable.dispatch, period, {\n            index: index, subscriber: subscriber, period: period\n        }));\n    };\n    return IntervalObservable;\n}(Observable_1.Observable));\nexports.IntervalObservable = IntervalObservable;\n//# sourceMappingURL=IntervalObservable.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/observable/IntervalObservable.js\n ** module id = 94\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/observable/IntervalObservable.js?");

/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar isArray_1 = __webpack_require__(11);\nfunction isNumeric(val) {\n    // parseFloat NaNs numeric-cast false positives (null|true|false|\"\")\n    // ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n    // subtraction forces infinities to NaN\n    // adding 1 corrects loss of precision from parseFloat (#15100)\n    return !isArray_1.isArray(val) && (val - parseFloat(val) + 1) >= 0;\n}\nexports.isNumeric = isNumeric;\n;\n//# sourceMappingURL=isNumeric.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/util/isNumeric.js\n ** module id = 95\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/util/isNumeric.js?");

/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar AsyncAction_1 = __webpack_require__(97);\nvar AsyncScheduler_1 = __webpack_require__(99);\nexports.async = new AsyncScheduler_1.AsyncScheduler(AsyncAction_1.AsyncAction);\n//# sourceMappingURL=async.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/scheduler/async.js\n ** module id = 96\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/scheduler/async.js?");

/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar root_1 = __webpack_require__(6);\nvar Action_1 = __webpack_require__(98);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar AsyncAction = (function (_super) {\n    __extends(AsyncAction, _super);\n    function AsyncAction(scheduler, work) {\n        _super.call(this, scheduler, work);\n        this.scheduler = scheduler;\n        this.work = work;\n        this.pending = false;\n    }\n    AsyncAction.prototype.schedule = function (state, delay) {\n        if (delay === void 0) { delay = 0; }\n        if (this.closed) {\n            return this;\n        }\n        // Always replace the current state with the new state.\n        this.state = state;\n        // Set the pending flag indicating that this action has been scheduled, or\n        // has recursively rescheduled itself.\n        this.pending = true;\n        var id = this.id;\n        var scheduler = this.scheduler;\n        //\n        // Important implementation note:\n        //\n        // Actions only execute once by default, unless rescheduled from within the\n        // scheduled callback. This allows us to implement single and repeat\n        // actions via the same code path, without adding API surface area, as well\n        // as mimic traditional recursion but across asynchronous boundaries.\n        //\n        // However, JS runtimes and timers distinguish between intervals achieved by\n        // serial `setTimeout` calls vs. a single `setInterval` call. An interval of\n        // serial `setTimeout` calls can be individually delayed, which delays\n        // scheduling the next `setTimeout`, and so on. `setInterval` attempts to\n        // guarantee the interval callback will be invoked more precisely to the\n        // interval period, regardless of load.\n        //\n        // Therefore, we use `setInterval` to schedule single and repeat actions.\n        // If the action reschedules itself with the same delay, the interval is not\n        // canceled. If the action doesn't reschedule, or reschedules with a\n        // different delay, the interval will be canceled after scheduled callback\n        // execution.\n        //\n        if (id != null) {\n            this.id = this.recycleAsyncId(scheduler, id, delay);\n        }\n        this.delay = delay;\n        // If this action has already an async Id, don't request a new one.\n        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);\n        return this;\n    };\n    AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) { delay = 0; }\n        return root_1.root.setInterval(scheduler.flush.bind(scheduler, this), delay);\n    };\n    AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) { delay = 0; }\n        // If this action is rescheduled with the same delay time, don't clear the interval id.\n        if (delay !== null && this.delay === delay) {\n            return id;\n        }\n        // Otherwise, if the action's delay time is different from the current delay,\n        // clear the interval id\n        return root_1.root.clearInterval(id) && undefined || undefined;\n    };\n    /**\n     * Immediately executes this action and the `work` it contains.\n     * @return {any}\n     */\n    AsyncAction.prototype.execute = function (state, delay) {\n        if (this.closed) {\n            return new Error('executing a cancelled action');\n        }\n        this.pending = false;\n        var error = this._execute(state, delay);\n        if (error) {\n            return error;\n        }\n        else if (this.pending === false && this.id != null) {\n            // Dequeue if the action didn't reschedule itself. Don't call\n            // unsubscribe(), because the action could reschedule later.\n            // For example:\n            // ```\n            // scheduler.schedule(function doWork(counter) {\n            //   /* ... I'm a busy worker bee ... */\n            //   var originalAction = this;\n            //   /* wait 100ms before rescheduling the action */\n            //   setTimeout(function () {\n            //     originalAction.schedule(counter + 1);\n            //   }, 100);\n            // }, 1000);\n            // ```\n            this.id = this.recycleAsyncId(this.scheduler, this.id, null);\n        }\n    };\n    AsyncAction.prototype._execute = function (state, delay) {\n        var errored = false;\n        var errorValue = undefined;\n        try {\n            this.work(state);\n        }\n        catch (e) {\n            errored = true;\n            errorValue = !!e && e || new Error(e);\n        }\n        if (errored) {\n            this.unsubscribe();\n            return errorValue;\n        }\n    };\n    AsyncAction.prototype._unsubscribe = function () {\n        var id = this.id;\n        var scheduler = this.scheduler;\n        var actions = scheduler.actions;\n        var index = actions.indexOf(this);\n        this.work = null;\n        this.delay = null;\n        this.state = null;\n        this.pending = false;\n        this.scheduler = null;\n        if (index !== -1) {\n            actions.splice(index, 1);\n        }\n        if (id != null) {\n            this.id = this.recycleAsyncId(scheduler, id, null);\n        }\n    };\n    return AsyncAction;\n}(Action_1.Action));\nexports.AsyncAction = AsyncAction;\n//# sourceMappingURL=AsyncAction.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/scheduler/AsyncAction.js\n ** module id = 97\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/scheduler/AsyncAction.js?");

/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscription_1 = __webpack_require__(10);\n/**\n * A unit of work to be executed in a {@link Scheduler}. An action is typically\n * created from within a Scheduler and an RxJS user does not need to concern\n * themselves about creating and manipulating an Action.\n *\n * ```ts\n * class Action<T> extends Subscription {\n *   new (scheduler: Scheduler, work: (state?: T) => void);\n *   schedule(state?: T, delay: number = 0): Subscription;\n * }\n * ```\n *\n * @class Action<T>\n */\nvar Action = (function (_super) {\n    __extends(Action, _super);\n    function Action(scheduler, work) {\n        _super.call(this);\n    }\n    /**\n     * Schedules this action on its parent Scheduler for execution. May be passed\n     * some context object, `state`. May happen at some point in the future,\n     * according to the `delay` parameter, if specified.\n     * @param {T} [state] Some contextual data that the `work` function uses when\n     * called by the Scheduler.\n     * @param {number} [delay] Time to wait before executing the work, where the\n     * time unit is implicit and defined by the Scheduler.\n     * @return {void}\n     */\n    Action.prototype.schedule = function (state, delay) {\n        if (delay === void 0) { delay = 0; }\n        return this;\n    };\n    return Action;\n}(Subscription_1.Subscription));\nexports.Action = Action;\n//# sourceMappingURL=Action.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/scheduler/Action.js\n ** module id = 98\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/scheduler/Action.js?");

/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Scheduler_1 = __webpack_require__(100);\nvar AsyncScheduler = (function (_super) {\n    __extends(AsyncScheduler, _super);\n    function AsyncScheduler() {\n        _super.apply(this, arguments);\n        this.actions = [];\n        /**\n         * A flag to indicate whether the Scheduler is currently executing a batch of\n         * queued actions.\n         * @type {boolean}\n         */\n        this.active = false;\n        /**\n         * An internal ID used to track the latest asynchronous task such as those\n         * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and\n         * others.\n         * @type {any}\n         */\n        this.scheduled = undefined;\n    }\n    AsyncScheduler.prototype.flush = function (action) {\n        var actions = this.actions;\n        if (this.active) {\n            actions.push(action);\n            return;\n        }\n        var error;\n        this.active = true;\n        do {\n            if (error = action.execute(action.state, action.delay)) {\n                break;\n            }\n        } while (action = actions.shift()); // exhaust the scheduler queue\n        this.active = false;\n        if (error) {\n            while (action = actions.shift()) {\n                action.unsubscribe();\n            }\n            throw error;\n        }\n    };\n    return AsyncScheduler;\n}(Scheduler_1.Scheduler));\nexports.AsyncScheduler = AsyncScheduler;\n//# sourceMappingURL=AsyncScheduler.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/scheduler/AsyncScheduler.js\n ** module id = 99\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/scheduler/AsyncScheduler.js?");

/***/ },
/* 100 */
/***/ function(module, exports) {

	eval("\"use strict\";\n/**\n * An execution context and a data structure to order tasks and schedule their\n * execution. Provides a notion of (potentially virtual) time, through the\n * `now()` getter method.\n *\n * Each unit of work in a Scheduler is called an {@link Action}.\n *\n * ```ts\n * class Scheduler {\n *   now(): number;\n *   schedule(work, delay?, state?): Subscription;\n * }\n * ```\n *\n * @class Scheduler\n */\nvar Scheduler = (function () {\n    function Scheduler(SchedulerAction, now) {\n        if (now === void 0) { now = Scheduler.now; }\n        this.SchedulerAction = SchedulerAction;\n        this.now = now;\n    }\n    /**\n     * Schedules a function, `work`, for execution. May happen at some point in\n     * the future, according to the `delay` parameter, if specified. May be passed\n     * some context object, `state`, which will be passed to the `work` function.\n     *\n     * The given arguments will be processed an stored as an Action object in a\n     * queue of actions.\n     *\n     * @param {function(state: ?T): ?Subscription} work A function representing a\n     * task, or some unit of work to be executed by the Scheduler.\n     * @param {number} [delay] Time to wait before executing the work, where the\n     * time unit is implicit and defined by the Scheduler itself.\n     * @param {T} [state] Some contextual data that the `work` function uses when\n     * called by the Scheduler.\n     * @return {Subscription} A subscription in order to be able to unsubscribe\n     * the scheduled work.\n     */\n    Scheduler.prototype.schedule = function (work, delay, state) {\n        if (delay === void 0) { delay = 0; }\n        return new this.SchedulerAction(this, work).schedule(state, delay);\n    };\n    Scheduler.now = Date.now ? Date.now : function () { return +new Date(); };\n    return Scheduler;\n}());\nexports.Scheduler = Scheduler;\n//# sourceMappingURL=Scheduler.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/Scheduler.js\n ** module id = 100\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/Scheduler.js?");

/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar merge_1 = __webpack_require__(102);\nObservable_1.Observable.merge = merge_1.merge;\n//# sourceMappingURL=merge.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/observable/merge.js\n ** module id = 101\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/observable/merge.js?");

/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar merge_1 = __webpack_require__(103);\nexports.merge = merge_1.mergeStatic;\n//# sourceMappingURL=merge.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/observable/merge.js\n ** module id = 102\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/observable/merge.js?");

/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar ArrayObservable_1 = __webpack_require__(50);\nvar mergeAll_1 = __webpack_require__(62);\nvar isScheduler_1 = __webpack_require__(49);\n/**\n * Creates an output Observable which concurrently emits all values from every\n * given input Observable.\n *\n * <span class=\"informal\">Flattens multiple Observables together by blending\n * their values into one Observable.</span>\n *\n * <img src=\"./img/merge.png\" width=\"100%\">\n *\n * `merge` subscribes to each given input Observable (either the source or an\n * Observable given as argument), and simply forwards (without doing any\n * transformation) all the values from all the input Observables to the output\n * Observable. The output Observable only completes once all input Observables\n * have completed. Any error delivered by an input Observable will be immediately\n * emitted on the output Observable.\n *\n * @example <caption>Merge together two Observables: 1s interval and clicks</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var timer = Rx.Observable.interval(1000);\n * var clicksOrTimer = clicks.merge(timer);\n * clicksOrTimer.subscribe(x => console.log(x));\n *\n * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>\n * var timer1 = Rx.Observable.interval(1000).take(10);\n * var timer2 = Rx.Observable.interval(2000).take(6);\n * var timer3 = Rx.Observable.interval(500).take(10);\n * var concurrent = 2; // the argument\n * var merged = timer1.merge(timer2, timer3, concurrent);\n * merged.subscribe(x => console.log(x));\n *\n * @see {@link mergeAll}\n * @see {@link mergeMap}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n *\n * @param {Observable} other An input Observable to merge with the source\n * Observable. More than one input Observables may be given as argument.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @param {Scheduler} [scheduler=null] The Scheduler to use for managing\n * concurrency of input Observables.\n * @return {Observable} an Observable that emits items that are the result of\n * every input Observable.\n * @method merge\n * @owner Observable\n */\nfunction merge() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    observables.unshift(this);\n    return mergeStatic.apply(this, observables);\n}\nexports.merge = merge;\n/* tslint:enable:max-line-length */\n/**\n * Creates an output Observable which concurrently emits all values from every\n * given input Observable.\n *\n * <span class=\"informal\">Flattens multiple Observables together by blending\n * their values into one Observable.</span>\n *\n * <img src=\"./img/merge.png\" width=\"100%\">\n *\n * `merge` subscribes to each given input Observable (as arguments), and simply\n * forwards (without doing any transformation) all the values from all the input\n * Observables to the output Observable. The output Observable only completes\n * once all input Observables have completed. Any error delivered by an input\n * Observable will be immediately emitted on the output Observable.\n *\n * @example <caption>Merge together two Observables: 1s interval and clicks</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var timer = Rx.Observable.interval(1000);\n * var clicksOrTimer = Rx.Observable.merge(clicks, timer);\n * clicksOrTimer.subscribe(x => console.log(x));\n *\n * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>\n * var timer1 = Rx.Observable.interval(1000).take(10);\n * var timer2 = Rx.Observable.interval(2000).take(6);\n * var timer3 = Rx.Observable.interval(500).take(10);\n * var concurrent = 2; // the argument\n * var merged = Rx.Observable.merge(timer1, timer2, timer3, concurrent);\n * merged.subscribe(x => console.log(x));\n *\n * @see {@link mergeAll}\n * @see {@link mergeMap}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n *\n * @param {Observable} input1 An input Observable to merge with others.\n * @param {Observable} input2 An input Observable to merge with others.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @param {Scheduler} [scheduler=null] The Scheduler to use for managing\n * concurrency of input Observables.\n * @return {Observable} an Observable that emits items that are the result of\n * every input Observable.\n * @static true\n * @name merge\n * @owner Observable\n */\nfunction mergeStatic() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    var concurrent = Number.POSITIVE_INFINITY;\n    var scheduler = null;\n    var last = observables[observables.length - 1];\n    if (isScheduler_1.isScheduler(last)) {\n        scheduler = observables.pop();\n        if (observables.length > 1 && typeof observables[observables.length - 1] === 'number') {\n            concurrent = observables.pop();\n        }\n    }\n    else if (typeof last === 'number') {\n        concurrent = observables.pop();\n    }\n    if (observables.length === 1) {\n        return observables[0];\n    }\n    return new ArrayObservable_1.ArrayObservable(observables, scheduler).lift(new mergeAll_1.MergeAllOperator(concurrent));\n}\nexports.mergeStatic = mergeStatic;\n//# sourceMappingURL=merge.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/merge.js\n ** module id = 103\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/merge.js?");

/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar race_1 = __webpack_require__(105);\nObservable_1.Observable.race = race_1.raceStatic;\n//# sourceMappingURL=race.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/observable/race.js\n ** module id = 104\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/observable/race.js?");

/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar isArray_1 = __webpack_require__(11);\nvar ArrayObservable_1 = __webpack_require__(50);\nvar OuterSubscriber_1 = __webpack_require__(54);\nvar subscribeToResult_1 = __webpack_require__(55);\n/**\n * Returns an Observable that mirrors the first source Observable to emit an item\n * from the combination of this Observable and supplied Observables\n * @param {...Observables} ...observables sources used to race for which Observable emits first.\n * @return {Observable} an Observable that mirrors the output of the first Observable to emit an item.\n * @method race\n * @owner Observable\n */\nfunction race() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    // if the only argument is an array, it was most likely called with\n    // `pair([obs1, obs2, ...])`\n    if (observables.length === 1 && isArray_1.isArray(observables[0])) {\n        observables = observables[0];\n    }\n    observables.unshift(this);\n    return raceStatic.apply(this, observables);\n}\nexports.race = race;\nfunction raceStatic() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    // if the only argument is an array, it was most likely called with\n    // `pair([obs1, obs2, ...])`\n    if (observables.length === 1) {\n        if (isArray_1.isArray(observables[0])) {\n            observables = observables[0];\n        }\n        else {\n            return observables[0];\n        }\n    }\n    return new ArrayObservable_1.ArrayObservable(observables).lift(new RaceOperator());\n}\nexports.raceStatic = raceStatic;\nvar RaceOperator = (function () {\n    function RaceOperator() {\n    }\n    RaceOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new RaceSubscriber(subscriber));\n    };\n    return RaceOperator;\n}());\nexports.RaceOperator = RaceOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar RaceSubscriber = (function (_super) {\n    __extends(RaceSubscriber, _super);\n    function RaceSubscriber(destination) {\n        _super.call(this, destination);\n        this.hasFirst = false;\n        this.observables = [];\n        this.subscriptions = [];\n    }\n    RaceSubscriber.prototype._next = function (observable) {\n        this.observables.push(observable);\n    };\n    RaceSubscriber.prototype._complete = function () {\n        var observables = this.observables;\n        var len = observables.length;\n        if (len === 0) {\n            this.destination.complete();\n        }\n        else {\n            for (var i = 0; i < len; i++) {\n                var observable = observables[i];\n                var subscription = subscribeToResult_1.subscribeToResult(this, observable, observable, i);\n                if (this.subscriptions) {\n                    this.subscriptions.push(subscription);\n                    this.add(subscription);\n                }\n            }\n            this.observables = null;\n        }\n    };\n    RaceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        if (!this.hasFirst) {\n            this.hasFirst = true;\n            for (var i = 0; i < this.subscriptions.length; i++) {\n                if (i !== outerIndex) {\n                    var subscription = this.subscriptions[i];\n                    subscription.unsubscribe();\n                    this.remove(subscription);\n                }\n            }\n            this.subscriptions = null;\n        }\n        this.destination.next(innerValue);\n    };\n    return RaceSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\nexports.RaceSubscriber = RaceSubscriber;\n//# sourceMappingURL=race.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/race.js\n ** module id = 105\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/race.js?");

/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar never_1 = __webpack_require__(107);\nObservable_1.Observable.never = never_1.never;\n//# sourceMappingURL=never.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/observable/never.js\n ** module id = 106\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/observable/never.js?");

/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar NeverObservable_1 = __webpack_require__(108);\nexports.never = NeverObservable_1.NeverObservable.create;\n//# sourceMappingURL=never.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/observable/never.js\n ** module id = 107\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/observable/never.js?");

/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = __webpack_require__(5);\nvar noop_1 = __webpack_require__(109);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar NeverObservable = (function (_super) {\n    __extends(NeverObservable, _super);\n    function NeverObservable() {\n        _super.call(this);\n    }\n    /**\n     * Creates an Observable that emits no items to the Observer.\n     *\n     * <span class=\"informal\">An Observable that never emits anything.</span>\n     *\n     * <img src=\"./img/never.png\" width=\"100%\">\n     *\n     * This static operator is useful for creating a simple Observable that emits\n     * neither values nor errors nor the completion notification. It can be used\n     * for testing purposes or for composing with other Observables. Please not\n     * that by never emitting a complete notification, this Observable keeps the\n     * subscription from being disposed automatically. Subscriptions need to be\n     * manually disposed.\n     *\n     * @example <caption>Emit the number 7, then never emit anything else (not even complete).</caption>\n     * function info() {\n     *   console.log('Will not be called');\n     * }\n     * var result = Rx.Observable.never().startWith(7);\n     * result.subscribe(x => console.log(x), info, info);\n     *\n     * @see {@link create}\n     * @see {@link empty}\n     * @see {@link of}\n     * @see {@link throw}\n     *\n     * @return {Observable} A \"never\" Observable: never emits anything.\n     * @static true\n     * @name never\n     * @owner Observable\n     */\n    NeverObservable.create = function () {\n        return new NeverObservable();\n    };\n    NeverObservable.prototype._subscribe = function (subscriber) {\n        noop_1.noop();\n    };\n    return NeverObservable;\n}(Observable_1.Observable));\nexports.NeverObservable = NeverObservable;\n//# sourceMappingURL=NeverObservable.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/observable/NeverObservable.js\n ** module id = 108\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/observable/NeverObservable.js?");

/***/ },
/* 109 */
/***/ function(module, exports) {

	eval("\"use strict\";\n/* tslint:disable:no-empty */\nfunction noop() { }\nexports.noop = noop;\n//# sourceMappingURL=noop.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/util/noop.js\n ** module id = 109\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/util/noop.js?");

/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar of_1 = __webpack_require__(111);\nObservable_1.Observable.of = of_1.of;\n//# sourceMappingURL=of.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/observable/of.js\n ** module id = 110\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/observable/of.js?");

/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar ArrayObservable_1 = __webpack_require__(50);\nexports.of = ArrayObservable_1.ArrayObservable.of;\n//# sourceMappingURL=of.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/observable/of.js\n ** module id = 111\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/observable/of.js?");

/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar onErrorResumeNext_1 = __webpack_require__(113);\nObservable_1.Observable.onErrorResumeNext = onErrorResumeNext_1.onErrorResumeNextStatic;\n//# sourceMappingURL=onErrorResumeNext.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/observable/onErrorResumeNext.js\n ** module id = 112\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/observable/onErrorResumeNext.js?");

/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar FromObservable_1 = __webpack_require__(73);\nvar isArray_1 = __webpack_require__(11);\nvar OuterSubscriber_1 = __webpack_require__(54);\nvar subscribeToResult_1 = __webpack_require__(55);\nfunction onErrorResumeNext() {\n    var nextSources = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        nextSources[_i - 0] = arguments[_i];\n    }\n    if (nextSources.length === 1 && isArray_1.isArray(nextSources[0])) {\n        nextSources = nextSources[0];\n    }\n    return this.lift(new OnErrorResumeNextOperator(nextSources));\n}\nexports.onErrorResumeNext = onErrorResumeNext;\n/* tslint:enable:max-line-length */\nfunction onErrorResumeNextStatic() {\n    var nextSources = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        nextSources[_i - 0] = arguments[_i];\n    }\n    var source = null;\n    if (nextSources.length === 1 && isArray_1.isArray(nextSources[0])) {\n        nextSources = nextSources[0];\n    }\n    source = nextSources.shift();\n    return new FromObservable_1.FromObservable(source, null).lift(new OnErrorResumeNextOperator(nextSources));\n}\nexports.onErrorResumeNextStatic = onErrorResumeNextStatic;\nvar OnErrorResumeNextOperator = (function () {\n    function OnErrorResumeNextOperator(nextSources) {\n        this.nextSources = nextSources;\n    }\n    OnErrorResumeNextOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new OnErrorResumeNextSubscriber(subscriber, this.nextSources));\n    };\n    return OnErrorResumeNextOperator;\n}());\nvar OnErrorResumeNextSubscriber = (function (_super) {\n    __extends(OnErrorResumeNextSubscriber, _super);\n    function OnErrorResumeNextSubscriber(destination, nextSources) {\n        _super.call(this, destination);\n        this.destination = destination;\n        this.nextSources = nextSources;\n    }\n    OnErrorResumeNextSubscriber.prototype.notifyError = function (error, innerSub) {\n        this.subscribeToNextSource();\n    };\n    OnErrorResumeNextSubscriber.prototype.notifyComplete = function (innerSub) {\n        this.subscribeToNextSource();\n    };\n    OnErrorResumeNextSubscriber.prototype._error = function (err) {\n        this.subscribeToNextSource();\n    };\n    OnErrorResumeNextSubscriber.prototype._complete = function () {\n        this.subscribeToNextSource();\n    };\n    OnErrorResumeNextSubscriber.prototype.subscribeToNextSource = function () {\n        var next = this.nextSources.shift();\n        if (next) {\n            this.add(subscribeToResult_1.subscribeToResult(this, next));\n        }\n        else {\n            this.destination.complete();\n        }\n    };\n    return OnErrorResumeNextSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=onErrorResumeNext.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/onErrorResumeNext.js\n ** module id = 113\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/onErrorResumeNext.js?");

/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar pairs_1 = __webpack_require__(115);\nObservable_1.Observable.pairs = pairs_1.pairs;\n//# sourceMappingURL=pairs.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/observable/pairs.js\n ** module id = 114\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/observable/pairs.js?");

/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar PairsObservable_1 = __webpack_require__(116);\nexports.pairs = PairsObservable_1.PairsObservable.create;\n//# sourceMappingURL=pairs.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/observable/pairs.js\n ** module id = 115\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/observable/pairs.js?");

/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = __webpack_require__(5);\nfunction dispatch(state) {\n    var obj = state.obj, keys = state.keys, length = state.length, index = state.index, subscriber = state.subscriber;\n    if (index === length) {\n        subscriber.complete();\n        return;\n    }\n    var key = keys[index];\n    subscriber.next([key, obj[key]]);\n    state.index = index + 1;\n    this.schedule(state);\n}\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar PairsObservable = (function (_super) {\n    __extends(PairsObservable, _super);\n    function PairsObservable(obj, scheduler) {\n        _super.call(this);\n        this.obj = obj;\n        this.scheduler = scheduler;\n        this.keys = Object.keys(obj);\n    }\n    /**\n     * Convert an object into an observable sequence of [key, value] pairs\n     * using an optional Scheduler to enumerate the object.\n     *\n     * @example <caption>Converts a javascript object to an Observable</caption>\n     * var obj = {\n     *   foo: 42,\n     *   bar: 56,\n     *   baz: 78\n     * };\n     *\n     * var source = Rx.Observable.pairs(obj);\n     *\n     * var subscription = source.subscribe(\n     *   function (x) {\n     *     console.log('Next: %s', x);\n     *   },\n     *   function (err) {\n     *     console.log('Error: %s', err);\n     *   },\n     *   function () {\n     *     console.log('Completed');\n     *   });\n     *\n     * @param {Object} obj The object to inspect and turn into an\n     * Observable sequence.\n     * @param {Scheduler} [scheduler] An optional Scheduler to run the\n     * enumeration of the input sequence on.\n     * @returns {(Observable<Array<string | T>>)} An observable sequence of\n     * [key, value] pairs from the object.\n     */\n    PairsObservable.create = function (obj, scheduler) {\n        return new PairsObservable(obj, scheduler);\n    };\n    PairsObservable.prototype._subscribe = function (subscriber) {\n        var _a = this, keys = _a.keys, scheduler = _a.scheduler;\n        var length = keys.length;\n        if (scheduler) {\n            return scheduler.schedule(dispatch, 0, {\n                obj: this.obj, keys: keys, length: length, index: 0, subscriber: subscriber\n            });\n        }\n        else {\n            for (var idx = 0; idx < length; idx++) {\n                var key = keys[idx];\n                subscriber.next([key, this.obj[key]]);\n            }\n            subscriber.complete();\n        }\n    };\n    return PairsObservable;\n}(Observable_1.Observable));\nexports.PairsObservable = PairsObservable;\n//# sourceMappingURL=PairsObservable.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/observable/PairsObservable.js\n ** module id = 116\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/observable/PairsObservable.js?");

/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar range_1 = __webpack_require__(118);\nObservable_1.Observable.range = range_1.range;\n//# sourceMappingURL=range.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/observable/range.js\n ** module id = 117\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/observable/range.js?");

/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar RangeObservable_1 = __webpack_require__(119);\nexports.range = RangeObservable_1.RangeObservable.create;\n//# sourceMappingURL=range.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/observable/range.js\n ** module id = 118\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/observable/range.js?");

/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = __webpack_require__(5);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar RangeObservable = (function (_super) {\n    __extends(RangeObservable, _super);\n    function RangeObservable(start, count, scheduler) {\n        _super.call(this);\n        this.start = start;\n        this._count = count;\n        this.scheduler = scheduler;\n    }\n    /**\n     * Creates an Observable that emits a sequence of numbers within a specified\n     * range.\n     *\n     * <span class=\"informal\">Emits a sequence of numbers in a range.</span>\n     *\n     * <img src=\"./img/range.png\" width=\"100%\">\n     *\n     * `range` operator emits a range of sequential integers, in order, where you\n     * select the `start` of the range and its `length`. By default, uses no\n     * Scheduler and just delivers the notifications synchronously, but may use\n     * an optional Scheduler to regulate those deliveries.\n     *\n     * @example <caption>Emits the numbers 1 to 10</caption>\n     * var numbers = Rx.Observable.range(1, 10);\n     * numbers.subscribe(x => console.log(x));\n     *\n     * @see {@link timer}\n     * @see {@link interval}\n     *\n     * @param {number} [start=0] The value of the first integer in the sequence.\n     * @param {number} [count=0] The number of sequential integers to generate.\n     * @param {Scheduler} [scheduler] A {@link Scheduler} to use for scheduling\n     * the emissions of the notifications.\n     * @return {Observable} An Observable of numbers that emits a finite range of\n     * sequential integers.\n     * @static true\n     * @name range\n     * @owner Observable\n     */\n    RangeObservable.create = function (start, count, scheduler) {\n        if (start === void 0) { start = 0; }\n        if (count === void 0) { count = 0; }\n        return new RangeObservable(start, count, scheduler);\n    };\n    RangeObservable.dispatch = function (state) {\n        var start = state.start, index = state.index, count = state.count, subscriber = state.subscriber;\n        if (index >= count) {\n            subscriber.complete();\n            return;\n        }\n        subscriber.next(start);\n        if (subscriber.closed) {\n            return;\n        }\n        state.index = index + 1;\n        state.start = start + 1;\n        this.schedule(state);\n    };\n    RangeObservable.prototype._subscribe = function (subscriber) {\n        var index = 0;\n        var start = this.start;\n        var count = this._count;\n        var scheduler = this.scheduler;\n        if (scheduler) {\n            return scheduler.schedule(RangeObservable.dispatch, 0, {\n                index: index, count: count, start: start, subscriber: subscriber\n            });\n        }\n        else {\n            do {\n                if (index++ >= count) {\n                    subscriber.complete();\n                    break;\n                }\n                subscriber.next(start++);\n                if (subscriber.closed) {\n                    break;\n                }\n            } while (true);\n        }\n    };\n    return RangeObservable;\n}(Observable_1.Observable));\nexports.RangeObservable = RangeObservable;\n//# sourceMappingURL=RangeObservable.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/observable/RangeObservable.js\n ** module id = 119\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/observable/RangeObservable.js?");

/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar using_1 = __webpack_require__(121);\nObservable_1.Observable.using = using_1.using;\n//# sourceMappingURL=using.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/observable/using.js\n ** module id = 120\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/observable/using.js?");

/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar UsingObservable_1 = __webpack_require__(122);\nexports.using = UsingObservable_1.UsingObservable.create;\n//# sourceMappingURL=using.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/observable/using.js\n ** module id = 121\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/observable/using.js?");

/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = __webpack_require__(5);\nvar subscribeToResult_1 = __webpack_require__(55);\nvar OuterSubscriber_1 = __webpack_require__(54);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar UsingObservable = (function (_super) {\n    __extends(UsingObservable, _super);\n    function UsingObservable(resourceFactory, observableFactory) {\n        _super.call(this);\n        this.resourceFactory = resourceFactory;\n        this.observableFactory = observableFactory;\n    }\n    UsingObservable.create = function (resourceFactory, observableFactory) {\n        return new UsingObservable(resourceFactory, observableFactory);\n    };\n    UsingObservable.prototype._subscribe = function (subscriber) {\n        var _a = this, resourceFactory = _a.resourceFactory, observableFactory = _a.observableFactory;\n        var resource;\n        try {\n            resource = resourceFactory();\n            return new UsingSubscriber(subscriber, resource, observableFactory);\n        }\n        catch (err) {\n            subscriber.error(err);\n        }\n    };\n    return UsingObservable;\n}(Observable_1.Observable));\nexports.UsingObservable = UsingObservable;\nvar UsingSubscriber = (function (_super) {\n    __extends(UsingSubscriber, _super);\n    function UsingSubscriber(destination, resource, observableFactory) {\n        _super.call(this, destination);\n        this.resource = resource;\n        this.observableFactory = observableFactory;\n        destination.add(resource);\n        this.tryUse();\n    }\n    UsingSubscriber.prototype.tryUse = function () {\n        try {\n            var source = this.observableFactory.call(this, this.resource);\n            if (source) {\n                this.add(subscribeToResult_1.subscribeToResult(this, source));\n            }\n        }\n        catch (err) {\n            this._error(err);\n        }\n    };\n    return UsingSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=UsingObservable.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/observable/UsingObservable.js\n ** module id = 122\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/observable/UsingObservable.js?");

/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar throw_1 = __webpack_require__(124);\nObservable_1.Observable.throw = throw_1._throw;\n//# sourceMappingURL=throw.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/observable/throw.js\n ** module id = 123\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/observable/throw.js?");

/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar ErrorObservable_1 = __webpack_require__(125);\nexports._throw = ErrorObservable_1.ErrorObservable.create;\n//# sourceMappingURL=throw.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/observable/throw.js\n ** module id = 124\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/observable/throw.js?");

/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = __webpack_require__(5);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar ErrorObservable = (function (_super) {\n    __extends(ErrorObservable, _super);\n    function ErrorObservable(error, scheduler) {\n        _super.call(this);\n        this.error = error;\n        this.scheduler = scheduler;\n    }\n    /**\n     * Creates an Observable that emits no items to the Observer and immediately\n     * emits an error notification.\n     *\n     * <span class=\"informal\">Just emits 'error', and nothing else.\n     * </span>\n     *\n     * <img src=\"./img/throw.png\" width=\"100%\">\n     *\n     * This static operator is useful for creating a simple Observable that only\n     * emits the error notification. It can be used for composing with other\n     * Observables, such as in a {@link mergeMap}.\n     *\n     * @example <caption>Emit the number 7, then emit an error.</caption>\n     * var result = Rx.Observable.throw(new Error('oops!')).startWith(7);\n     * result.subscribe(x => console.log(x), e => console.error(e));\n     *\n     * @example <caption>Map and flattens numbers to the sequence 'a', 'b', 'c', but throw an error for 13</caption>\n     * var interval = Rx.Observable.interval(1000);\n     * var result = interval.mergeMap(x =>\n     *   x === 13 ?\n     *     Rx.Observable.throw('Thirteens are bad') :\n     *     Rx.Observable.of('a', 'b', 'c')\n     * );\n     * result.subscribe(x => console.log(x), e => console.error(e));\n     *\n     * @see {@link create}\n     * @see {@link empty}\n     * @see {@link never}\n     * @see {@link of}\n     *\n     * @param {any} error The particular Error to pass to the error notification.\n     * @param {Scheduler} [scheduler] A {@link Scheduler} to use for scheduling\n     * the emission of the error notification.\n     * @return {Observable} An error Observable: emits only the error notification\n     * using the given error argument.\n     * @static true\n     * @name throw\n     * @owner Observable\n     */\n    ErrorObservable.create = function (error, scheduler) {\n        return new ErrorObservable(error, scheduler);\n    };\n    ErrorObservable.dispatch = function (arg) {\n        var error = arg.error, subscriber = arg.subscriber;\n        subscriber.error(error);\n    };\n    ErrorObservable.prototype._subscribe = function (subscriber) {\n        var error = this.error;\n        var scheduler = this.scheduler;\n        if (scheduler) {\n            return scheduler.schedule(ErrorObservable.dispatch, 0, {\n                error: error, subscriber: subscriber\n            });\n        }\n        else {\n            subscriber.error(error);\n        }\n    };\n    return ErrorObservable;\n}(Observable_1.Observable));\nexports.ErrorObservable = ErrorObservable;\n//# sourceMappingURL=ErrorObservable.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/observable/ErrorObservable.js\n ** module id = 125\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/observable/ErrorObservable.js?");

/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar timer_1 = __webpack_require__(127);\nObservable_1.Observable.timer = timer_1.timer;\n//# sourceMappingURL=timer.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/observable/timer.js\n ** module id = 126\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/observable/timer.js?");

/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar TimerObservable_1 = __webpack_require__(128);\nexports.timer = TimerObservable_1.TimerObservable.create;\n//# sourceMappingURL=timer.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/observable/timer.js\n ** module id = 127\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/observable/timer.js?");

/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar isNumeric_1 = __webpack_require__(95);\nvar Observable_1 = __webpack_require__(5);\nvar async_1 = __webpack_require__(96);\nvar isScheduler_1 = __webpack_require__(49);\nvar isDate_1 = __webpack_require__(129);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar TimerObservable = (function (_super) {\n    __extends(TimerObservable, _super);\n    function TimerObservable(dueTime, period, scheduler) {\n        if (dueTime === void 0) { dueTime = 0; }\n        _super.call(this);\n        this.period = -1;\n        this.dueTime = 0;\n        if (isNumeric_1.isNumeric(period)) {\n            this.period = Number(period) < 1 && 1 || Number(period);\n        }\n        else if (isScheduler_1.isScheduler(period)) {\n            scheduler = period;\n        }\n        if (!isScheduler_1.isScheduler(scheduler)) {\n            scheduler = async_1.async;\n        }\n        this.scheduler = scheduler;\n        this.dueTime = isDate_1.isDate(dueTime) ?\n            (+dueTime - this.scheduler.now()) :\n            dueTime;\n    }\n    /**\n     * Creates an Observable that starts emitting after an `initialDelay` and\n     * emits ever increasing numbers after each `period` of time thereafter.\n     *\n     * <span class=\"informal\">Its like {@link interval}, but you can specify when\n     * should the emissions start.</span>\n     *\n     * <img src=\"./img/timer.png\" width=\"100%\">\n     *\n     * `timer` returns an Observable that emits an infinite sequence of ascending\n     * integers, with a constant interval of time, `period` of your choosing\n     * between those emissions. The first emission happens after the specified\n     * `initialDelay`. The initial delay may be a {@link Date}. By default, this\n     * operator uses the `async` Scheduler to provide a notion of time, but you\n     * may pass any Scheduler to it. If `period` is not specified, the output\n     * Observable emits only one value, `0`. Otherwise, it emits an infinite\n     * sequence.\n     *\n     * @example <caption>Emits ascending numbers, one every second (1000ms), starting after 3 seconds</caption>\n     * var numbers = Rx.Observable.timer(3000, 1000);\n     * numbers.subscribe(x => console.log(x));\n     *\n     * @example <caption>Emits one number after five seconds</caption>\n     * var numbers = Rx.Observable.timer(5000);\n     * numbers.subscribe(x => console.log(x));\n     *\n     * @see {@link interval}\n     * @see {@link delay}\n     *\n     * @param {number|Date} initialDelay The initial delay time to wait before\n     * emitting the first value of `0`.\n     * @param {number} [period] The period of time between emissions of the\n     * subsequent numbers.\n     * @param {Scheduler} [scheduler=async] The Scheduler to use for scheduling\n     * the emission of values, and providing a notion of \"time\".\n     * @return {Observable} An Observable that emits a `0` after the\n     * `initialDelay` and ever increasing numbers after each `period` of time\n     * thereafter.\n     * @static true\n     * @name timer\n     * @owner Observable\n     */\n    TimerObservable.create = function (initialDelay, period, scheduler) {\n        if (initialDelay === void 0) { initialDelay = 0; }\n        return new TimerObservable(initialDelay, period, scheduler);\n    };\n    TimerObservable.dispatch = function (state) {\n        var index = state.index, period = state.period, subscriber = state.subscriber;\n        var action = this;\n        subscriber.next(index);\n        if (subscriber.closed) {\n            return;\n        }\n        else if (period === -1) {\n            return subscriber.complete();\n        }\n        state.index = index + 1;\n        action.schedule(state, period);\n    };\n    TimerObservable.prototype._subscribe = function (subscriber) {\n        var index = 0;\n        var _a = this, period = _a.period, dueTime = _a.dueTime, scheduler = _a.scheduler;\n        return scheduler.schedule(TimerObservable.dispatch, dueTime, {\n            index: index, period: period, subscriber: subscriber\n        });\n    };\n    return TimerObservable;\n}(Observable_1.Observable));\nexports.TimerObservable = TimerObservable;\n//# sourceMappingURL=TimerObservable.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/observable/TimerObservable.js\n ** module id = 128\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/observable/TimerObservable.js?");

/***/ },
/* 129 */
/***/ function(module, exports) {

	eval("\"use strict\";\nfunction isDate(value) {\n    return value instanceof Date && !isNaN(+value);\n}\nexports.isDate = isDate;\n//# sourceMappingURL=isDate.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/util/isDate.js\n ** module id = 129\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/util/isDate.js?");

/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar zip_1 = __webpack_require__(131);\nObservable_1.Observable.zip = zip_1.zip;\n//# sourceMappingURL=zip.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/observable/zip.js\n ** module id = 130\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/observable/zip.js?");

/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar zip_1 = __webpack_require__(132);\nexports.zip = zip_1.zipStatic;\n//# sourceMappingURL=zip.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/observable/zip.js\n ** module id = 131\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/observable/zip.js?");

/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar ArrayObservable_1 = __webpack_require__(50);\nvar isArray_1 = __webpack_require__(11);\nvar Subscriber_1 = __webpack_require__(8);\nvar OuterSubscriber_1 = __webpack_require__(54);\nvar subscribeToResult_1 = __webpack_require__(55);\nvar iterator_1 = __webpack_require__(57);\n/**\n * @param observables\n * @return {Observable<R>}\n * @method zip\n * @owner Observable\n */\nfunction zipProto() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    observables.unshift(this);\n    return zipStatic.apply(this, observables);\n}\nexports.zipProto = zipProto;\n/* tslint:enable:max-line-length */\n/**\n * @param observables\n * @return {Observable<R>}\n * @static true\n * @name zip\n * @owner Observable\n */\nfunction zipStatic() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    var project = observables[observables.length - 1];\n    if (typeof project === 'function') {\n        observables.pop();\n    }\n    return new ArrayObservable_1.ArrayObservable(observables).lift(new ZipOperator(project));\n}\nexports.zipStatic = zipStatic;\nvar ZipOperator = (function () {\n    function ZipOperator(project) {\n        this.project = project;\n    }\n    ZipOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new ZipSubscriber(subscriber, this.project));\n    };\n    return ZipOperator;\n}());\nexports.ZipOperator = ZipOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar ZipSubscriber = (function (_super) {\n    __extends(ZipSubscriber, _super);\n    function ZipSubscriber(destination, project, values) {\n        if (values === void 0) { values = Object.create(null); }\n        _super.call(this, destination);\n        this.index = 0;\n        this.iterators = [];\n        this.active = 0;\n        this.project = (typeof project === 'function') ? project : null;\n        this.values = values;\n    }\n    ZipSubscriber.prototype._next = function (value) {\n        var iterators = this.iterators;\n        var index = this.index++;\n        if (isArray_1.isArray(value)) {\n            iterators.push(new StaticArrayIterator(value));\n        }\n        else if (typeof value[iterator_1.$$iterator] === 'function') {\n            iterators.push(new StaticIterator(value[iterator_1.$$iterator]()));\n        }\n        else {\n            iterators.push(new ZipBufferIterator(this.destination, this, value, index));\n        }\n    };\n    ZipSubscriber.prototype._complete = function () {\n        var iterators = this.iterators;\n        var len = iterators.length;\n        this.active = len;\n        for (var i = 0; i < len; i++) {\n            var iterator = iterators[i];\n            if (iterator.stillUnsubscribed) {\n                this.add(iterator.subscribe(iterator, i));\n            }\n            else {\n                this.active--; // not an observable\n            }\n        }\n    };\n    ZipSubscriber.prototype.notifyInactive = function () {\n        this.active--;\n        if (this.active === 0) {\n            this.destination.complete();\n        }\n    };\n    ZipSubscriber.prototype.checkIterators = function () {\n        var iterators = this.iterators;\n        var len = iterators.length;\n        var destination = this.destination;\n        // abort if not all of them have values\n        for (var i = 0; i < len; i++) {\n            var iterator = iterators[i];\n            if (typeof iterator.hasValue === 'function' && !iterator.hasValue()) {\n                return;\n            }\n        }\n        var shouldComplete = false;\n        var args = [];\n        for (var i = 0; i < len; i++) {\n            var iterator = iterators[i];\n            var result = iterator.next();\n            // check to see if it's completed now that you've gotten\n            // the next value.\n            if (iterator.hasCompleted()) {\n                shouldComplete = true;\n            }\n            if (result.done) {\n                destination.complete();\n                return;\n            }\n            args.push(result.value);\n        }\n        if (this.project) {\n            this._tryProject(args);\n        }\n        else {\n            destination.next(args);\n        }\n        if (shouldComplete) {\n            destination.complete();\n        }\n    };\n    ZipSubscriber.prototype._tryProject = function (args) {\n        var result;\n        try {\n            result = this.project.apply(this, args);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.destination.next(result);\n    };\n    return ZipSubscriber;\n}(Subscriber_1.Subscriber));\nexports.ZipSubscriber = ZipSubscriber;\nvar StaticIterator = (function () {\n    function StaticIterator(iterator) {\n        this.iterator = iterator;\n        this.nextResult = iterator.next();\n    }\n    StaticIterator.prototype.hasValue = function () {\n        return true;\n    };\n    StaticIterator.prototype.next = function () {\n        var result = this.nextResult;\n        this.nextResult = this.iterator.next();\n        return result;\n    };\n    StaticIterator.prototype.hasCompleted = function () {\n        var nextResult = this.nextResult;\n        return nextResult && nextResult.done;\n    };\n    return StaticIterator;\n}());\nvar StaticArrayIterator = (function () {\n    function StaticArrayIterator(array) {\n        this.array = array;\n        this.index = 0;\n        this.length = 0;\n        this.length = array.length;\n    }\n    StaticArrayIterator.prototype[iterator_1.$$iterator] = function () {\n        return this;\n    };\n    StaticArrayIterator.prototype.next = function (value) {\n        var i = this.index++;\n        var array = this.array;\n        return i < this.length ? { value: array[i], done: false } : { value: null, done: true };\n    };\n    StaticArrayIterator.prototype.hasValue = function () {\n        return this.array.length > this.index;\n    };\n    StaticArrayIterator.prototype.hasCompleted = function () {\n        return this.array.length === this.index;\n    };\n    return StaticArrayIterator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar ZipBufferIterator = (function (_super) {\n    __extends(ZipBufferIterator, _super);\n    function ZipBufferIterator(destination, parent, observable, index) {\n        _super.call(this, destination);\n        this.parent = parent;\n        this.observable = observable;\n        this.index = index;\n        this.stillUnsubscribed = true;\n        this.buffer = [];\n        this.isComplete = false;\n    }\n    ZipBufferIterator.prototype[iterator_1.$$iterator] = function () {\n        return this;\n    };\n    // NOTE: there is actually a name collision here with Subscriber.next and Iterator.next\n    //    this is legit because `next()` will never be called by a subscription in this case.\n    ZipBufferIterator.prototype.next = function () {\n        var buffer = this.buffer;\n        if (buffer.length === 0 && this.isComplete) {\n            return { value: null, done: true };\n        }\n        else {\n            return { value: buffer.shift(), done: false };\n        }\n    };\n    ZipBufferIterator.prototype.hasValue = function () {\n        return this.buffer.length > 0;\n    };\n    ZipBufferIterator.prototype.hasCompleted = function () {\n        return this.buffer.length === 0 && this.isComplete;\n    };\n    ZipBufferIterator.prototype.notifyComplete = function () {\n        if (this.buffer.length > 0) {\n            this.isComplete = true;\n            this.parent.notifyInactive();\n        }\n        else {\n            this.destination.complete();\n        }\n    };\n    ZipBufferIterator.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.buffer.push(innerValue);\n        this.parent.checkIterators();\n    };\n    ZipBufferIterator.prototype.subscribe = function (value, index) {\n        return subscribeToResult_1.subscribeToResult(this, this.observable, this, index);\n    };\n    return ZipBufferIterator;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=zip.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/zip.js\n ** module id = 132\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/zip.js?");

/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar ajax_1 = __webpack_require__(134);\nObservable_1.Observable.ajax = ajax_1.ajax;\n//# sourceMappingURL=ajax.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/observable/dom/ajax.js\n ** module id = 133\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/observable/dom/ajax.js?");

/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar AjaxObservable_1 = __webpack_require__(135);\nexports.ajax = AjaxObservable_1.AjaxObservable.create;\n//# sourceMappingURL=ajax.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/observable/dom/ajax.js\n ** module id = 134\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/observable/dom/ajax.js?");

/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar root_1 = __webpack_require__(6);\nvar tryCatch_1 = __webpack_require__(13);\nvar errorObject_1 = __webpack_require__(14);\nvar Observable_1 = __webpack_require__(5);\nvar Subscriber_1 = __webpack_require__(8);\nvar map_1 = __webpack_require__(136);\nfunction getCORSRequest() {\n    if (root_1.root.XMLHttpRequest) {\n        var xhr = new root_1.root.XMLHttpRequest();\n        if ('withCredentials' in xhr) {\n            xhr.withCredentials = !!this.withCredentials;\n        }\n        return xhr;\n    }\n    else if (!!root_1.root.XDomainRequest) {\n        return new root_1.root.XDomainRequest();\n    }\n    else {\n        throw new Error('CORS is not supported by your browser');\n    }\n}\nfunction getXMLHttpRequest() {\n    if (root_1.root.XMLHttpRequest) {\n        return new root_1.root.XMLHttpRequest();\n    }\n    else {\n        var progId = void 0;\n        try {\n            var progIds = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'];\n            for (var i = 0; i < 3; i++) {\n                try {\n                    progId = progIds[i];\n                    if (new root_1.root.ActiveXObject(progId)) {\n                        break;\n                    }\n                }\n                catch (e) {\n                }\n            }\n            return new root_1.root.ActiveXObject(progId);\n        }\n        catch (e) {\n            throw new Error('XMLHttpRequest is not supported by your browser');\n        }\n    }\n}\nfunction ajaxGet(url, headers) {\n    if (headers === void 0) { headers = null; }\n    return new AjaxObservable({ method: 'GET', url: url, headers: headers });\n}\nexports.ajaxGet = ajaxGet;\n;\nfunction ajaxPost(url, body, headers) {\n    return new AjaxObservable({ method: 'POST', url: url, body: body, headers: headers });\n}\nexports.ajaxPost = ajaxPost;\n;\nfunction ajaxDelete(url, headers) {\n    return new AjaxObservable({ method: 'DELETE', url: url, headers: headers });\n}\nexports.ajaxDelete = ajaxDelete;\n;\nfunction ajaxPut(url, body, headers) {\n    return new AjaxObservable({ method: 'PUT', url: url, body: body, headers: headers });\n}\nexports.ajaxPut = ajaxPut;\n;\nfunction ajaxGetJSON(url, headers) {\n    return new AjaxObservable({ method: 'GET', url: url, responseType: 'json', headers: headers })\n        .lift(new map_1.MapOperator(function (x, index) { return x.response; }, null));\n}\nexports.ajaxGetJSON = ajaxGetJSON;\n;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar AjaxObservable = (function (_super) {\n    __extends(AjaxObservable, _super);\n    function AjaxObservable(urlOrRequest) {\n        _super.call(this);\n        var request = {\n            async: true,\n            createXHR: function () {\n                return this.crossDomain ? getCORSRequest.call(this) : getXMLHttpRequest();\n            },\n            crossDomain: false,\n            withCredentials: false,\n            headers: {},\n            method: 'GET',\n            responseType: 'json',\n            timeout: 0\n        };\n        if (typeof urlOrRequest === 'string') {\n            request.url = urlOrRequest;\n        }\n        else {\n            for (var prop in urlOrRequest) {\n                if (urlOrRequest.hasOwnProperty(prop)) {\n                    request[prop] = urlOrRequest[prop];\n                }\n            }\n        }\n        this.request = request;\n    }\n    AjaxObservable.prototype._subscribe = function (subscriber) {\n        return new AjaxSubscriber(subscriber, this.request);\n    };\n    /**\n     * Creates an observable for an Ajax request with either a request object with\n     * url, headers, etc or a string for a URL.\n     *\n     * @example\n     * source = Rx.Observable.ajax('/products');\n     * source = Rx.Observable.ajax({ url: 'products', method: 'GET' });\n     *\n     * @param {string|Object} request Can be one of the following:\n     *   A string of the URL to make the Ajax call.\n     *   An object with the following properties\n     *   - url: URL of the request\n     *   - body: The body of the request\n     *   - method: Method of the request, such as GET, POST, PUT, PATCH, DELETE\n     *   - async: Whether the request is async\n     *   - headers: Optional headers\n     *   - crossDomain: true if a cross domain request, else false\n     *   - createXHR: a function to override if you need to use an alternate\n     *   XMLHttpRequest implementation.\n     *   - resultSelector: a function to use to alter the output value type of\n     *   the Observable. Gets {@link AjaxResponse} as an argument.\n     * @return {Observable} An observable sequence containing the XMLHttpRequest.\n     * @static true\n     * @name ajax\n     * @owner Observable\n    */\n    AjaxObservable.create = (function () {\n        var create = function (urlOrRequest) {\n            return new AjaxObservable(urlOrRequest);\n        };\n        create.get = ajaxGet;\n        create.post = ajaxPost;\n        create.delete = ajaxDelete;\n        create.put = ajaxPut;\n        create.getJSON = ajaxGetJSON;\n        return create;\n    })();\n    return AjaxObservable;\n}(Observable_1.Observable));\nexports.AjaxObservable = AjaxObservable;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar AjaxSubscriber = (function (_super) {\n    __extends(AjaxSubscriber, _super);\n    function AjaxSubscriber(destination, request) {\n        _super.call(this, destination);\n        this.request = request;\n        this.done = false;\n        var headers = request.headers = request.headers || {};\n        // force CORS if requested\n        if (!request.crossDomain && !headers['X-Requested-With']) {\n            headers['X-Requested-With'] = 'XMLHttpRequest';\n        }\n        // ensure content type is set\n        if (!('Content-Type' in headers) && !(root_1.root.FormData && request.body instanceof root_1.root.FormData) && typeof request.body !== 'undefined') {\n            headers['Content-Type'] = 'application/x-www-form-urlencoded; charset=UTF-8';\n        }\n        // properly serialize body\n        request.body = this.serializeBody(request.body, request.headers['Content-Type']);\n        this.send();\n    }\n    AjaxSubscriber.prototype.next = function (e) {\n        this.done = true;\n        var _a = this, xhr = _a.xhr, request = _a.request, destination = _a.destination;\n        var response = new AjaxResponse(e, xhr, request);\n        destination.next(response);\n    };\n    AjaxSubscriber.prototype.send = function () {\n        var _a = this, request = _a.request, _b = _a.request, user = _b.user, method = _b.method, url = _b.url, async = _b.async, password = _b.password, headers = _b.headers, body = _b.body;\n        var createXHR = request.createXHR;\n        var xhr = tryCatch_1.tryCatch(createXHR).call(request);\n        if (xhr === errorObject_1.errorObject) {\n            this.error(errorObject_1.errorObject.e);\n        }\n        else {\n            this.xhr = xhr;\n            // open XHR first\n            var result = void 0;\n            if (user) {\n                result = tryCatch_1.tryCatch(xhr.open).call(xhr, method, url, async, user, password);\n            }\n            else {\n                result = tryCatch_1.tryCatch(xhr.open).call(xhr, method, url, async);\n            }\n            if (result === errorObject_1.errorObject) {\n                this.error(errorObject_1.errorObject.e);\n                return null;\n            }\n            // timeout and responseType can be set once the XHR is open\n            xhr.timeout = request.timeout;\n            xhr.responseType = request.responseType;\n            // set headers\n            this.setHeaders(xhr, headers);\n            // now set up the events\n            this.setupEvents(xhr, request);\n            // finally send the request\n            if (body) {\n                xhr.send(body);\n            }\n            else {\n                xhr.send();\n            }\n        }\n        return xhr;\n    };\n    AjaxSubscriber.prototype.serializeBody = function (body, contentType) {\n        if (!body || typeof body === 'string') {\n            return body;\n        }\n        else if (root_1.root.FormData && body instanceof root_1.root.FormData) {\n            return body;\n        }\n        if (contentType) {\n            var splitIndex = contentType.indexOf(';');\n            if (splitIndex !== -1) {\n                contentType = contentType.substring(0, splitIndex);\n            }\n        }\n        switch (contentType) {\n            case 'application/x-www-form-urlencoded':\n                return Object.keys(body).map(function (key) { return (encodeURI(key) + \"=\" + encodeURI(body[key])); }).join('&');\n            case 'application/json':\n                return JSON.stringify(body);\n            default:\n                return body;\n        }\n    };\n    AjaxSubscriber.prototype.setHeaders = function (xhr, headers) {\n        for (var key in headers) {\n            if (headers.hasOwnProperty(key)) {\n                xhr.setRequestHeader(key, headers[key]);\n            }\n        }\n    };\n    AjaxSubscriber.prototype.setupEvents = function (xhr, request) {\n        var progressSubscriber = request.progressSubscriber;\n        xhr.ontimeout = function xhrTimeout(e) {\n            var _a = xhrTimeout, subscriber = _a.subscriber, progressSubscriber = _a.progressSubscriber, request = _a.request;\n            if (progressSubscriber) {\n                progressSubscriber.error(e);\n            }\n            subscriber.error(new AjaxTimeoutError(this, request)); //TODO: Make betterer.\n        };\n        xhr.ontimeout.request = request;\n        xhr.ontimeout.subscriber = this;\n        xhr.ontimeout.progressSubscriber = progressSubscriber;\n        if (xhr.upload && 'withCredentials' in xhr && root_1.root.XDomainRequest) {\n            if (progressSubscriber) {\n                xhr.onprogress = function xhrProgress(e) {\n                    var progressSubscriber = xhrProgress.progressSubscriber;\n                    progressSubscriber.next(e);\n                };\n                xhr.onprogress.progressSubscriber = progressSubscriber;\n            }\n            xhr.onerror = function xhrError(e) {\n                var _a = xhrError, progressSubscriber = _a.progressSubscriber, subscriber = _a.subscriber, request = _a.request;\n                if (progressSubscriber) {\n                    progressSubscriber.error(e);\n                }\n                subscriber.error(new AjaxError('ajax error', this, request));\n            };\n            xhr.onerror.request = request;\n            xhr.onerror.subscriber = this;\n            xhr.onerror.progressSubscriber = progressSubscriber;\n        }\n        xhr.onreadystatechange = function xhrReadyStateChange(e) {\n            var _a = xhrReadyStateChange, subscriber = _a.subscriber, progressSubscriber = _a.progressSubscriber, request = _a.request;\n            if (this.readyState === 4) {\n                // normalize IE9 bug (http://bugs.jquery.com/ticket/1450)\n                var status_1 = this.status === 1223 ? 204 : this.status;\n                var response = (this.responseType === 'text' ? (this.response || this.responseText) : this.response);\n                // fix status code when it is 0 (0 status is undocumented).\n                // Occurs when accessing file resources or on Android 4.1 stock browser\n                // while retrieving files from application cache.\n                if (status_1 === 0) {\n                    status_1 = response ? 200 : 0;\n                }\n                if (200 <= status_1 && status_1 < 300) {\n                    if (progressSubscriber) {\n                        progressSubscriber.complete();\n                    }\n                    subscriber.next(e);\n                    subscriber.complete();\n                }\n                else {\n                    if (progressSubscriber) {\n                        progressSubscriber.error(e);\n                    }\n                    subscriber.error(new AjaxError('ajax error ' + status_1, this, request));\n                }\n            }\n        };\n        xhr.onreadystatechange.subscriber = this;\n        xhr.onreadystatechange.progressSubscriber = progressSubscriber;\n        xhr.onreadystatechange.request = request;\n    };\n    AjaxSubscriber.prototype.unsubscribe = function () {\n        var _a = this, done = _a.done, xhr = _a.xhr;\n        if (!done && xhr && xhr.readyState !== 4) {\n            xhr.abort();\n        }\n        _super.prototype.unsubscribe.call(this);\n    };\n    return AjaxSubscriber;\n}(Subscriber_1.Subscriber));\nexports.AjaxSubscriber = AjaxSubscriber;\n/**\n * A normalized AJAX response.\n *\n * @see {@link ajax}\n *\n * @class AjaxResponse\n */\nvar AjaxResponse = (function () {\n    function AjaxResponse(originalEvent, xhr, request) {\n        this.originalEvent = originalEvent;\n        this.xhr = xhr;\n        this.request = request;\n        this.status = xhr.status;\n        this.responseType = xhr.responseType || request.responseType;\n        switch (this.responseType) {\n            case 'json':\n                if ('response' in xhr) {\n                    //IE does not support json as responseType, parse it internally\n                    this.response = xhr.responseType ? xhr.response : JSON.parse(xhr.response || xhr.responseText || 'null');\n                }\n                else {\n                    this.response = JSON.parse(xhr.responseText || 'null');\n                }\n                break;\n            case 'xml':\n                this.response = xhr.responseXML;\n                break;\n            case 'text':\n            default:\n                this.response = ('response' in xhr) ? xhr.response : xhr.responseText;\n                break;\n        }\n    }\n    return AjaxResponse;\n}());\nexports.AjaxResponse = AjaxResponse;\n/**\n * A normalized AJAX error.\n *\n * @see {@link ajax}\n *\n * @class AjaxError\n */\nvar AjaxError = (function (_super) {\n    __extends(AjaxError, _super);\n    function AjaxError(message, xhr, request) {\n        _super.call(this, message);\n        this.message = message;\n        this.xhr = xhr;\n        this.request = request;\n        this.status = xhr.status;\n    }\n    return AjaxError;\n}(Error));\nexports.AjaxError = AjaxError;\n/**\n * @see {@link ajax}\n *\n * @class AjaxTimeoutError\n */\nvar AjaxTimeoutError = (function (_super) {\n    __extends(AjaxTimeoutError, _super);\n    function AjaxTimeoutError(xhr, request) {\n        _super.call(this, 'ajax timeout', xhr, request);\n    }\n    return AjaxTimeoutError;\n}(AjaxError));\nexports.AjaxTimeoutError = AjaxTimeoutError;\n//# sourceMappingURL=AjaxObservable.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/observable/dom/AjaxObservable.js\n ** module id = 135\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/observable/dom/AjaxObservable.js?");

/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(8);\n/**\n * Applies a given `project` function to each value emitted by the source\n * Observable, and emits the resulting values as an Observable.\n *\n * <span class=\"informal\">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),\n * it passes each source value through a transformation function to get\n * corresponding output values.</span>\n *\n * <img src=\"./img/map.png\" width=\"100%\">\n *\n * Similar to the well known `Array.prototype.map` function, this operator\n * applies a projection to each value and emits that projection in the output\n * Observable.\n *\n * @example <caption>Map every every click to the clientX position of that click</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var positions = clicks.map(ev => ev.clientX);\n * positions.subscribe(x => console.log(x));\n *\n * @see {@link mapTo}\n * @see {@link pluck}\n *\n * @param {function(value: T, index: number): R} project The function to apply\n * to each `value` emitted by the source Observable. The `index` parameter is\n * the number `i` for the i-th emission that has happened since the\n * subscription, starting from the number `0`.\n * @param {any} [thisArg] An optional argument to define what `this` is in the\n * `project` function.\n * @return {Observable<R>} An Observable that emits the values from the source\n * Observable transformed by the given `project` function.\n * @method map\n * @owner Observable\n */\nfunction map(project, thisArg) {\n    if (typeof project !== 'function') {\n        throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');\n    }\n    return this.lift(new MapOperator(project, thisArg));\n}\nexports.map = map;\nvar MapOperator = (function () {\n    function MapOperator(project, thisArg) {\n        this.project = project;\n        this.thisArg = thisArg;\n    }\n    MapOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));\n    };\n    return MapOperator;\n}());\nexports.MapOperator = MapOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar MapSubscriber = (function (_super) {\n    __extends(MapSubscriber, _super);\n    function MapSubscriber(destination, project, thisArg) {\n        _super.call(this, destination);\n        this.project = project;\n        this.count = 0;\n        this.thisArg = thisArg || this;\n    }\n    // NOTE: This looks unoptimized, but it's actually purposefully NOT\n    // using try/catch optimizations.\n    MapSubscriber.prototype._next = function (value) {\n        var result;\n        try {\n            result = this.project.call(this.thisArg, value, this.count++);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.destination.next(result);\n    };\n    return MapSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=map.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/map.js\n ** module id = 136\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/map.js?");

/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar webSocket_1 = __webpack_require__(138);\nObservable_1.Observable.webSocket = webSocket_1.webSocket;\n//# sourceMappingURL=webSocket.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/observable/dom/webSocket.js\n ** module id = 137\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/observable/dom/webSocket.js?");

/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar WebSocketSubject_1 = __webpack_require__(139);\nexports.webSocket = WebSocketSubject_1.WebSocketSubject.create;\n//# sourceMappingURL=webSocket.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/observable/dom/webSocket.js\n ** module id = 138\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/observable/dom/webSocket.js?");

/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = __webpack_require__(4);\nvar Subscriber_1 = __webpack_require__(8);\nvar Observable_1 = __webpack_require__(5);\nvar Subscription_1 = __webpack_require__(10);\nvar root_1 = __webpack_require__(6);\nvar ReplaySubject_1 = __webpack_require__(140);\nvar tryCatch_1 = __webpack_require__(13);\nvar errorObject_1 = __webpack_require__(14);\nvar assign_1 = __webpack_require__(144);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar WebSocketSubject = (function (_super) {\n    __extends(WebSocketSubject, _super);\n    function WebSocketSubject(urlConfigOrSource, destination) {\n        if (urlConfigOrSource instanceof Observable_1.Observable) {\n            _super.call(this, destination, urlConfigOrSource);\n        }\n        else {\n            _super.call(this);\n            this.WebSocketCtor = root_1.root.WebSocket;\n            this._output = new Subject_1.Subject();\n            if (typeof urlConfigOrSource === 'string') {\n                this.url = urlConfigOrSource;\n            }\n            else {\n                // WARNING: config object could override important members here.\n                assign_1.assign(this, urlConfigOrSource);\n            }\n            if (!this.WebSocketCtor) {\n                throw new Error('no WebSocket constructor can be found');\n            }\n            this.destination = new ReplaySubject_1.ReplaySubject();\n        }\n    }\n    WebSocketSubject.prototype.resultSelector = function (e) {\n        return JSON.parse(e.data);\n    };\n    /**\n     * @param urlConfigOrSource\n     * @return {WebSocketSubject}\n     * @static true\n     * @name webSocket\n     * @owner Observable\n     */\n    WebSocketSubject.create = function (urlConfigOrSource) {\n        return new WebSocketSubject(urlConfigOrSource);\n    };\n    WebSocketSubject.prototype.lift = function (operator) {\n        var sock = new WebSocketSubject(this, this.destination);\n        sock.operator = operator;\n        return sock;\n    };\n    // TODO: factor this out to be a proper Operator/Subscriber implementation and eliminate closures\n    WebSocketSubject.prototype.multiplex = function (subMsg, unsubMsg, messageFilter) {\n        var self = this;\n        return new Observable_1.Observable(function (observer) {\n            var result = tryCatch_1.tryCatch(subMsg)();\n            if (result === errorObject_1.errorObject) {\n                observer.error(errorObject_1.errorObject.e);\n            }\n            else {\n                self.next(result);\n            }\n            var subscription = self.subscribe(function (x) {\n                var result = tryCatch_1.tryCatch(messageFilter)(x);\n                if (result === errorObject_1.errorObject) {\n                    observer.error(errorObject_1.errorObject.e);\n                }\n                else if (result) {\n                    observer.next(x);\n                }\n            }, function (err) { return observer.error(err); }, function () { return observer.complete(); });\n            return function () {\n                var result = tryCatch_1.tryCatch(unsubMsg)();\n                if (result === errorObject_1.errorObject) {\n                    observer.error(errorObject_1.errorObject.e);\n                }\n                else {\n                    self.next(result);\n                }\n                subscription.unsubscribe();\n            };\n        });\n    };\n    WebSocketSubject.prototype._connectSocket = function () {\n        var _this = this;\n        var WebSocketCtor = this.WebSocketCtor;\n        var observer = this._output;\n        var socket = null;\n        try {\n            socket = this.protocol ?\n                new WebSocketCtor(this.url, this.protocol) :\n                new WebSocketCtor(this.url);\n            this.socket = socket;\n        }\n        catch (e) {\n            observer.error(e);\n            return;\n        }\n        var subscription = new Subscription_1.Subscription(function () {\n            _this.socket = null;\n            if (socket && socket.readyState === 1) {\n                socket.close();\n            }\n        });\n        socket.onopen = function (e) {\n            var openObserver = _this.openObserver;\n            if (openObserver) {\n                openObserver.next(e);\n            }\n            var queue = _this.destination;\n            _this.destination = Subscriber_1.Subscriber.create(function (x) { return socket.readyState === 1 && socket.send(x); }, function (e) {\n                var closingObserver = _this.closingObserver;\n                if (closingObserver) {\n                    closingObserver.next(undefined);\n                }\n                if (e && e.code) {\n                    socket.close(e.code, e.reason);\n                }\n                else {\n                    observer.error(new TypeError('WebSocketSubject.error must be called with an object with an error code, ' +\n                        'and an optional reason: { code: number, reason: string }'));\n                }\n                _this.destination = new ReplaySubject_1.ReplaySubject();\n                _this.socket = null;\n            }, function () {\n                var closingObserver = _this.closingObserver;\n                if (closingObserver) {\n                    closingObserver.next(undefined);\n                }\n                socket.close();\n                _this.destination = new ReplaySubject_1.ReplaySubject();\n                _this.socket = null;\n            });\n            if (queue && queue instanceof ReplaySubject_1.ReplaySubject) {\n                subscription.add(queue.subscribe(_this.destination));\n            }\n        };\n        socket.onerror = function (e) { return observer.error(e); };\n        socket.onclose = function (e) {\n            var closeObserver = _this.closeObserver;\n            if (closeObserver) {\n                closeObserver.next(e);\n            }\n            if (e.wasClean) {\n                observer.complete();\n            }\n            else {\n                observer.error(e);\n            }\n        };\n        socket.onmessage = function (e) {\n            var result = tryCatch_1.tryCatch(_this.resultSelector)(e);\n            if (result === errorObject_1.errorObject) {\n                observer.error(errorObject_1.errorObject.e);\n            }\n            else {\n                observer.next(result);\n            }\n        };\n    };\n    WebSocketSubject.prototype._subscribe = function (subscriber) {\n        var _this = this;\n        var source = this.source;\n        if (source) {\n            return source.subscribe(subscriber);\n        }\n        if (!this.socket) {\n            this._connectSocket();\n        }\n        var subscription = new Subscription_1.Subscription();\n        subscription.add(this._output.subscribe(subscriber));\n        subscription.add(function () {\n            var socket = _this.socket;\n            if (_this._output.observers.length === 0 && socket && socket.readyState === 1) {\n                socket.close();\n                _this.socket = null;\n            }\n        });\n        return subscription;\n    };\n    WebSocketSubject.prototype.unsubscribe = function () {\n        var _a = this, source = _a.source, socket = _a.socket;\n        if (socket && socket.readyState === 1) {\n            socket.close();\n            this.socket = null;\n        }\n        _super.prototype.unsubscribe.call(this);\n        if (!source) {\n            this.destination = new ReplaySubject_1.ReplaySubject();\n        }\n    };\n    return WebSocketSubject;\n}(Subject_1.AnonymousSubject));\nexports.WebSocketSubject = WebSocketSubject;\n//# sourceMappingURL=WebSocketSubject.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/observable/dom/WebSocketSubject.js\n ** module id = 139\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/observable/dom/WebSocketSubject.js?");

/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = __webpack_require__(4);\nvar queue_1 = __webpack_require__(141);\nvar observeOn_1 = __webpack_require__(77);\n/**\n * @class ReplaySubject<T>\n */\nvar ReplaySubject = (function (_super) {\n    __extends(ReplaySubject, _super);\n    function ReplaySubject(bufferSize, windowTime, scheduler) {\n        if (bufferSize === void 0) { bufferSize = Number.POSITIVE_INFINITY; }\n        if (windowTime === void 0) { windowTime = Number.POSITIVE_INFINITY; }\n        _super.call(this);\n        this.scheduler = scheduler;\n        this._events = [];\n        this._bufferSize = bufferSize < 1 ? 1 : bufferSize;\n        this._windowTime = windowTime < 1 ? 1 : windowTime;\n    }\n    ReplaySubject.prototype.next = function (value) {\n        var now = this._getNow();\n        this._events.push(new ReplayEvent(now, value));\n        this._trimBufferThenGetEvents();\n        _super.prototype.next.call(this, value);\n    };\n    ReplaySubject.prototype._subscribe = function (subscriber) {\n        var _events = this._trimBufferThenGetEvents();\n        var scheduler = this.scheduler;\n        if (scheduler) {\n            subscriber.add(subscriber = new observeOn_1.ObserveOnSubscriber(subscriber, scheduler));\n        }\n        var len = _events.length;\n        for (var i = 0; i < len && !subscriber.closed; i++) {\n            subscriber.next(_events[i].value);\n        }\n        return _super.prototype._subscribe.call(this, subscriber);\n    };\n    ReplaySubject.prototype._getNow = function () {\n        return (this.scheduler || queue_1.queue).now();\n    };\n    ReplaySubject.prototype._trimBufferThenGetEvents = function () {\n        var now = this._getNow();\n        var _bufferSize = this._bufferSize;\n        var _windowTime = this._windowTime;\n        var _events = this._events;\n        var eventsCount = _events.length;\n        var spliceCount = 0;\n        // Trim events that fall out of the time window.\n        // Start at the front of the list. Break early once\n        // we encounter an event that falls within the window.\n        while (spliceCount < eventsCount) {\n            if ((now - _events[spliceCount].time) < _windowTime) {\n                break;\n            }\n            spliceCount++;\n        }\n        if (eventsCount > _bufferSize) {\n            spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);\n        }\n        if (spliceCount > 0) {\n            _events.splice(0, spliceCount);\n        }\n        return _events;\n    };\n    return ReplaySubject;\n}(Subject_1.Subject));\nexports.ReplaySubject = ReplaySubject;\nvar ReplayEvent = (function () {\n    function ReplayEvent(time, value) {\n        this.time = time;\n        this.value = value;\n    }\n    return ReplayEvent;\n}());\n//# sourceMappingURL=ReplaySubject.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/ReplaySubject.js\n ** module id = 140\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/ReplaySubject.js?");

/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar QueueAction_1 = __webpack_require__(142);\nvar QueueScheduler_1 = __webpack_require__(143);\nexports.queue = new QueueScheduler_1.QueueScheduler(QueueAction_1.QueueAction);\n//# sourceMappingURL=queue.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/scheduler/queue.js\n ** module id = 141\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/scheduler/queue.js?");

/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar AsyncAction_1 = __webpack_require__(97);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar QueueAction = (function (_super) {\n    __extends(QueueAction, _super);\n    function QueueAction(scheduler, work) {\n        _super.call(this, scheduler, work);\n        this.scheduler = scheduler;\n        this.work = work;\n    }\n    QueueAction.prototype.schedule = function (state, delay) {\n        if (delay === void 0) { delay = 0; }\n        if (delay > 0) {\n            return _super.prototype.schedule.call(this, state, delay);\n        }\n        this.delay = delay;\n        this.state = state;\n        this.scheduler.flush(this);\n        return this;\n    };\n    QueueAction.prototype.execute = function (state, delay) {\n        return (delay > 0 || this.closed) ?\n            _super.prototype.execute.call(this, state, delay) :\n            this._execute(state, delay);\n    };\n    QueueAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) { delay = 0; }\n        // If delay is greater than 0, enqueue as an async action.\n        if (delay !== null && delay > 0) {\n            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);\n        }\n        // Otherwise flush the scheduler starting with this action.\n        return scheduler.flush(this);\n    };\n    return QueueAction;\n}(AsyncAction_1.AsyncAction));\nexports.QueueAction = QueueAction;\n//# sourceMappingURL=QueueAction.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/scheduler/QueueAction.js\n ** module id = 142\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/scheduler/QueueAction.js?");

/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar AsyncScheduler_1 = __webpack_require__(99);\nvar QueueScheduler = (function (_super) {\n    __extends(QueueScheduler, _super);\n    function QueueScheduler() {\n        _super.apply(this, arguments);\n    }\n    return QueueScheduler;\n}(AsyncScheduler_1.AsyncScheduler));\nexports.QueueScheduler = QueueScheduler;\n//# sourceMappingURL=QueueScheduler.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/scheduler/QueueScheduler.js\n ** module id = 143\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/scheduler/QueueScheduler.js?");

/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar root_1 = __webpack_require__(6);\nvar Object = root_1.root.Object;\nif (typeof Object.assign != 'function') {\n    (function () {\n        Object.assign = function assignPolyfill(target) {\n            var sources = [];\n            for (var _i = 1; _i < arguments.length; _i++) {\n                sources[_i - 1] = arguments[_i];\n            }\n            if (target === undefined || target === null) {\n                throw new TypeError('cannot convert undefined or null to object');\n            }\n            var output = Object(target);\n            var len = sources.length;\n            for (var index = 0; index < len; index++) {\n                var source = sources[index];\n                if (source !== undefined && source !== null) {\n                    for (var key in source) {\n                        if (source.hasOwnProperty(key)) {\n                            output[key] = source[key];\n                        }\n                    }\n                }\n            }\n            return output;\n        };\n    })();\n}\nexports.assign = Object.assign;\n//# sourceMappingURL=assign.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/util/assign.js\n ** module id = 144\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/util/assign.js?");

/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar buffer_1 = __webpack_require__(146);\nObservable_1.Observable.prototype.buffer = buffer_1.buffer;\n//# sourceMappingURL=buffer.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/buffer.js\n ** module id = 145\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/buffer.js?");

/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = __webpack_require__(54);\nvar subscribeToResult_1 = __webpack_require__(55);\n/**\n * Buffers the source Observable values until `closingNotifier` emits.\n *\n * <span class=\"informal\">Collects values from the past as an array, and emits\n * that array only when another Observable emits.</span>\n *\n * <img src=\"./img/buffer.png\" width=\"100%\">\n *\n * Buffers the incoming Observable values until the given `closingNotifier`\n * Observable emits a value, at which point it emits the buffer on the output\n * Observable and starts a new buffer internally, awaiting the next time\n * `closingNotifier` emits.\n *\n * @example <caption>On every click, emit array of most recent interval events</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var interval = Rx.Observable.interval(1000);\n * var buffered = interval.buffer(clicks);\n * buffered.subscribe(x => console.log(x));\n *\n * @see {@link bufferCount}\n * @see {@link bufferTime}\n * @see {@link bufferToggle}\n * @see {@link bufferWhen}\n * @see {@link window}\n *\n * @param {Observable<any>} closingNotifier An Observable that signals the\n * buffer to be emitted on the output Observable.\n * @return {Observable<T[]>} An Observable of buffers, which are arrays of\n * values.\n * @method buffer\n * @owner Observable\n */\nfunction buffer(closingNotifier) {\n    return this.lift(new BufferOperator(closingNotifier));\n}\nexports.buffer = buffer;\nvar BufferOperator = (function () {\n    function BufferOperator(closingNotifier) {\n        this.closingNotifier = closingNotifier;\n    }\n    BufferOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new BufferSubscriber(subscriber, this.closingNotifier));\n    };\n    return BufferOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar BufferSubscriber = (function (_super) {\n    __extends(BufferSubscriber, _super);\n    function BufferSubscriber(destination, closingNotifier) {\n        _super.call(this, destination);\n        this.buffer = [];\n        this.add(subscribeToResult_1.subscribeToResult(this, closingNotifier));\n    }\n    BufferSubscriber.prototype._next = function (value) {\n        this.buffer.push(value);\n    };\n    BufferSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        var buffer = this.buffer;\n        this.buffer = [];\n        this.destination.next(buffer);\n    };\n    return BufferSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=buffer.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/buffer.js\n ** module id = 146\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/buffer.js?");

/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar bufferCount_1 = __webpack_require__(148);\nObservable_1.Observable.prototype.bufferCount = bufferCount_1.bufferCount;\n//# sourceMappingURL=bufferCount.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/bufferCount.js\n ** module id = 147\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/bufferCount.js?");

/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(8);\n/**\n * Buffers the source Observable values until the size hits the maximum\n * `bufferSize` given.\n *\n * <span class=\"informal\">Collects values from the past as an array, and emits\n * that array only when its size reaches `bufferSize`.</span>\n *\n * <img src=\"./img/bufferCount.png\" width=\"100%\">\n *\n * Buffers a number of values from the source Observable by `bufferSize` then\n * emits the buffer and clears it, and starts a new buffer each\n * `startBufferEvery` values. If `startBufferEvery` is not provided or is\n * `null`, then new buffers are started immediately at the start of the source\n * and when each buffer closes and is emitted.\n *\n * @example <caption>Emit the last two click events as an array</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferCount(2);\n * buffered.subscribe(x => console.log(x));\n *\n * @example <caption>On every click, emit the last two click events as an array</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferCount(2, 1);\n * buffered.subscribe(x => console.log(x));\n *\n * @see {@link buffer}\n * @see {@link bufferTime}\n * @see {@link bufferToggle}\n * @see {@link bufferWhen}\n * @see {@link pairwise}\n * @see {@link windowCount}\n *\n * @param {number} bufferSize The maximum size of the buffer emitted.\n * @param {number} [startBufferEvery] Interval at which to start a new buffer.\n * For example if `startBufferEvery` is `2`, then a new buffer will be started\n * on every other value from the source. A new buffer is started at the\n * beginning of the source by default.\n * @return {Observable<T[]>} An Observable of arrays of buffered values.\n * @method bufferCount\n * @owner Observable\n */\nfunction bufferCount(bufferSize, startBufferEvery) {\n    if (startBufferEvery === void 0) { startBufferEvery = null; }\n    return this.lift(new BufferCountOperator(bufferSize, startBufferEvery));\n}\nexports.bufferCount = bufferCount;\nvar BufferCountOperator = (function () {\n    function BufferCountOperator(bufferSize, startBufferEvery) {\n        this.bufferSize = bufferSize;\n        this.startBufferEvery = startBufferEvery;\n    }\n    BufferCountOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new BufferCountSubscriber(subscriber, this.bufferSize, this.startBufferEvery));\n    };\n    return BufferCountOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar BufferCountSubscriber = (function (_super) {\n    __extends(BufferCountSubscriber, _super);\n    function BufferCountSubscriber(destination, bufferSize, startBufferEvery) {\n        _super.call(this, destination);\n        this.bufferSize = bufferSize;\n        this.startBufferEvery = startBufferEvery;\n        this.buffers = [[]];\n        this.count = 0;\n    }\n    BufferCountSubscriber.prototype._next = function (value) {\n        var count = (this.count += 1);\n        var destination = this.destination;\n        var bufferSize = this.bufferSize;\n        var startBufferEvery = (this.startBufferEvery == null) ? bufferSize : this.startBufferEvery;\n        var buffers = this.buffers;\n        var len = buffers.length;\n        var remove = -1;\n        if (count % startBufferEvery === 0) {\n            buffers.push([]);\n        }\n        for (var i = 0; i < len; i++) {\n            var buffer = buffers[i];\n            buffer.push(value);\n            if (buffer.length === bufferSize) {\n                remove = i;\n                destination.next(buffer);\n            }\n        }\n        if (remove !== -1) {\n            buffers.splice(remove, 1);\n        }\n    };\n    BufferCountSubscriber.prototype._complete = function () {\n        var destination = this.destination;\n        var buffers = this.buffers;\n        while (buffers.length > 0) {\n            var buffer = buffers.shift();\n            if (buffer.length > 0) {\n                destination.next(buffer);\n            }\n        }\n        _super.prototype._complete.call(this);\n    };\n    return BufferCountSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=bufferCount.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/bufferCount.js\n ** module id = 148\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/bufferCount.js?");

/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar bufferTime_1 = __webpack_require__(150);\nObservable_1.Observable.prototype.bufferTime = bufferTime_1.bufferTime;\n//# sourceMappingURL=bufferTime.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/bufferTime.js\n ** module id = 149\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/bufferTime.js?");

/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar async_1 = __webpack_require__(96);\nvar Subscriber_1 = __webpack_require__(8);\nvar isScheduler_1 = __webpack_require__(49);\n/**\n * Buffers the source Observable values for a specific time period.\n *\n * <span class=\"informal\">Collects values from the past as an array, and emits\n * those arrays periodically in time.</span>\n *\n * <img src=\"./img/bufferTime.png\" width=\"100%\">\n *\n * Buffers values from the source for a specific time duration `bufferTimeSpan`.\n * Unless the optional argument `bufferCreationInterval` is given, it emits and\n * resets the buffer every `bufferTimeSpan` milliseconds. If\n * `bufferCreationInterval` is given, this operator opens the buffer every\n * `bufferCreationInterval` milliseconds and closes (emits and resets) the\n * buffer every `bufferTimeSpan` milliseconds. When the optional argument\n * `maxBufferSize` is specified, the buffer will be closed either after\n * `bufferTimeSpan` milliseconds or when it contains `maxBufferSize` elements.\n *\n * @example <caption>Every second, emit an array of the recent click events</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferTime(1000);\n * buffered.subscribe(x => console.log(x));\n *\n * @example <caption>Every 5 seconds, emit the click events from the next 2 seconds</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferTime(2000, 5000);\n * buffered.subscribe(x => console.log(x));\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n * @see {@link bufferToggle}\n * @see {@link bufferWhen}\n * @see {@link windowTime}\n *\n * @param {number} bufferTimeSpan The amount of time to fill each buffer array.\n * @param {number} [bufferCreationInterval] The interval at which to start new\n * buffers.\n * @param {number} [maxBufferSize] The maximum buffer size.\n * @param {Scheduler} [scheduler=async] The scheduler on which to schedule the\n * intervals that determine buffer boundaries.\n * @return {Observable<T[]>} An observable of arrays of buffered values.\n * @method bufferTime\n * @owner Observable\n */\nfunction bufferTime(bufferTimeSpan) {\n    var length = arguments.length;\n    var scheduler = async_1.async;\n    if (isScheduler_1.isScheduler(arguments[arguments.length - 1])) {\n        scheduler = arguments[arguments.length - 1];\n        length--;\n    }\n    var bufferCreationInterval = null;\n    if (length >= 2) {\n        bufferCreationInterval = arguments[1];\n    }\n    var maxBufferSize = Number.POSITIVE_INFINITY;\n    if (length >= 3) {\n        maxBufferSize = arguments[2];\n    }\n    return this.lift(new BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler));\n}\nexports.bufferTime = bufferTime;\nvar BufferTimeOperator = (function () {\n    function BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {\n        this.bufferTimeSpan = bufferTimeSpan;\n        this.bufferCreationInterval = bufferCreationInterval;\n        this.maxBufferSize = maxBufferSize;\n        this.scheduler = scheduler;\n    }\n    BufferTimeOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new BufferTimeSubscriber(subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));\n    };\n    return BufferTimeOperator;\n}());\nvar Context = (function () {\n    function Context() {\n        this.buffer = [];\n    }\n    return Context;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar BufferTimeSubscriber = (function (_super) {\n    __extends(BufferTimeSubscriber, _super);\n    function BufferTimeSubscriber(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {\n        _super.call(this, destination);\n        this.bufferTimeSpan = bufferTimeSpan;\n        this.bufferCreationInterval = bufferCreationInterval;\n        this.maxBufferSize = maxBufferSize;\n        this.scheduler = scheduler;\n        this.contexts = [];\n        var context = this.openContext();\n        this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;\n        if (this.timespanOnly) {\n            var timeSpanOnlyState = { subscriber: this, context: context, bufferTimeSpan: bufferTimeSpan };\n            this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\n        }\n        else {\n            var closeState = { subscriber: this, context: context };\n            var creationState = { bufferTimeSpan: bufferTimeSpan, bufferCreationInterval: bufferCreationInterval, subscriber: this, scheduler: scheduler };\n            this.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));\n            this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));\n        }\n    }\n    BufferTimeSubscriber.prototype._next = function (value) {\n        var contexts = this.contexts;\n        var len = contexts.length;\n        var filledBufferContext;\n        for (var i = 0; i < len; i++) {\n            var context = contexts[i];\n            var buffer = context.buffer;\n            buffer.push(value);\n            if (buffer.length == this.maxBufferSize) {\n                filledBufferContext = context;\n            }\n        }\n        if (filledBufferContext) {\n            this.onBufferFull(filledBufferContext);\n        }\n    };\n    BufferTimeSubscriber.prototype._error = function (err) {\n        this.contexts.length = 0;\n        _super.prototype._error.call(this, err);\n    };\n    BufferTimeSubscriber.prototype._complete = function () {\n        var _a = this, contexts = _a.contexts, destination = _a.destination;\n        while (contexts.length > 0) {\n            var context = contexts.shift();\n            destination.next(context.buffer);\n        }\n        _super.prototype._complete.call(this);\n    };\n    BufferTimeSubscriber.prototype._unsubscribe = function () {\n        this.contexts = null;\n    };\n    BufferTimeSubscriber.prototype.onBufferFull = function (context) {\n        this.closeContext(context);\n        var closeAction = context.closeAction;\n        closeAction.unsubscribe();\n        this.remove(closeAction);\n        if (this.timespanOnly) {\n            context = this.openContext();\n            var bufferTimeSpan = this.bufferTimeSpan;\n            var timeSpanOnlyState = { subscriber: this, context: context, bufferTimeSpan: bufferTimeSpan };\n            this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\n        }\n    };\n    BufferTimeSubscriber.prototype.openContext = function () {\n        var context = new Context();\n        this.contexts.push(context);\n        return context;\n    };\n    BufferTimeSubscriber.prototype.closeContext = function (context) {\n        this.destination.next(context.buffer);\n        var contexts = this.contexts;\n        var spliceIndex = contexts ? contexts.indexOf(context) : -1;\n        if (spliceIndex >= 0) {\n            contexts.splice(contexts.indexOf(context), 1);\n        }\n    };\n    return BufferTimeSubscriber;\n}(Subscriber_1.Subscriber));\nfunction dispatchBufferTimeSpanOnly(state) {\n    var subscriber = state.subscriber;\n    var prevContext = state.context;\n    if (prevContext) {\n        subscriber.closeContext(prevContext);\n    }\n    if (!subscriber.closed) {\n        state.context = subscriber.openContext();\n        state.context.closeAction = this.schedule(state, state.bufferTimeSpan);\n    }\n}\nfunction dispatchBufferCreation(state) {\n    var bufferCreationInterval = state.bufferCreationInterval, bufferTimeSpan = state.bufferTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler;\n    var context = subscriber.openContext();\n    var action = this;\n    if (!subscriber.closed) {\n        subscriber.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, { subscriber: subscriber, context: context }));\n        action.schedule(state, bufferCreationInterval);\n    }\n}\nfunction dispatchBufferClose(arg) {\n    var subscriber = arg.subscriber, context = arg.context;\n    subscriber.closeContext(context);\n}\n//# sourceMappingURL=bufferTime.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/bufferTime.js\n ** module id = 150\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/bufferTime.js?");

/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar bufferToggle_1 = __webpack_require__(152);\nObservable_1.Observable.prototype.bufferToggle = bufferToggle_1.bufferToggle;\n//# sourceMappingURL=bufferToggle.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/bufferToggle.js\n ** module id = 151\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/bufferToggle.js?");

/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscription_1 = __webpack_require__(10);\nvar subscribeToResult_1 = __webpack_require__(55);\nvar OuterSubscriber_1 = __webpack_require__(54);\n/**\n * Buffers the source Observable values starting from an emission from\n * `openings` and ending when the output of `closingSelector` emits.\n *\n * <span class=\"informal\">Collects values from the past as an array. Starts\n * collecting only when `opening` emits, and calls the `closingSelector`\n * function to get an Observable that tells when to close the buffer.</span>\n *\n * <img src=\"./img/bufferToggle.png\" width=\"100%\">\n *\n * Buffers values from the source by opening the buffer via signals from an\n * Observable provided to `openings`, and closing and sending the buffers when\n * a Subscribable or Promise returned by the `closingSelector` function emits.\n *\n * @example <caption>Every other second, emit the click events from the next 500ms</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var openings = Rx.Observable.interval(1000);\n * var buffered = clicks.bufferToggle(openings, i =>\n *   i % 2 ? Rx.Observable.interval(500) : Rx.Observable.empty()\n * );\n * buffered.subscribe(x => console.log(x));\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n * @see {@link bufferTime}\n * @see {@link bufferWhen}\n * @see {@link windowToggle}\n *\n * @param {SubscribableOrPromise<O>} openings A Subscribable or Promise of notifications to start new\n * buffers.\n * @param {function(value: O): SubscribableOrPromise} closingSelector A function that takes\n * the value emitted by the `openings` observable and returns a Subscribable or Promise,\n * which, when it emits, signals that the associated buffer should be emitted\n * and cleared.\n * @return {Observable<T[]>} An observable of arrays of buffered values.\n * @method bufferToggle\n * @owner Observable\n */\nfunction bufferToggle(openings, closingSelector) {\n    return this.lift(new BufferToggleOperator(openings, closingSelector));\n}\nexports.bufferToggle = bufferToggle;\nvar BufferToggleOperator = (function () {\n    function BufferToggleOperator(openings, closingSelector) {\n        this.openings = openings;\n        this.closingSelector = closingSelector;\n    }\n    BufferToggleOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new BufferToggleSubscriber(subscriber, this.openings, this.closingSelector));\n    };\n    return BufferToggleOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar BufferToggleSubscriber = (function (_super) {\n    __extends(BufferToggleSubscriber, _super);\n    function BufferToggleSubscriber(destination, openings, closingSelector) {\n        _super.call(this, destination);\n        this.openings = openings;\n        this.closingSelector = closingSelector;\n        this.contexts = [];\n        this.add(subscribeToResult_1.subscribeToResult(this, openings));\n    }\n    BufferToggleSubscriber.prototype._next = function (value) {\n        var contexts = this.contexts;\n        var len = contexts.length;\n        for (var i = 0; i < len; i++) {\n            contexts[i].buffer.push(value);\n        }\n    };\n    BufferToggleSubscriber.prototype._error = function (err) {\n        var contexts = this.contexts;\n        while (contexts.length > 0) {\n            var context = contexts.shift();\n            context.subscription.unsubscribe();\n            context.buffer = null;\n            context.subscription = null;\n        }\n        this.contexts = null;\n        _super.prototype._error.call(this, err);\n    };\n    BufferToggleSubscriber.prototype._complete = function () {\n        var contexts = this.contexts;\n        while (contexts.length > 0) {\n            var context = contexts.shift();\n            this.destination.next(context.buffer);\n            context.subscription.unsubscribe();\n            context.buffer = null;\n            context.subscription = null;\n        }\n        this.contexts = null;\n        _super.prototype._complete.call(this);\n    };\n    BufferToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        outerValue ? this.closeBuffer(outerValue) : this.openBuffer(innerValue);\n    };\n    BufferToggleSubscriber.prototype.notifyComplete = function (innerSub) {\n        this.closeBuffer(innerSub.context);\n    };\n    BufferToggleSubscriber.prototype.openBuffer = function (value) {\n        try {\n            var closingSelector = this.closingSelector;\n            var closingNotifier = closingSelector.call(this, value);\n            if (closingNotifier) {\n                this.trySubscribe(closingNotifier);\n            }\n        }\n        catch (err) {\n            this._error(err);\n        }\n    };\n    BufferToggleSubscriber.prototype.closeBuffer = function (context) {\n        var contexts = this.contexts;\n        if (contexts && context) {\n            var buffer = context.buffer, subscription = context.subscription;\n            this.destination.next(buffer);\n            contexts.splice(contexts.indexOf(context), 1);\n            this.remove(subscription);\n            subscription.unsubscribe();\n        }\n    };\n    BufferToggleSubscriber.prototype.trySubscribe = function (closingNotifier) {\n        var contexts = this.contexts;\n        var buffer = [];\n        var subscription = new Subscription_1.Subscription();\n        var context = { buffer: buffer, subscription: subscription };\n        contexts.push(context);\n        var innerSubscription = subscribeToResult_1.subscribeToResult(this, closingNotifier, context);\n        if (!innerSubscription || innerSubscription.closed) {\n            this.closeBuffer(context);\n        }\n        else {\n            innerSubscription.context = context;\n            this.add(innerSubscription);\n            subscription.add(innerSubscription);\n        }\n    };\n    return BufferToggleSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=bufferToggle.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/bufferToggle.js\n ** module id = 152\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/bufferToggle.js?");

/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar bufferWhen_1 = __webpack_require__(154);\nObservable_1.Observable.prototype.bufferWhen = bufferWhen_1.bufferWhen;\n//# sourceMappingURL=bufferWhen.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/bufferWhen.js\n ** module id = 153\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/bufferWhen.js?");

/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscription_1 = __webpack_require__(10);\nvar tryCatch_1 = __webpack_require__(13);\nvar errorObject_1 = __webpack_require__(14);\nvar OuterSubscriber_1 = __webpack_require__(54);\nvar subscribeToResult_1 = __webpack_require__(55);\n/**\n * Buffers the source Observable values, using a factory function of closing\n * Observables to determine when to close, emit, and reset the buffer.\n *\n * <span class=\"informal\">Collects values from the past as an array. When it\n * starts collecting values, it calls a function that returns an Observable that\n * tells when to close the buffer and restart collecting.</span>\n *\n * <img src=\"./img/bufferWhen.png\" width=\"100%\">\n *\n * Opens a buffer immediately, then closes the buffer when the observable\n * returned by calling `closingSelector` function emits a value. When it closes\n * the buffer, it immediately opens a new buffer and repeats the process.\n *\n * @example <caption>Emit an array of the last clicks every [1-5] random seconds</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferWhen(() =>\n *   Rx.Observable.interval(1000 + Math.random() * 4000)\n * );\n * buffered.subscribe(x => console.log(x));\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n * @see {@link bufferTime}\n * @see {@link bufferToggle}\n * @see {@link windowWhen}\n *\n * @param {function(): Observable} closingSelector A function that takes no\n * arguments and returns an Observable that signals buffer closure.\n * @return {Observable<T[]>} An observable of arrays of buffered values.\n * @method bufferWhen\n * @owner Observable\n */\nfunction bufferWhen(closingSelector) {\n    return this.lift(new BufferWhenOperator(closingSelector));\n}\nexports.bufferWhen = bufferWhen;\nvar BufferWhenOperator = (function () {\n    function BufferWhenOperator(closingSelector) {\n        this.closingSelector = closingSelector;\n    }\n    BufferWhenOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new BufferWhenSubscriber(subscriber, this.closingSelector));\n    };\n    return BufferWhenOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar BufferWhenSubscriber = (function (_super) {\n    __extends(BufferWhenSubscriber, _super);\n    function BufferWhenSubscriber(destination, closingSelector) {\n        _super.call(this, destination);\n        this.closingSelector = closingSelector;\n        this.subscribing = false;\n        this.openBuffer();\n    }\n    BufferWhenSubscriber.prototype._next = function (value) {\n        this.buffer.push(value);\n    };\n    BufferWhenSubscriber.prototype._complete = function () {\n        var buffer = this.buffer;\n        if (buffer) {\n            this.destination.next(buffer);\n        }\n        _super.prototype._complete.call(this);\n    };\n    BufferWhenSubscriber.prototype._unsubscribe = function () {\n        this.buffer = null;\n        this.subscribing = false;\n    };\n    BufferWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.openBuffer();\n    };\n    BufferWhenSubscriber.prototype.notifyComplete = function () {\n        if (this.subscribing) {\n            this.complete();\n        }\n        else {\n            this.openBuffer();\n        }\n    };\n    BufferWhenSubscriber.prototype.openBuffer = function () {\n        var closingSubscription = this.closingSubscription;\n        if (closingSubscription) {\n            this.remove(closingSubscription);\n            closingSubscription.unsubscribe();\n        }\n        var buffer = this.buffer;\n        if (this.buffer) {\n            this.destination.next(buffer);\n        }\n        this.buffer = [];\n        var closingNotifier = tryCatch_1.tryCatch(this.closingSelector)();\n        if (closingNotifier === errorObject_1.errorObject) {\n            this.error(errorObject_1.errorObject.e);\n        }\n        else {\n            closingSubscription = new Subscription_1.Subscription();\n            this.closingSubscription = closingSubscription;\n            this.add(closingSubscription);\n            this.subscribing = true;\n            closingSubscription.add(subscribeToResult_1.subscribeToResult(this, closingNotifier));\n            this.subscribing = false;\n        }\n    };\n    return BufferWhenSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=bufferWhen.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/bufferWhen.js\n ** module id = 154\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/bufferWhen.js?");

/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar cache_1 = __webpack_require__(156);\nObservable_1.Observable.prototype.cache = cache_1.cache;\n//# sourceMappingURL=cache.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/cache.js\n ** module id = 155\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/cache.js?");

/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar ReplaySubject_1 = __webpack_require__(140);\n/**\n * @param bufferSize\n * @param windowTime\n * @param scheduler\n * @return {Observable<any>}\n * @method cache\n * @owner Observable\n */\nfunction cache(bufferSize, windowTime, scheduler) {\n    if (bufferSize === void 0) { bufferSize = Number.POSITIVE_INFINITY; }\n    if (windowTime === void 0) { windowTime = Number.POSITIVE_INFINITY; }\n    var subject;\n    var source = this;\n    var refs = 0;\n    var outerSub;\n    var getSubject = function () {\n        subject = new ReplaySubject_1.ReplaySubject(bufferSize, windowTime, scheduler);\n        return subject;\n    };\n    return new Observable_1.Observable(function (observer) {\n        if (!subject) {\n            subject = getSubject();\n            outerSub = source.subscribe(function (value) { return subject.next(value); }, function (err) {\n                var s = subject;\n                subject = null;\n                s.error(err);\n            }, function () { return subject.complete(); });\n        }\n        refs++;\n        if (!subject) {\n            subject = getSubject();\n        }\n        var innerSub = subject.subscribe(observer);\n        return function () {\n            refs--;\n            if (innerSub) {\n                innerSub.unsubscribe();\n            }\n            if (refs === 0) {\n                outerSub.unsubscribe();\n            }\n        };\n    });\n}\nexports.cache = cache;\n//# sourceMappingURL=cache.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/cache.js\n ** module id = 156\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/cache.js?");

/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar catch_1 = __webpack_require__(158);\nObservable_1.Observable.prototype.catch = catch_1._catch;\nObservable_1.Observable.prototype._catch = catch_1._catch;\n//# sourceMappingURL=catch.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/catch.js\n ** module id = 157\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/catch.js?");

/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = __webpack_require__(54);\nvar subscribeToResult_1 = __webpack_require__(55);\n/**\n * Catches errors on the observable to be handled by returning a new observable or throwing an error.\n * @param {function} selector a function that takes as arguments `err`, which is the error, and `caught`, which\n *  is the source observable, in case you'd like to \"retry\" that observable by returning it again. Whatever observable\n *  is returned by the `selector` will be used to continue the observable chain.\n * @return {Observable} an observable that originates from either the source or the observable returned by the\n *  catch `selector` function.\n * @method catch\n * @owner Observable\n */\nfunction _catch(selector) {\n    var operator = new CatchOperator(selector);\n    var caught = this.lift(operator);\n    return (operator.caught = caught);\n}\nexports._catch = _catch;\nvar CatchOperator = (function () {\n    function CatchOperator(selector) {\n        this.selector = selector;\n    }\n    CatchOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));\n    };\n    return CatchOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar CatchSubscriber = (function (_super) {\n    __extends(CatchSubscriber, _super);\n    function CatchSubscriber(destination, selector, caught) {\n        _super.call(this, destination);\n        this.selector = selector;\n        this.caught = caught;\n    }\n    // NOTE: overriding `error` instead of `_error` because we don't want\n    // to have this flag this subscriber as `isStopped`.\n    CatchSubscriber.prototype.error = function (err) {\n        if (!this.isStopped) {\n            var result = void 0;\n            try {\n                result = this.selector(err, this.caught);\n            }\n            catch (err) {\n                this.destination.error(err);\n                return;\n            }\n            this.unsubscribe();\n            this.destination.remove(this);\n            subscribeToResult_1.subscribeToResult(this, result);\n        }\n    };\n    return CatchSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=catch.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/catch.js\n ** module id = 158\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/catch.js?");

/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar combineAll_1 = __webpack_require__(160);\nObservable_1.Observable.prototype.combineAll = combineAll_1.combineAll;\n//# sourceMappingURL=combineAll.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/combineAll.js\n ** module id = 159\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/combineAll.js?");

/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar combineLatest_1 = __webpack_require__(53);\n/**\n * Converts a higher-order Observable into a first-order Observable by waiting\n * for the outer Observable to complete, then applying {@link combineLatest}.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables by applying\n * {@link combineLatest} when the Observable-of-Observables completes.</span>\n *\n * <img src=\"./img/combineAll.png\" width=\"100%\">\n *\n * Takes an Observable of Observables, and collects all Observables from it.\n * Once the outer Observable completes, it subscribes to all collected\n * Observables and combines their values using the {@link combineLatest}\n * strategy, such that:\n * - Every time an inner Observable emits, the output Observable emits.\n * - When the returned observable emits, it emits all of the latest values by:\n *   - If a `project` function is provided, it is called with each recent value\n *     from each inner Observable in whatever order they arrived, and the result\n *     of the `project` function is what is emitted by the output Observable.\n *   - If there is no `project` function, an array of all of the most recent\n *     values is emitted by the output Observable.\n *\n * @example <caption>Map two click events to a finite interval Observable, then apply combineAll</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var higherOrder = clicks.map(ev =>\n *   Rx.Observable.interval(Math.random()*2000).take(3)\n * ).take(2);\n * var result = higherOrder.combineAll();\n * result.subscribe(x => console.log(x));\n *\n * @see {@link combineLatest}\n * @see {@link mergeAll}\n *\n * @param {function} [project] An optional function to map the most recent\n * values from each inner Observable into a new result. Takes each of the most\n * recent values from each collected inner Observable as arguments, in order.\n * @return {Observable} An Observable of projected results or arrays of recent\n * values.\n * @method combineAll\n * @owner Observable\n */\nfunction combineAll(project) {\n    return this.lift(new combineLatest_1.CombineLatestOperator(project));\n}\nexports.combineAll = combineAll;\n//# sourceMappingURL=combineAll.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/combineAll.js\n ** module id = 160\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/combineAll.js?");

/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar combineLatest_1 = __webpack_require__(53);\nObservable_1.Observable.prototype.combineLatest = combineLatest_1.combineLatest;\n//# sourceMappingURL=combineLatest.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/combineLatest.js\n ** module id = 161\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/combineLatest.js?");

/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar concat_1 = __webpack_require__(61);\nObservable_1.Observable.prototype.concat = concat_1.concat;\n//# sourceMappingURL=concat.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/concat.js\n ** module id = 162\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/concat.js?");

/***/ },
/* 163 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar concatAll_1 = __webpack_require__(164);\nObservable_1.Observable.prototype.concatAll = concatAll_1.concatAll;\n//# sourceMappingURL=concatAll.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/concatAll.js\n ** module id = 163\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/concatAll.js?");

/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar mergeAll_1 = __webpack_require__(62);\n/**\n * Converts a higher-order Observable into a first-order Observable by\n * concatenating the inner Observables in order.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables by putting one\n * inner Observable after the other.</span>\n *\n * <img src=\"./img/concatAll.png\" width=\"100%\">\n *\n * Joins every Observable emitted by the source (a higher-order Observable), in\n * a serial fashion. It subscribes to each inner Observable only after the\n * previous inner Observable has completed, and merges all of their values into\n * the returned observable.\n *\n * __Warning:__ If the source Observable emits Observables quickly and\n * endlessly, and the inner Observables it emits generally complete slower than\n * the source emits, you can run into memory issues as the incoming Observables\n * collect in an unbounded buffer.\n *\n * Note: `concatAll` is equivalent to `mergeAll` with concurrency parameter set\n * to `1`.\n *\n * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var higherOrder = clicks.map(ev => Rx.Observable.interval(1000).take(4));\n * var firstOrder = higherOrder.concatAll();\n * firstOrder.subscribe(x => console.log(x));\n *\n * @see {@link combineAll}\n * @see {@link concat}\n * @see {@link concatMap}\n * @see {@link concatMapTo}\n * @see {@link exhaust}\n * @see {@link mergeAll}\n * @see {@link switch}\n * @see {@link zipAll}\n *\n * @return {Observable} An Observable emitting values from all the inner\n * Observables concatenated.\n * @method concatAll\n * @owner Observable\n */\nfunction concatAll() {\n    return this.lift(new mergeAll_1.MergeAllOperator(1));\n}\nexports.concatAll = concatAll;\n//# sourceMappingURL=concatAll.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/concatAll.js\n ** module id = 164\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/concatAll.js?");

/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar concatMap_1 = __webpack_require__(166);\nObservable_1.Observable.prototype.concatMap = concatMap_1.concatMap;\n//# sourceMappingURL=concatMap.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/concatMap.js\n ** module id = 165\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/concatMap.js?");

/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar mergeMap_1 = __webpack_require__(167);\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable, in a serialized fashion waiting for each one to complete before\n * merging the next.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link concatAll}.</span>\n *\n * <img src=\"./img/concatMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. Each new inner Observable is\n * concatenated with the previous inner Observable.\n *\n * __Warning:__ if source values arrive endlessly and faster than their\n * corresponding inner Observables can complete, it will result in memory issues\n * as inner Observables amass in an unbounded buffer waiting for their turn to\n * be subscribed to.\n *\n * Note: `concatMap` is equivalent to `mergeMap` with concurrency parameter set\n * to `1`.\n *\n * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.concatMap(ev => Rx.Observable.interval(1000).take(4));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concat}\n * @see {@link concatAll}\n * @see {@link concatMapTo}\n * @see {@link exhaustMap}\n * @see {@link mergeMap}\n * @see {@link switchMap}\n *\n * @param {function(value: T, ?index: number): Observable} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} an observable of values merged from the projected\n * Observables as they were subscribed to, one at a time. Optionally, these\n * values may have been projected from a passed `projectResult` argument.\n * @return {Observable} An Observable that emits the result of applying the\n * projection function (and the optional `resultSelector`) to each item emitted\n * by the source Observable and taking values from each projected inner\n * Observable sequentially.\n * @method concatMap\n * @owner Observable\n */\nfunction concatMap(project, resultSelector) {\n    return this.lift(new mergeMap_1.MergeMapOperator(project, resultSelector, 1));\n}\nexports.concatMap = concatMap;\n//# sourceMappingURL=concatMap.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/concatMap.js\n ** module id = 166\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/concatMap.js?");

/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar subscribeToResult_1 = __webpack_require__(55);\nvar OuterSubscriber_1 = __webpack_require__(54);\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link mergeAll}.</span>\n *\n * <img src=\"./img/mergeMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an Observable, and then merging those resulting Observables and\n * emitting the results of this merger.\n *\n * @example <caption>Map and flatten each letter to an Observable ticking every 1 second</caption>\n * var letters = Rx.Observable.of('a', 'b', 'c');\n * var result = letters.mergeMap(x =>\n *   Rx.Observable.interval(1000).map(i => x+i)\n * );\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatMap}\n * @see {@link exhaustMap}\n * @see {@link merge}\n * @see {@link mergeAll}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n * @see {@link switchMap}\n *\n * @param {function(value: T, ?index: number): Observable} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @return {Observable} An Observable that emits the result of applying the\n * projection function (and the optional `resultSelector`) to each item emitted\n * by the source Observable and merging the results of the Observables obtained\n * from this transformation.\n * @method mergeMap\n * @owner Observable\n */\nfunction mergeMap(project, resultSelector, concurrent) {\n    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n    if (typeof resultSelector === 'number') {\n        concurrent = resultSelector;\n        resultSelector = null;\n    }\n    return this.lift(new MergeMapOperator(project, resultSelector, concurrent));\n}\nexports.mergeMap = mergeMap;\nvar MergeMapOperator = (function () {\n    function MergeMapOperator(project, resultSelector, concurrent) {\n        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n        this.project = project;\n        this.resultSelector = resultSelector;\n        this.concurrent = concurrent;\n    }\n    MergeMapOperator.prototype.call = function (observer, source) {\n        return source._subscribe(new MergeMapSubscriber(observer, this.project, this.resultSelector, this.concurrent));\n    };\n    return MergeMapOperator;\n}());\nexports.MergeMapOperator = MergeMapOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar MergeMapSubscriber = (function (_super) {\n    __extends(MergeMapSubscriber, _super);\n    function MergeMapSubscriber(destination, project, resultSelector, concurrent) {\n        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n        _super.call(this, destination);\n        this.project = project;\n        this.resultSelector = resultSelector;\n        this.concurrent = concurrent;\n        this.hasCompleted = false;\n        this.buffer = [];\n        this.active = 0;\n        this.index = 0;\n    }\n    MergeMapSubscriber.prototype._next = function (value) {\n        if (this.active < this.concurrent) {\n            this._tryNext(value);\n        }\n        else {\n            this.buffer.push(value);\n        }\n    };\n    MergeMapSubscriber.prototype._tryNext = function (value) {\n        var result;\n        var index = this.index++;\n        try {\n            result = this.project(value, index);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.active++;\n        this._innerSub(result, value, index);\n    };\n    MergeMapSubscriber.prototype._innerSub = function (ish, value, index) {\n        this.add(subscribeToResult_1.subscribeToResult(this, ish, value, index));\n    };\n    MergeMapSubscriber.prototype._complete = function () {\n        this.hasCompleted = true;\n        if (this.active === 0 && this.buffer.length === 0) {\n            this.destination.complete();\n        }\n    };\n    MergeMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        if (this.resultSelector) {\n            this._notifyResultSelector(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        else {\n            this.destination.next(innerValue);\n        }\n    };\n    MergeMapSubscriber.prototype._notifyResultSelector = function (outerValue, innerValue, outerIndex, innerIndex) {\n        var result;\n        try {\n            result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.destination.next(result);\n    };\n    MergeMapSubscriber.prototype.notifyComplete = function (innerSub) {\n        var buffer = this.buffer;\n        this.remove(innerSub);\n        this.active--;\n        if (buffer.length > 0) {\n            this._next(buffer.shift());\n        }\n        else if (this.active === 0 && this.hasCompleted) {\n            this.destination.complete();\n        }\n    };\n    return MergeMapSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\nexports.MergeMapSubscriber = MergeMapSubscriber;\n//# sourceMappingURL=mergeMap.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/mergeMap.js\n ** module id = 167\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/mergeMap.js?");

/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar concatMapTo_1 = __webpack_require__(169);\nObservable_1.Observable.prototype.concatMapTo = concatMapTo_1.concatMapTo;\n//# sourceMappingURL=concatMapTo.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/concatMapTo.js\n ** module id = 168\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/concatMapTo.js?");

/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar mergeMapTo_1 = __webpack_require__(170);\n/**\n * Projects each source value to the same Observable which is merged multiple\n * times in a serialized fashion on the output Observable.\n *\n * <span class=\"informal\">It's like {@link concatMap}, but maps each value\n * always to the same inner Observable.</span>\n *\n * <img src=\"./img/concatMapTo.png\" width=\"100%\">\n *\n * Maps each source value to the given Observable `innerObservable` regardless\n * of the source value, and then flattens those resulting Observables into one\n * single Observable, which is the output Observable. Each new `innerObservable`\n * instance emitted on the output Observable is concatenated with the previous\n * `innerObservable` instance.\n *\n * __Warning:__ if source values arrive endlessly and faster than their\n * corresponding inner Observables can complete, it will result in memory issues\n * as inner Observables amass in an unbounded buffer waiting for their turn to\n * be subscribed to.\n *\n * Note: `concatMapTo` is equivalent to `mergeMapTo` with concurrency parameter\n * set to `1`.\n *\n * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.concatMapTo(Rx.Observable.interval(1000).take(4));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concat}\n * @see {@link concatAll}\n * @see {@link concatMap}\n * @see {@link mergeMapTo}\n * @see {@link switchMapTo}\n *\n * @param {Observable} innerObservable An Observable to replace each value from\n * the source Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} An observable of values merged together by joining the\n * passed observable with itself, one after the other, for each value emitted\n * from the source.\n * @method concatMapTo\n * @owner Observable\n */\nfunction concatMapTo(innerObservable, resultSelector) {\n    return this.lift(new mergeMapTo_1.MergeMapToOperator(innerObservable, resultSelector, 1));\n}\nexports.concatMapTo = concatMapTo;\n//# sourceMappingURL=concatMapTo.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/concatMapTo.js\n ** module id = 169\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/concatMapTo.js?");

/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = __webpack_require__(54);\nvar subscribeToResult_1 = __webpack_require__(55);\n/**\n * Projects each source value to the same Observable which is merged multiple\n * times in the output Observable.\n *\n * <span class=\"informal\">It's like {@link mergeMap}, but maps each value always\n * to the same inner Observable.</span>\n *\n * <img src=\"./img/mergeMapTo.png\" width=\"100%\">\n *\n * Maps each source value to the given Observable `innerObservable` regardless\n * of the source value, and then merges those resulting Observables into one\n * single Observable, which is the output Observable.\n *\n * @example <caption>For each click event, start an interval Observable ticking every 1 second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.mergeMapTo(Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatMapTo}\n * @see {@link merge}\n * @see {@link mergeAll}\n * @see {@link mergeMap}\n * @see {@link mergeScan}\n * @see {@link switchMapTo}\n *\n * @param {Observable} innerObservable An Observable to replace each value from\n * the source Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @return {Observable} An Observable that emits items from the given\n * `innerObservable` (and optionally transformed through `resultSelector`) every\n * time a value is emitted on the source Observable.\n * @method mergeMapTo\n * @owner Observable\n */\nfunction mergeMapTo(innerObservable, resultSelector, concurrent) {\n    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n    if (typeof resultSelector === 'number') {\n        concurrent = resultSelector;\n        resultSelector = null;\n    }\n    return this.lift(new MergeMapToOperator(innerObservable, resultSelector, concurrent));\n}\nexports.mergeMapTo = mergeMapTo;\n// TODO: Figure out correct signature here: an Operator<Observable<T>, R>\n//       needs to implement call(observer: Subscriber<R>): Subscriber<Observable<T>>\nvar MergeMapToOperator = (function () {\n    function MergeMapToOperator(ish, resultSelector, concurrent) {\n        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n        this.ish = ish;\n        this.resultSelector = resultSelector;\n        this.concurrent = concurrent;\n    }\n    MergeMapToOperator.prototype.call = function (observer, source) {\n        return source._subscribe(new MergeMapToSubscriber(observer, this.ish, this.resultSelector, this.concurrent));\n    };\n    return MergeMapToOperator;\n}());\nexports.MergeMapToOperator = MergeMapToOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar MergeMapToSubscriber = (function (_super) {\n    __extends(MergeMapToSubscriber, _super);\n    function MergeMapToSubscriber(destination, ish, resultSelector, concurrent) {\n        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n        _super.call(this, destination);\n        this.ish = ish;\n        this.resultSelector = resultSelector;\n        this.concurrent = concurrent;\n        this.hasCompleted = false;\n        this.buffer = [];\n        this.active = 0;\n        this.index = 0;\n    }\n    MergeMapToSubscriber.prototype._next = function (value) {\n        if (this.active < this.concurrent) {\n            var resultSelector = this.resultSelector;\n            var index = this.index++;\n            var ish = this.ish;\n            var destination = this.destination;\n            this.active++;\n            this._innerSub(ish, destination, resultSelector, value, index);\n        }\n        else {\n            this.buffer.push(value);\n        }\n    };\n    MergeMapToSubscriber.prototype._innerSub = function (ish, destination, resultSelector, value, index) {\n        this.add(subscribeToResult_1.subscribeToResult(this, ish, value, index));\n    };\n    MergeMapToSubscriber.prototype._complete = function () {\n        this.hasCompleted = true;\n        if (this.active === 0 && this.buffer.length === 0) {\n            this.destination.complete();\n        }\n    };\n    MergeMapToSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;\n        if (resultSelector) {\n            this.trySelectResult(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        else {\n            destination.next(innerValue);\n        }\n    };\n    MergeMapToSubscriber.prototype.trySelectResult = function (outerValue, innerValue, outerIndex, innerIndex) {\n        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;\n        var result;\n        try {\n            result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        catch (err) {\n            destination.error(err);\n            return;\n        }\n        destination.next(result);\n    };\n    MergeMapToSubscriber.prototype.notifyError = function (err) {\n        this.destination.error(err);\n    };\n    MergeMapToSubscriber.prototype.notifyComplete = function (innerSub) {\n        var buffer = this.buffer;\n        this.remove(innerSub);\n        this.active--;\n        if (buffer.length > 0) {\n            this._next(buffer.shift());\n        }\n        else if (this.active === 0 && this.hasCompleted) {\n            this.destination.complete();\n        }\n    };\n    return MergeMapToSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\nexports.MergeMapToSubscriber = MergeMapToSubscriber;\n//# sourceMappingURL=mergeMapTo.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/mergeMapTo.js\n ** module id = 170\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/mergeMapTo.js?");

/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar count_1 = __webpack_require__(172);\nObservable_1.Observable.prototype.count = count_1.count;\n//# sourceMappingURL=count.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/count.js\n ** module id = 171\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/count.js?");

/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(8);\n/**\n * Counts the number of emissions on the source and emits that number when the\n * source completes.\n *\n * <span class=\"informal\">Tells how many values were emitted, when the source\n * completes.</span>\n *\n * <img src=\"./img/count.png\" width=\"100%\">\n *\n * `count` transforms an Observable that emits values into an Observable that\n * emits a single value that represents the number of values emitted by the\n * source Observable. If the source Observable terminates with an error, `count`\n * will pass this error notification along without emitting an value first. If\n * the source Observable does not terminate at all, `count` will neither emit\n * a value nor terminate. This operator takes an optional `predicate` function\n * as argument, in which case the output emission will represent the number of\n * source values that matched `true` with the `predicate`.\n *\n * @example <caption>Counts how many seconds have passed before the first click happened</caption>\n * var seconds = Rx.Observable.interval(1000);\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var secondsBeforeClick = seconds.takeUntil(clicks);\n * var result = secondsBeforeClick.count();\n * result.subscribe(x => console.log(x));\n *\n * @example <caption>Counts how many odd numbers are there between 1 and 7</caption>\n * var numbers = Rx.Observable.range(1, 7);\n * var result = numbers.count(i => i % 2 === 1);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link max}\n * @see {@link min}\n * @see {@link reduce}\n *\n * @param {function(value: T, i: number, source: Observable<T>): boolean} [predicate] A\n * boolean function to select what values are to be counted. It is provided with\n * arguments of:\n * - `value`: the value from the source Observable.\n * - `index`: the (zero-based) \"index\" of the value from the source Observable.\n * - `source`: the source Observable instance itself.\n * @return {Observable} An Observable of one number that represents the count as\n * described above.\n * @method count\n * @owner Observable\n */\nfunction count(predicate) {\n    return this.lift(new CountOperator(predicate, this));\n}\nexports.count = count;\nvar CountOperator = (function () {\n    function CountOperator(predicate, source) {\n        this.predicate = predicate;\n        this.source = source;\n    }\n    CountOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new CountSubscriber(subscriber, this.predicate, this.source));\n    };\n    return CountOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar CountSubscriber = (function (_super) {\n    __extends(CountSubscriber, _super);\n    function CountSubscriber(destination, predicate, source) {\n        _super.call(this, destination);\n        this.predicate = predicate;\n        this.source = source;\n        this.count = 0;\n        this.index = 0;\n    }\n    CountSubscriber.prototype._next = function (value) {\n        if (this.predicate) {\n            this._tryPredicate(value);\n        }\n        else {\n            this.count++;\n        }\n    };\n    CountSubscriber.prototype._tryPredicate = function (value) {\n        var result;\n        try {\n            result = this.predicate(value, this.index++, this.source);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        if (result) {\n            this.count++;\n        }\n    };\n    CountSubscriber.prototype._complete = function () {\n        this.destination.next(this.count);\n        this.destination.complete();\n    };\n    return CountSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=count.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/count.js\n ** module id = 172\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/count.js?");

/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar dematerialize_1 = __webpack_require__(174);\nObservable_1.Observable.prototype.dematerialize = dematerialize_1.dematerialize;\n//# sourceMappingURL=dematerialize.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/dematerialize.js\n ** module id = 173\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/dematerialize.js?");

/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(8);\n/**\n * Converts an Observable of {@link Notification} objects into the emissions\n * that they represent.\n *\n * <span class=\"informal\">Unwraps {@link Notification} objects as actual `next`,\n * `error` and `complete` emissions. The opposite of {@link materialize}.</span>\n *\n * <img src=\"./img/dematerialize.png\" width=\"100%\">\n *\n * `dematerialize` is assumed to operate an Observable that only emits\n * {@link Notification} objects as `next` emissions, and does not emit any\n * `error`. Such Observable is the output of a `materialize` operation. Those\n * notifications are then unwrapped using the metadata they contain, and emitted\n * as `next`, `error`, and `complete` on the output Observable.\n *\n * Use this operator in conjunction with {@link materialize}.\n *\n * @example <caption>Convert an Observable of Notifications to an actual Observable</caption>\n * var notifA = new Rx.Notification('N', 'A');\n * var notifB = new Rx.Notification('N', 'B');\n * var notifE = new Rx.Notification('E', void 0,\n *   new TypeError('x.toUpperCase is not a function')\n * );\n * var materialized = Rx.Observable.of(notifA, notifB, notifE);\n * var upperCase = materialized.dematerialize();\n * upperCase.subscribe(x => console.log(x), e => console.error(e));\n *\n * @see {@link Notification}\n * @see {@link materialize}\n *\n * @return {Observable} An Observable that emits items and notifications\n * embedded in Notification objects emitted by the source Observable.\n * @method dematerialize\n * @owner Observable\n */\nfunction dematerialize() {\n    return this.lift(new DeMaterializeOperator());\n}\nexports.dematerialize = dematerialize;\nvar DeMaterializeOperator = (function () {\n    function DeMaterializeOperator() {\n    }\n    DeMaterializeOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new DeMaterializeSubscriber(subscriber));\n    };\n    return DeMaterializeOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DeMaterializeSubscriber = (function (_super) {\n    __extends(DeMaterializeSubscriber, _super);\n    function DeMaterializeSubscriber(destination) {\n        _super.call(this, destination);\n    }\n    DeMaterializeSubscriber.prototype._next = function (value) {\n        value.observe(this.destination);\n    };\n    return DeMaterializeSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=dematerialize.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/dematerialize.js\n ** module id = 174\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/dematerialize.js?");

/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar debounce_1 = __webpack_require__(176);\nObservable_1.Observable.prototype.debounce = debounce_1.debounce;\n//# sourceMappingURL=debounce.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/debounce.js\n ** module id = 175\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/debounce.js?");

/***/ },
/* 176 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = __webpack_require__(54);\nvar subscribeToResult_1 = __webpack_require__(55);\n/**\n * Emits a value from the source Observable only after a particular time span\n * determined by another Observable has passed without another source emission.\n *\n * <span class=\"informal\">It's like {@link debounceTime}, but the time span of\n * emission silence is determined by a second Observable.</span>\n *\n * <img src=\"./img/debounce.png\" width=\"100%\">\n *\n * `debounce` delays values emitted by the source Observable, but drops previous\n * pending delayed emissions if a new value arrives on the source Observable.\n * This operator keeps track of the most recent value from the source\n * Observable, and spawns a duration Observable by calling the\n * `durationSelector` function. The value is emitted only when the duration\n * Observable emits a value or completes, and if no other value was emitted on\n * the source Observable since the duration Observable was spawned. If a new\n * value appears before the duration Observable emits, the previous value will\n * be dropped and will not be emitted on the output Observable.\n *\n * Like {@link debounceTime}, this is a rate-limiting operator, and also a\n * delay-like operator since output emissions do not necessarily occur at the\n * same time as they did on the source Observable.\n *\n * @example <caption>Emit the most recent click after a burst of clicks</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.debounce(() => Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link audit}\n * @see {@link debounceTime}\n * @see {@link delayWhen}\n * @see {@link throttle}\n *\n * @param {function(value: T): Observable|Promise} durationSelector A function\n * that receives a value from the source Observable, for computing the timeout\n * duration for each source value, returned as an Observable or a Promise.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by the specified duration Observable returned by\n * `durationSelector`, and may drop some values if they occur too frequently.\n * @method debounce\n * @owner Observable\n */\nfunction debounce(durationSelector) {\n    return this.lift(new DebounceOperator(durationSelector));\n}\nexports.debounce = debounce;\nvar DebounceOperator = (function () {\n    function DebounceOperator(durationSelector) {\n        this.durationSelector = durationSelector;\n    }\n    DebounceOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new DebounceSubscriber(subscriber, this.durationSelector));\n    };\n    return DebounceOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DebounceSubscriber = (function (_super) {\n    __extends(DebounceSubscriber, _super);\n    function DebounceSubscriber(destination, durationSelector) {\n        _super.call(this, destination);\n        this.durationSelector = durationSelector;\n        this.hasValue = false;\n        this.durationSubscription = null;\n    }\n    DebounceSubscriber.prototype._next = function (value) {\n        try {\n            var result = this.durationSelector.call(this, value);\n            if (result) {\n                this._tryNext(value, result);\n            }\n        }\n        catch (err) {\n            this.destination.error(err);\n        }\n    };\n    DebounceSubscriber.prototype._complete = function () {\n        this.emitValue();\n        this.destination.complete();\n    };\n    DebounceSubscriber.prototype._tryNext = function (value, duration) {\n        var subscription = this.durationSubscription;\n        this.value = value;\n        this.hasValue = true;\n        if (subscription) {\n            subscription.unsubscribe();\n            this.remove(subscription);\n        }\n        subscription = subscribeToResult_1.subscribeToResult(this, duration);\n        if (!subscription.closed) {\n            this.add(this.durationSubscription = subscription);\n        }\n    };\n    DebounceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.emitValue();\n    };\n    DebounceSubscriber.prototype.notifyComplete = function () {\n        this.emitValue();\n    };\n    DebounceSubscriber.prototype.emitValue = function () {\n        if (this.hasValue) {\n            var value = this.value;\n            var subscription = this.durationSubscription;\n            if (subscription) {\n                this.durationSubscription = null;\n                subscription.unsubscribe();\n                this.remove(subscription);\n            }\n            this.value = null;\n            this.hasValue = false;\n            _super.prototype._next.call(this, value);\n        }\n    };\n    return DebounceSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=debounce.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/debounce.js\n ** module id = 176\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/debounce.js?");

/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar debounceTime_1 = __webpack_require__(178);\nObservable_1.Observable.prototype.debounceTime = debounceTime_1.debounceTime;\n//# sourceMappingURL=debounceTime.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/debounceTime.js\n ** module id = 177\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/debounceTime.js?");

/***/ },
/* 178 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(8);\nvar async_1 = __webpack_require__(96);\n/**\n * Emits a value from the source Observable only after a particular time span\n * has passed without another source emission.\n *\n * <span class=\"informal\">It's like {@link delay}, but passes only the most\n * recent value from each burst of emissions.</span>\n *\n * <img src=\"./img/debounceTime.png\" width=\"100%\">\n *\n * `debounceTime` delays values emitted by the source Observable, but drops\n * previous pending delayed emissions if a new value arrives on the source\n * Observable. This operator keeps track of the most recent value from the\n * source Observable, and emits that only when `dueTime` enough time has passed\n * without any other value appearing on the source Observable. If a new value\n * appears before `dueTime` silence occurs, the previous value will be dropped\n * and will not be emitted on the output Observable.\n *\n * This is a rate-limiting operator, because it is impossible for more than one\n * value to be emitted in any time window of duration `dueTime`, but it is also\n * a delay-like operator since output emissions do not occur at the same time as\n * they did on the source Observable. Optionally takes a {@link Scheduler} for\n * managing timers.\n *\n * @example <caption>Emit the most recent click after a burst of clicks</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.debounceTime(1000);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link auditTime}\n * @see {@link debounce}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttleTime}\n *\n * @param {number} dueTime The timeout duration in milliseconds (or the time\n * unit determined internally by the optional `scheduler`) for the window of\n * time required to wait for emission silence before emitting the most recent\n * source value.\n * @param {Scheduler} [scheduler=async] The {@link Scheduler} to use for\n * managing the timers that handle the timeout for each value.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by the specified `dueTime`, and may drop some values if they occur\n * too frequently.\n * @method debounceTime\n * @owner Observable\n */\nfunction debounceTime(dueTime, scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    return this.lift(new DebounceTimeOperator(dueTime, scheduler));\n}\nexports.debounceTime = debounceTime;\nvar DebounceTimeOperator = (function () {\n    function DebounceTimeOperator(dueTime, scheduler) {\n        this.dueTime = dueTime;\n        this.scheduler = scheduler;\n    }\n    DebounceTimeOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));\n    };\n    return DebounceTimeOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DebounceTimeSubscriber = (function (_super) {\n    __extends(DebounceTimeSubscriber, _super);\n    function DebounceTimeSubscriber(destination, dueTime, scheduler) {\n        _super.call(this, destination);\n        this.dueTime = dueTime;\n        this.scheduler = scheduler;\n        this.debouncedSubscription = null;\n        this.lastValue = null;\n        this.hasValue = false;\n    }\n    DebounceTimeSubscriber.prototype._next = function (value) {\n        this.clearDebounce();\n        this.lastValue = value;\n        this.hasValue = true;\n        this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));\n    };\n    DebounceTimeSubscriber.prototype._complete = function () {\n        this.debouncedNext();\n        this.destination.complete();\n    };\n    DebounceTimeSubscriber.prototype.debouncedNext = function () {\n        this.clearDebounce();\n        if (this.hasValue) {\n            this.destination.next(this.lastValue);\n            this.lastValue = null;\n            this.hasValue = false;\n        }\n    };\n    DebounceTimeSubscriber.prototype.clearDebounce = function () {\n        var debouncedSubscription = this.debouncedSubscription;\n        if (debouncedSubscription !== null) {\n            this.remove(debouncedSubscription);\n            debouncedSubscription.unsubscribe();\n            this.debouncedSubscription = null;\n        }\n    };\n    return DebounceTimeSubscriber;\n}(Subscriber_1.Subscriber));\nfunction dispatchNext(subscriber) {\n    subscriber.debouncedNext();\n}\n//# sourceMappingURL=debounceTime.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/debounceTime.js\n ** module id = 178\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/debounceTime.js?");

/***/ },
/* 179 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar defaultIfEmpty_1 = __webpack_require__(180);\nObservable_1.Observable.prototype.defaultIfEmpty = defaultIfEmpty_1.defaultIfEmpty;\n//# sourceMappingURL=defaultIfEmpty.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/defaultIfEmpty.js\n ** module id = 179\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/defaultIfEmpty.js?");

/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(8);\n/**\n * Emits a given value if the source Observable completes without emitting any\n * `next` value, otherwise mirrors the source Observable.\n *\n * <span class=\"informal\">If the source Observable turns out to be empty, then\n * this operator will emit a default value.</span>\n *\n * <img src=\"./img/defaultIfEmpty.png\" width=\"100%\">\n *\n * `defaultIfEmpty` emits the values emitted by the source Observable or a\n * specified default value if the source Observable is empty (completes without\n * having emitted any `next` value).\n *\n * @example <caption>If no clicks happen in 5 seconds, then emit \"no clicks\"</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var clicksBeforeFive = clicks.takeUntil(Rx.Observable.interval(5000));\n * var result = clicksBeforeFive.defaultIfEmpty('no clicks');\n * result.subscribe(x => console.log(x));\n *\n * @see {@link empty}\n * @see {@link last}\n *\n * @param {any} [defaultValue=null] The default value used if the source\n * Observable is empty.\n * @return {Observable} An Observable that emits either the specified\n * `defaultValue` if the source Observable emits no items, or the values emitted\n * by the source Observable.\n * @method defaultIfEmpty\n * @owner Observable\n */\nfunction defaultIfEmpty(defaultValue) {\n    if (defaultValue === void 0) { defaultValue = null; }\n    return this.lift(new DefaultIfEmptyOperator(defaultValue));\n}\nexports.defaultIfEmpty = defaultIfEmpty;\nvar DefaultIfEmptyOperator = (function () {\n    function DefaultIfEmptyOperator(defaultValue) {\n        this.defaultValue = defaultValue;\n    }\n    DefaultIfEmptyOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new DefaultIfEmptySubscriber(subscriber, this.defaultValue));\n    };\n    return DefaultIfEmptyOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DefaultIfEmptySubscriber = (function (_super) {\n    __extends(DefaultIfEmptySubscriber, _super);\n    function DefaultIfEmptySubscriber(destination, defaultValue) {\n        _super.call(this, destination);\n        this.defaultValue = defaultValue;\n        this.isEmpty = true;\n    }\n    DefaultIfEmptySubscriber.prototype._next = function (value) {\n        this.isEmpty = false;\n        this.destination.next(value);\n    };\n    DefaultIfEmptySubscriber.prototype._complete = function () {\n        if (this.isEmpty) {\n            this.destination.next(this.defaultValue);\n        }\n        this.destination.complete();\n    };\n    return DefaultIfEmptySubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=defaultIfEmpty.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/defaultIfEmpty.js\n ** module id = 180\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/defaultIfEmpty.js?");

/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar delay_1 = __webpack_require__(182);\nObservable_1.Observable.prototype.delay = delay_1.delay;\n//# sourceMappingURL=delay.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/delay.js\n ** module id = 181\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/delay.js?");

/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar async_1 = __webpack_require__(96);\nvar isDate_1 = __webpack_require__(129);\nvar Subscriber_1 = __webpack_require__(8);\nvar Notification_1 = __webpack_require__(78);\n/**\n * Delays the emission of items from the source Observable by a given timeout or\n * until a given Date.\n *\n * <span class=\"informal\">Time shifts each item by some specified amount of\n * milliseconds.</span>\n *\n * <img src=\"./img/delay.png\" width=\"100%\">\n *\n * If the delay argument is a Number, this operator time shifts the source\n * Observable by that amount of time expressed in milliseconds. The relative\n * time intervals between the values are preserved.\n *\n * If the delay argument is a Date, this operator time shifts the start of the\n * Observable execution until the given date occurs.\n *\n * @example <caption>Delay each click by one second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var delayedClicks = clicks.delay(1000); // each click emitted after 1 second\n * delayedClicks.subscribe(x => console.log(x));\n *\n * @example <caption>Delay all clicks until a future date happens</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var date = new Date('March 15, 2050 12:00:00'); // in the future\n * var delayedClicks = clicks.delay(date); // click emitted only after that date\n * delayedClicks.subscribe(x => console.log(x));\n *\n * @see {@link debounceTime}\n * @see {@link delayWhen}\n *\n * @param {number|Date} delay The delay duration in milliseconds (a `number`) or\n * a `Date` until which the emission of the source items is delayed.\n * @param {Scheduler} [scheduler=async] The Scheduler to use for\n * managing the timers that handle the time-shift for each item.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by the specified timeout or Date.\n * @method delay\n * @owner Observable\n */\nfunction delay(delay, scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    var absoluteDelay = isDate_1.isDate(delay);\n    var delayFor = absoluteDelay ? (+delay - scheduler.now()) : Math.abs(delay);\n    return this.lift(new DelayOperator(delayFor, scheduler));\n}\nexports.delay = delay;\nvar DelayOperator = (function () {\n    function DelayOperator(delay, scheduler) {\n        this.delay = delay;\n        this.scheduler = scheduler;\n    }\n    DelayOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));\n    };\n    return DelayOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DelaySubscriber = (function (_super) {\n    __extends(DelaySubscriber, _super);\n    function DelaySubscriber(destination, delay, scheduler) {\n        _super.call(this, destination);\n        this.delay = delay;\n        this.scheduler = scheduler;\n        this.queue = [];\n        this.active = false;\n        this.errored = false;\n    }\n    DelaySubscriber.dispatch = function (state) {\n        var source = state.source;\n        var queue = source.queue;\n        var scheduler = state.scheduler;\n        var destination = state.destination;\n        while (queue.length > 0 && (queue[0].time - scheduler.now()) <= 0) {\n            queue.shift().notification.observe(destination);\n        }\n        if (queue.length > 0) {\n            var delay_1 = Math.max(0, queue[0].time - scheduler.now());\n            this.schedule(state, delay_1);\n        }\n        else {\n            source.active = false;\n        }\n    };\n    DelaySubscriber.prototype._schedule = function (scheduler) {\n        this.active = true;\n        this.add(scheduler.schedule(DelaySubscriber.dispatch, this.delay, {\n            source: this, destination: this.destination, scheduler: scheduler\n        }));\n    };\n    DelaySubscriber.prototype.scheduleNotification = function (notification) {\n        if (this.errored === true) {\n            return;\n        }\n        var scheduler = this.scheduler;\n        var message = new DelayMessage(scheduler.now() + this.delay, notification);\n        this.queue.push(message);\n        if (this.active === false) {\n            this._schedule(scheduler);\n        }\n    };\n    DelaySubscriber.prototype._next = function (value) {\n        this.scheduleNotification(Notification_1.Notification.createNext(value));\n    };\n    DelaySubscriber.prototype._error = function (err) {\n        this.errored = true;\n        this.queue = [];\n        this.destination.error(err);\n    };\n    DelaySubscriber.prototype._complete = function () {\n        this.scheduleNotification(Notification_1.Notification.createComplete());\n    };\n    return DelaySubscriber;\n}(Subscriber_1.Subscriber));\nvar DelayMessage = (function () {\n    function DelayMessage(time, notification) {\n        this.time = time;\n        this.notification = notification;\n    }\n    return DelayMessage;\n}());\n//# sourceMappingURL=delay.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/delay.js\n ** module id = 182\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/delay.js?");

/***/ },
/* 183 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar delayWhen_1 = __webpack_require__(184);\nObservable_1.Observable.prototype.delayWhen = delayWhen_1.delayWhen;\n//# sourceMappingURL=delayWhen.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/delayWhen.js\n ** module id = 183\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/delayWhen.js?");

/***/ },
/* 184 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(8);\nvar Observable_1 = __webpack_require__(5);\nvar OuterSubscriber_1 = __webpack_require__(54);\nvar subscribeToResult_1 = __webpack_require__(55);\n/**\n * Delays the emission of items from the source Observable by a given time span\n * determined by the emissions of another Observable.\n *\n * <span class=\"informal\">It's like {@link delay}, but the time span of the\n * delay duration is determined by a second Observable.</span>\n *\n * <img src=\"./img/delayWhen.png\" width=\"100%\">\n *\n * `delayWhen` time shifts each emitted value from the source Observable by a\n * time span determined by another Observable. When the source emits a value,\n * the `delayDurationSelector` function is called with the source value as\n * argument, and should return an Observable, called the \"duration\" Observable.\n * The source value is emitted on the output Observable only when the duration\n * Observable emits a value or completes.\n *\n * Optionally, `delayWhen` takes a second argument, `subscriptionDelay`, which\n * is an Observable. When `subscriptionDelay` emits its first value or\n * completes, the source Observable is subscribed to and starts behaving like\n * described in the previous paragraph. If `subscriptionDelay` is not provided,\n * `delayWhen` will subscribe to the source Observable as soon as the output\n * Observable is subscribed.\n *\n * @example <caption>Delay each click by a random amount of time, between 0 and 5 seconds</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var delayedClicks = clicks.delayWhen(event =>\n *   Rx.Observable.interval(Math.random() * 5000)\n * );\n * delayedClicks.subscribe(x => console.log(x));\n *\n * @see {@link debounce}\n * @see {@link delay}\n *\n * @param {function(value: T): Observable} delayDurationSelector A function that\n * returns an Observable for each value emitted by the source Observable, which\n * is then used to delay the emission of that item on the output Observable\n * until the Observable returned from this function emits a value.\n * @param {Observable} subscriptionDelay An Observable that triggers the\n * subscription to the source Observable once it emits any value.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by an amount of time specified by the Observable returned by\n * `delayDurationSelector`.\n * @method delayWhen\n * @owner Observable\n */\nfunction delayWhen(delayDurationSelector, subscriptionDelay) {\n    if (subscriptionDelay) {\n        return new SubscriptionDelayObservable(this, subscriptionDelay)\n            .lift(new DelayWhenOperator(delayDurationSelector));\n    }\n    return this.lift(new DelayWhenOperator(delayDurationSelector));\n}\nexports.delayWhen = delayWhen;\nvar DelayWhenOperator = (function () {\n    function DelayWhenOperator(delayDurationSelector) {\n        this.delayDurationSelector = delayDurationSelector;\n    }\n    DelayWhenOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new DelayWhenSubscriber(subscriber, this.delayDurationSelector));\n    };\n    return DelayWhenOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DelayWhenSubscriber = (function (_super) {\n    __extends(DelayWhenSubscriber, _super);\n    function DelayWhenSubscriber(destination, delayDurationSelector) {\n        _super.call(this, destination);\n        this.delayDurationSelector = delayDurationSelector;\n        this.completed = false;\n        this.delayNotifierSubscriptions = [];\n        this.values = [];\n    }\n    DelayWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.destination.next(outerValue);\n        this.removeSubscription(innerSub);\n        this.tryComplete();\n    };\n    DelayWhenSubscriber.prototype.notifyError = function (error, innerSub) {\n        this._error(error);\n    };\n    DelayWhenSubscriber.prototype.notifyComplete = function (innerSub) {\n        var value = this.removeSubscription(innerSub);\n        if (value) {\n            this.destination.next(value);\n        }\n        this.tryComplete();\n    };\n    DelayWhenSubscriber.prototype._next = function (value) {\n        try {\n            var delayNotifier = this.delayDurationSelector(value);\n            if (delayNotifier) {\n                this.tryDelay(delayNotifier, value);\n            }\n        }\n        catch (err) {\n            this.destination.error(err);\n        }\n    };\n    DelayWhenSubscriber.prototype._complete = function () {\n        this.completed = true;\n        this.tryComplete();\n    };\n    DelayWhenSubscriber.prototype.removeSubscription = function (subscription) {\n        subscription.unsubscribe();\n        var subscriptionIdx = this.delayNotifierSubscriptions.indexOf(subscription);\n        var value = null;\n        if (subscriptionIdx !== -1) {\n            value = this.values[subscriptionIdx];\n            this.delayNotifierSubscriptions.splice(subscriptionIdx, 1);\n            this.values.splice(subscriptionIdx, 1);\n        }\n        return value;\n    };\n    DelayWhenSubscriber.prototype.tryDelay = function (delayNotifier, value) {\n        var notifierSubscription = subscribeToResult_1.subscribeToResult(this, delayNotifier, value);\n        this.add(notifierSubscription);\n        this.delayNotifierSubscriptions.push(notifierSubscription);\n        this.values.push(value);\n    };\n    DelayWhenSubscriber.prototype.tryComplete = function () {\n        if (this.completed && this.delayNotifierSubscriptions.length === 0) {\n            this.destination.complete();\n        }\n    };\n    return DelayWhenSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SubscriptionDelayObservable = (function (_super) {\n    __extends(SubscriptionDelayObservable, _super);\n    function SubscriptionDelayObservable(source, subscriptionDelay) {\n        _super.call(this);\n        this.source = source;\n        this.subscriptionDelay = subscriptionDelay;\n    }\n    SubscriptionDelayObservable.prototype._subscribe = function (subscriber) {\n        this.subscriptionDelay.subscribe(new SubscriptionDelaySubscriber(subscriber, this.source));\n    };\n    return SubscriptionDelayObservable;\n}(Observable_1.Observable));\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SubscriptionDelaySubscriber = (function (_super) {\n    __extends(SubscriptionDelaySubscriber, _super);\n    function SubscriptionDelaySubscriber(parent, source) {\n        _super.call(this);\n        this.parent = parent;\n        this.source = source;\n        this.sourceSubscribed = false;\n    }\n    SubscriptionDelaySubscriber.prototype._next = function (unused) {\n        this.subscribeToSource();\n    };\n    SubscriptionDelaySubscriber.prototype._error = function (err) {\n        this.unsubscribe();\n        this.parent.error(err);\n    };\n    SubscriptionDelaySubscriber.prototype._complete = function () {\n        this.subscribeToSource();\n    };\n    SubscriptionDelaySubscriber.prototype.subscribeToSource = function () {\n        if (!this.sourceSubscribed) {\n            this.sourceSubscribed = true;\n            this.unsubscribe();\n            this.source.subscribe(this.parent);\n        }\n    };\n    return SubscriptionDelaySubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=delayWhen.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/delayWhen.js\n ** module id = 184\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/delayWhen.js?");

/***/ },
/* 185 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar distinct_1 = __webpack_require__(186);\nObservable_1.Observable.prototype.distinct = distinct_1.distinct;\n//# sourceMappingURL=distinct.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/distinct.js\n ** module id = 185\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/distinct.js?");

/***/ },
/* 186 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = __webpack_require__(54);\nvar subscribeToResult_1 = __webpack_require__(55);\n/**\n * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from previous items.\n * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.\n * If a comparator function is not provided, an equality check is used by default.\n * As the internal HashSet of this operator grows larger and larger, care should be taken in the domain of inputs this operator may see.\n * An optional parameter is also provided such that an Observable can be provided to queue the internal HashSet to flush the values it holds.\n * @param {function} [compare] optional comparison function called to test if an item is distinct from previous items in the source.\n * @param {Observable} [flushes] optional Observable for flushing the internal HashSet of the operator.\n * @return {Observable} an Observable that emits items from the source Observable with distinct values.\n * @method distinct\n * @owner Observable\n */\nfunction distinct(compare, flushes) {\n    return this.lift(new DistinctOperator(compare, flushes));\n}\nexports.distinct = distinct;\nvar DistinctOperator = (function () {\n    function DistinctOperator(compare, flushes) {\n        this.compare = compare;\n        this.flushes = flushes;\n    }\n    DistinctOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new DistinctSubscriber(subscriber, this.compare, this.flushes));\n    };\n    return DistinctOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DistinctSubscriber = (function (_super) {\n    __extends(DistinctSubscriber, _super);\n    function DistinctSubscriber(destination, compare, flushes) {\n        _super.call(this, destination);\n        this.values = [];\n        if (typeof compare === 'function') {\n            this.compare = compare;\n        }\n        if (flushes) {\n            this.add(subscribeToResult_1.subscribeToResult(this, flushes));\n        }\n    }\n    DistinctSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.values.length = 0;\n    };\n    DistinctSubscriber.prototype.notifyError = function (error, innerSub) {\n        this._error(error);\n    };\n    DistinctSubscriber.prototype._next = function (value) {\n        var found = false;\n        var values = this.values;\n        var len = values.length;\n        try {\n            for (var i = 0; i < len; i++) {\n                if (this.compare(values[i], value)) {\n                    found = true;\n                    return;\n                }\n            }\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.values.push(value);\n        this.destination.next(value);\n    };\n    DistinctSubscriber.prototype.compare = function (x, y) {\n        return x === y;\n    };\n    return DistinctSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\nexports.DistinctSubscriber = DistinctSubscriber;\n//# sourceMappingURL=distinct.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/distinct.js\n ** module id = 186\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/distinct.js?");

/***/ },
/* 187 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar distinctKey_1 = __webpack_require__(188);\nObservable_1.Observable.prototype.distinctKey = distinctKey_1.distinctKey;\n//# sourceMappingURL=distinctKey.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/distinctKey.js\n ** module id = 187\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/distinctKey.js?");

/***/ },
/* 188 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar distinct_1 = __webpack_require__(186);\n/**\n * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from previous items,\n * using a property accessed by using the key provided to check if the two items are distinct.\n * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.\n * If a comparator function is not provided, an equality check is used by default.\n * As the internal HashSet of this operator grows larger and larger, care should be taken in the domain of inputs this operator may see.\n * An optional parameter is also provided such that an Observable can be provided to queue the internal HashSet to flush the values it holds.\n * @param {string} key string key for object property lookup on each item.\n * @param {function} [compare] optional comparison function called to test if an item is distinct from previous items in the source.\n * @param {Observable} [flushes] optional Observable for flushing the internal HashSet of the operator.\n * @return {Observable} an Observable that emits items from the source Observable with distinct values.\n * @method distinctKey\n * @owner Observable\n */\nfunction distinctKey(key, compare, flushes) {\n    return distinct_1.distinct.call(this, function (x, y) {\n        if (compare) {\n            return compare(x[key], y[key]);\n        }\n        return x[key] === y[key];\n    }, flushes);\n}\nexports.distinctKey = distinctKey;\n//# sourceMappingURL=distinctKey.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/distinctKey.js\n ** module id = 188\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/distinctKey.js?");

/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar distinctUntilChanged_1 = __webpack_require__(190);\nObservable_1.Observable.prototype.distinctUntilChanged = distinctUntilChanged_1.distinctUntilChanged;\n//# sourceMappingURL=distinctUntilChanged.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/distinctUntilChanged.js\n ** module id = 189\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/distinctUntilChanged.js?");

/***/ },
/* 190 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(8);\nvar tryCatch_1 = __webpack_require__(13);\nvar errorObject_1 = __webpack_require__(14);\n/**\n * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item.\n * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.\n * If a comparator function is not provided, an equality check is used by default.\n * @param {function} [compare] optional comparison function called to test if an item is distinct from the previous item in the source.\n * @return {Observable} an Observable that emits items from the source Observable with distinct values.\n * @method distinctUntilChanged\n * @owner Observable\n */\nfunction distinctUntilChanged(compare, keySelector) {\n    return this.lift(new DistinctUntilChangedOperator(compare, keySelector));\n}\nexports.distinctUntilChanged = distinctUntilChanged;\nvar DistinctUntilChangedOperator = (function () {\n    function DistinctUntilChangedOperator(compare, keySelector) {\n        this.compare = compare;\n        this.keySelector = keySelector;\n    }\n    DistinctUntilChangedOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));\n    };\n    return DistinctUntilChangedOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DistinctUntilChangedSubscriber = (function (_super) {\n    __extends(DistinctUntilChangedSubscriber, _super);\n    function DistinctUntilChangedSubscriber(destination, compare, keySelector) {\n        _super.call(this, destination);\n        this.keySelector = keySelector;\n        this.hasKey = false;\n        if (typeof compare === 'function') {\n            this.compare = compare;\n        }\n    }\n    DistinctUntilChangedSubscriber.prototype.compare = function (x, y) {\n        return x === y;\n    };\n    DistinctUntilChangedSubscriber.prototype._next = function (value) {\n        var keySelector = this.keySelector;\n        var key = value;\n        if (keySelector) {\n            key = tryCatch_1.tryCatch(this.keySelector)(value);\n            if (key === errorObject_1.errorObject) {\n                return this.destination.error(errorObject_1.errorObject.e);\n            }\n        }\n        var result = false;\n        if (this.hasKey) {\n            result = tryCatch_1.tryCatch(this.compare)(this.key, key);\n            if (result === errorObject_1.errorObject) {\n                return this.destination.error(errorObject_1.errorObject.e);\n            }\n        }\n        else {\n            this.hasKey = true;\n        }\n        if (Boolean(result) === false) {\n            this.key = key;\n            this.destination.next(value);\n        }\n    };\n    return DistinctUntilChangedSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=distinctUntilChanged.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/distinctUntilChanged.js\n ** module id = 190\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/distinctUntilChanged.js?");

/***/ },
/* 191 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar distinctUntilKeyChanged_1 = __webpack_require__(192);\nObservable_1.Observable.prototype.distinctUntilKeyChanged = distinctUntilKeyChanged_1.distinctUntilKeyChanged;\n//# sourceMappingURL=distinctUntilKeyChanged.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/distinctUntilKeyChanged.js\n ** module id = 191\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/distinctUntilKeyChanged.js?");

/***/ },
/* 192 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar distinctUntilChanged_1 = __webpack_require__(190);\n/**\n * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item,\n * using a property accessed by using the key provided to check if the two items are distinct.\n * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.\n * If a comparator function is not provided, an equality check is used by default.\n * @param {string} key string key for object property lookup on each item.\n * @param {function} [compare] optional comparison function called to test if an item is distinct from the previous item in the source.\n * @return {Observable} an Observable that emits items from the source Observable with distinct values based on the key specified.\n * @method distinctUntilKeyChanged\n * @owner Observable\n */\nfunction distinctUntilKeyChanged(key, compare) {\n    return distinctUntilChanged_1.distinctUntilChanged.call(this, function (x, y) {\n        if (compare) {\n            return compare(x[key], y[key]);\n        }\n        return x[key] === y[key];\n    });\n}\nexports.distinctUntilKeyChanged = distinctUntilKeyChanged;\n//# sourceMappingURL=distinctUntilKeyChanged.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/distinctUntilKeyChanged.js\n ** module id = 192\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/distinctUntilKeyChanged.js?");

/***/ },
/* 193 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar do_1 = __webpack_require__(194);\nObservable_1.Observable.prototype.do = do_1._do;\nObservable_1.Observable.prototype._do = do_1._do;\n//# sourceMappingURL=do.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/do.js\n ** module id = 193\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/do.js?");

/***/ },
/* 194 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(8);\n/**\n * Perform a side effect for every emission on the source Observable, but return\n * an Observable that is identical to the source.\n *\n * <span class=\"informal\">Intercepts each emission on the source and runs a\n * function, but returns an output which is identical to the source.</span>\n *\n * <img src=\"./img/do.png\" width=\"100%\">\n *\n * Returns a mirrored Observable of the source Observable, but modified so that\n * the provided Observer is called to perform a side effect for every value,\n * error, and completion emitted by the source. Any errors that are thrown in\n * the aforementioned Observer or handlers are safely sent down the error path\n * of the output Observable.\n *\n * This operator is useful for debugging your Observables for the correct values\n * or performing other side effects.\n *\n * Note: this is different to a `subscribe` on the Observable. If the Observable\n * returned by `do` is not subscribed, the side effects specified by the\n * Observer will never happen. `do` therefore simply spies on existing\n * execution, it does not trigger an execution to happen like `subscribe` does.\n *\n * @example <caption>Map every every click to the clientX position of that click, while also logging the click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var positions = clicks\n *   .do(ev => console.log(ev))\n *   .map(ev => ev.clientX);\n * positions.subscribe(x => console.log(x));\n *\n * @see {@link map}\n * @see {@link subscribe}\n *\n * @param {Observer|function} [nextOrObserver] A normal Observer object or a\n * callback for `next`.\n * @param {function} [error] Callback for errors in the source.\n * @param {function} [complete] Callback for the completion of the source.\n * @return {Observable} An Observable identical to the source, but runs the\n * specified Observer or callback(s) for each item.\n * @method do\n * @name do\n * @owner Observable\n */\nfunction _do(nextOrObserver, error, complete) {\n    return this.lift(new DoOperator(nextOrObserver, error, complete));\n}\nexports._do = _do;\nvar DoOperator = (function () {\n    function DoOperator(nextOrObserver, error, complete) {\n        this.nextOrObserver = nextOrObserver;\n        this.error = error;\n        this.complete = complete;\n    }\n    DoOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new DoSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));\n    };\n    return DoOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DoSubscriber = (function (_super) {\n    __extends(DoSubscriber, _super);\n    function DoSubscriber(destination, nextOrObserver, error, complete) {\n        _super.call(this, destination);\n        var safeSubscriber = new Subscriber_1.Subscriber(nextOrObserver, error, complete);\n        safeSubscriber.syncErrorThrowable = true;\n        this.add(safeSubscriber);\n        this.safeSubscriber = safeSubscriber;\n    }\n    DoSubscriber.prototype._next = function (value) {\n        var safeSubscriber = this.safeSubscriber;\n        safeSubscriber.next(value);\n        if (safeSubscriber.syncErrorThrown) {\n            this.destination.error(safeSubscriber.syncErrorValue);\n        }\n        else {\n            this.destination.next(value);\n        }\n    };\n    DoSubscriber.prototype._error = function (err) {\n        var safeSubscriber = this.safeSubscriber;\n        safeSubscriber.error(err);\n        if (safeSubscriber.syncErrorThrown) {\n            this.destination.error(safeSubscriber.syncErrorValue);\n        }\n        else {\n            this.destination.error(err);\n        }\n    };\n    DoSubscriber.prototype._complete = function () {\n        var safeSubscriber = this.safeSubscriber;\n        safeSubscriber.complete();\n        if (safeSubscriber.syncErrorThrown) {\n            this.destination.error(safeSubscriber.syncErrorValue);\n        }\n        else {\n            this.destination.complete();\n        }\n    };\n    return DoSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=do.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/do.js\n ** module id = 194\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/do.js?");

/***/ },
/* 195 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar exhaust_1 = __webpack_require__(196);\nObservable_1.Observable.prototype.exhaust = exhaust_1.exhaust;\n//# sourceMappingURL=exhaust.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/exhaust.js\n ** module id = 195\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/exhaust.js?");

/***/ },
/* 196 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = __webpack_require__(54);\nvar subscribeToResult_1 = __webpack_require__(55);\n/**\n * Converts a higher-order Observable into a first-order Observable by dropping\n * inner Observables while the previous inner Observable has not yet completed.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables by dropping the\n * next inner Observables while the current inner is still executing.</span>\n *\n * <img src=\"./img/exhaust.png\" width=\"100%\">\n *\n * `exhaust` subscribes to an Observable that emits Observables, also known as a\n * higher-order Observable. Each time it observes one of these emitted inner\n * Observables, the output Observable begins emitting the items emitted by that\n * inner Observable. So far, it behaves like {@link mergeAll}. However,\n * `exhaust` ignores every new inner Observable if the previous Observable has\n * not yet completed. Once that one completes, it will accept and flatten the\n * next inner Observable and repeat this process.\n *\n * @example <caption>Run a finite timer for each click, only if there is no currently active timer</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));\n * var result = higherOrder.exhaust();\n * result.subscribe(x => console.log(x));\n *\n * @see {@link combineAll}\n * @see {@link concatAll}\n * @see {@link switch}\n * @see {@link mergeAll}\n * @see {@link exhaustMap}\n * @see {@link zipAll}\n *\n * @return {Observable} Returns an Observable that takes a source of Observables\n * and propagates the first observable exclusively until it completes before\n * subscribing to the next.\n * @method exhaust\n * @owner Observable\n */\nfunction exhaust() {\n    return this.lift(new SwitchFirstOperator());\n}\nexports.exhaust = exhaust;\nvar SwitchFirstOperator = (function () {\n    function SwitchFirstOperator() {\n    }\n    SwitchFirstOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new SwitchFirstSubscriber(subscriber));\n    };\n    return SwitchFirstOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SwitchFirstSubscriber = (function (_super) {\n    __extends(SwitchFirstSubscriber, _super);\n    function SwitchFirstSubscriber(destination) {\n        _super.call(this, destination);\n        this.hasCompleted = false;\n        this.hasSubscription = false;\n    }\n    SwitchFirstSubscriber.prototype._next = function (value) {\n        if (!this.hasSubscription) {\n            this.hasSubscription = true;\n            this.add(subscribeToResult_1.subscribeToResult(this, value));\n        }\n    };\n    SwitchFirstSubscriber.prototype._complete = function () {\n        this.hasCompleted = true;\n        if (!this.hasSubscription) {\n            this.destination.complete();\n        }\n    };\n    SwitchFirstSubscriber.prototype.notifyComplete = function (innerSub) {\n        this.remove(innerSub);\n        this.hasSubscription = false;\n        if (this.hasCompleted) {\n            this.destination.complete();\n        }\n    };\n    return SwitchFirstSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=exhaust.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/exhaust.js\n ** module id = 196\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/exhaust.js?");

/***/ },
/* 197 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar exhaustMap_1 = __webpack_require__(198);\nObservable_1.Observable.prototype.exhaustMap = exhaustMap_1.exhaustMap;\n//# sourceMappingURL=exhaustMap.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/exhaustMap.js\n ** module id = 197\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/exhaustMap.js?");

/***/ },
/* 198 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = __webpack_require__(54);\nvar subscribeToResult_1 = __webpack_require__(55);\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable only if the previous projected Observable has completed.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link exhaust}.</span>\n *\n * <img src=\"./img/exhaustMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. When it projects a source value to\n * an Observable, the output Observable begins emitting the items emitted by\n * that projected Observable. However, `exhaustMap` ignores every new projected\n * Observable if the previous projected Observable has not yet completed. Once\n * that one completes, it will accept and flatten the next projected Observable\n * and repeat this process.\n *\n * @example <caption>Run a finite timer for each click, only if there is no currently active timer</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.exhaustMap((ev) => Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatMap}\n * @see {@link exhaust}\n * @see {@link mergeMap}\n * @see {@link switchMap}\n *\n * @param {function(value: T, ?index: number): Observable} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} An Observable containing projected Observables\n * of each item of the source, ignoring projected Observables that start before\n * their preceding Observable has completed.\n * @method exhaustMap\n * @owner Observable\n */\nfunction exhaustMap(project, resultSelector) {\n    return this.lift(new SwitchFirstMapOperator(project, resultSelector));\n}\nexports.exhaustMap = exhaustMap;\nvar SwitchFirstMapOperator = (function () {\n    function SwitchFirstMapOperator(project, resultSelector) {\n        this.project = project;\n        this.resultSelector = resultSelector;\n    }\n    SwitchFirstMapOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new SwitchFirstMapSubscriber(subscriber, this.project, this.resultSelector));\n    };\n    return SwitchFirstMapOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SwitchFirstMapSubscriber = (function (_super) {\n    __extends(SwitchFirstMapSubscriber, _super);\n    function SwitchFirstMapSubscriber(destination, project, resultSelector) {\n        _super.call(this, destination);\n        this.project = project;\n        this.resultSelector = resultSelector;\n        this.hasSubscription = false;\n        this.hasCompleted = false;\n        this.index = 0;\n    }\n    SwitchFirstMapSubscriber.prototype._next = function (value) {\n        if (!this.hasSubscription) {\n            this.tryNext(value);\n        }\n    };\n    SwitchFirstMapSubscriber.prototype.tryNext = function (value) {\n        var index = this.index++;\n        var destination = this.destination;\n        try {\n            var result = this.project(value, index);\n            this.hasSubscription = true;\n            this.add(subscribeToResult_1.subscribeToResult(this, result, value, index));\n        }\n        catch (err) {\n            destination.error(err);\n        }\n    };\n    SwitchFirstMapSubscriber.prototype._complete = function () {\n        this.hasCompleted = true;\n        if (!this.hasSubscription) {\n            this.destination.complete();\n        }\n    };\n    SwitchFirstMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;\n        if (resultSelector) {\n            this.trySelectResult(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        else {\n            destination.next(innerValue);\n        }\n    };\n    SwitchFirstMapSubscriber.prototype.trySelectResult = function (outerValue, innerValue, outerIndex, innerIndex) {\n        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;\n        try {\n            var result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n            destination.next(result);\n        }\n        catch (err) {\n            destination.error(err);\n        }\n    };\n    SwitchFirstMapSubscriber.prototype.notifyError = function (err) {\n        this.destination.error(err);\n    };\n    SwitchFirstMapSubscriber.prototype.notifyComplete = function (innerSub) {\n        this.remove(innerSub);\n        this.hasSubscription = false;\n        if (this.hasCompleted) {\n            this.destination.complete();\n        }\n    };\n    return SwitchFirstMapSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=exhaustMap.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/exhaustMap.js\n ** module id = 198\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/exhaustMap.js?");

/***/ },
/* 199 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar expand_1 = __webpack_require__(200);\nObservable_1.Observable.prototype.expand = expand_1.expand;\n//# sourceMappingURL=expand.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/expand.js\n ** module id = 199\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/expand.js?");

/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar tryCatch_1 = __webpack_require__(13);\nvar errorObject_1 = __webpack_require__(14);\nvar OuterSubscriber_1 = __webpack_require__(54);\nvar subscribeToResult_1 = __webpack_require__(55);\n/**\n * Recursively projects each source value to an Observable which is merged in\n * the output Observable.\n *\n * <span class=\"informal\">It's similar to {@link mergeMap}, but applies the\n * projection function to every source value as well as every output value.\n * It's recursive.</span>\n *\n * <img src=\"./img/expand.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an Observable, and then merging those resulting Observables and\n * emitting the results of this merger. *Expand* will re-emit on the output\n * Observable every source value. Then, each output value is given to the\n * `project` function which returns an inner Observable to be merged on the\n * output Observable. Those output values resulting from the projection are also\n * given to the `project` function to produce new output values. This is how\n * *expand* behaves recursively.\n *\n * @example <caption>Start emitting the powers of two on every click, at most 10 of them</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var powersOfTwo = clicks\n *   .mapTo(1)\n *   .expand(x => Rx.Observable.of(2 * x).delay(1000))\n *   .take(10);\n * powersOfTwo.subscribe(x => console.log(x));\n *\n * @see {@link mergeMap}\n * @see {@link mergeScan}\n *\n * @param {function(value: T, index: number) => Observable} project A function\n * that, when applied to an item emitted by the source or the output Observable,\n * returns an Observable.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @param {Scheduler} [scheduler=null] The Scheduler to use for subscribing to\n * each projected inner Observable.\n * @return {Observable} An Observable that emits the source values and also\n * result of applying the projection function to each value emitted on the\n * output Observable and and merging the results of the Observables obtained\n * from this transformation.\n * @method expand\n * @owner Observable\n */\nfunction expand(project, concurrent, scheduler) {\n    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n    if (scheduler === void 0) { scheduler = undefined; }\n    concurrent = (concurrent || 0) < 1 ? Number.POSITIVE_INFINITY : concurrent;\n    return this.lift(new ExpandOperator(project, concurrent, scheduler));\n}\nexports.expand = expand;\nvar ExpandOperator = (function () {\n    function ExpandOperator(project, concurrent, scheduler) {\n        this.project = project;\n        this.concurrent = concurrent;\n        this.scheduler = scheduler;\n    }\n    ExpandOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new ExpandSubscriber(subscriber, this.project, this.concurrent, this.scheduler));\n    };\n    return ExpandOperator;\n}());\nexports.ExpandOperator = ExpandOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar ExpandSubscriber = (function (_super) {\n    __extends(ExpandSubscriber, _super);\n    function ExpandSubscriber(destination, project, concurrent, scheduler) {\n        _super.call(this, destination);\n        this.project = project;\n        this.concurrent = concurrent;\n        this.scheduler = scheduler;\n        this.index = 0;\n        this.active = 0;\n        this.hasCompleted = false;\n        if (concurrent < Number.POSITIVE_INFINITY) {\n            this.buffer = [];\n        }\n    }\n    ExpandSubscriber.dispatch = function (arg) {\n        var subscriber = arg.subscriber, result = arg.result, value = arg.value, index = arg.index;\n        subscriber.subscribeToProjection(result, value, index);\n    };\n    ExpandSubscriber.prototype._next = function (value) {\n        var destination = this.destination;\n        if (destination.closed) {\n            this._complete();\n            return;\n        }\n        var index = this.index++;\n        if (this.active < this.concurrent) {\n            destination.next(value);\n            var result = tryCatch_1.tryCatch(this.project)(value, index);\n            if (result === errorObject_1.errorObject) {\n                destination.error(errorObject_1.errorObject.e);\n            }\n            else if (!this.scheduler) {\n                this.subscribeToProjection(result, value, index);\n            }\n            else {\n                var state = { subscriber: this, result: result, value: value, index: index };\n                this.add(this.scheduler.schedule(ExpandSubscriber.dispatch, 0, state));\n            }\n        }\n        else {\n            this.buffer.push(value);\n        }\n    };\n    ExpandSubscriber.prototype.subscribeToProjection = function (result, value, index) {\n        this.active++;\n        this.add(subscribeToResult_1.subscribeToResult(this, result, value, index));\n    };\n    ExpandSubscriber.prototype._complete = function () {\n        this.hasCompleted = true;\n        if (this.hasCompleted && this.active === 0) {\n            this.destination.complete();\n        }\n    };\n    ExpandSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this._next(innerValue);\n    };\n    ExpandSubscriber.prototype.notifyComplete = function (innerSub) {\n        var buffer = this.buffer;\n        this.remove(innerSub);\n        this.active--;\n        if (buffer && buffer.length > 0) {\n            this._next(buffer.shift());\n        }\n        if (this.hasCompleted && this.active === 0) {\n            this.destination.complete();\n        }\n    };\n    return ExpandSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\nexports.ExpandSubscriber = ExpandSubscriber;\n//# sourceMappingURL=expand.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/expand.js\n ** module id = 200\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/expand.js?");

/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar elementAt_1 = __webpack_require__(202);\nObservable_1.Observable.prototype.elementAt = elementAt_1.elementAt;\n//# sourceMappingURL=elementAt.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/elementAt.js\n ** module id = 201\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/elementAt.js?");

/***/ },
/* 202 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(8);\nvar ArgumentOutOfRangeError_1 = __webpack_require__(203);\n/**\n * Emits the single value at the specified `index` in a sequence of emissions\n * from the source Observable.\n *\n * <span class=\"informal\">Emits only the i-th value, then completes.</span>\n *\n * <img src=\"./img/elementAt.png\" width=\"100%\">\n *\n * `elementAt` returns an Observable that emits the item at the specified\n * `index` in the source Observable, or a default value if that `index` is out\n * of range and the `default` argument is provided. If the `default` argument is\n * not given and the `index` is out of range, the output Observable will emit an\n * `ArgumentOutOfRangeError` error.\n *\n * @example <caption>Emit only the third click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.elementAt(2);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link first}\n * @see {@link last}\n * @see {@link skip}\n * @see {@link single}\n * @see {@link take}\n *\n * @throws {ArgumentOutOfRangeError} When using `elementAt(i)`, it delivers an\n * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0` or the\n * Observable has completed before emitting the i-th `next` notification.\n *\n * @param {number} index Is the number `i` for the i-th source emission that has\n * happened since the subscription, starting from the number `0`.\n * @param {T} [defaultValue] The default value returned for missing indices.\n * @return {Observable} An Observable that emits a single item, if it is found.\n * Otherwise, will emit the default value if given. If not, then emits an error.\n * @method elementAt\n * @owner Observable\n */\nfunction elementAt(index, defaultValue) {\n    return this.lift(new ElementAtOperator(index, defaultValue));\n}\nexports.elementAt = elementAt;\nvar ElementAtOperator = (function () {\n    function ElementAtOperator(index, defaultValue) {\n        this.index = index;\n        this.defaultValue = defaultValue;\n        if (index < 0) {\n            throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;\n        }\n    }\n    ElementAtOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new ElementAtSubscriber(subscriber, this.index, this.defaultValue));\n    };\n    return ElementAtOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar ElementAtSubscriber = (function (_super) {\n    __extends(ElementAtSubscriber, _super);\n    function ElementAtSubscriber(destination, index, defaultValue) {\n        _super.call(this, destination);\n        this.index = index;\n        this.defaultValue = defaultValue;\n    }\n    ElementAtSubscriber.prototype._next = function (x) {\n        if (this.index-- === 0) {\n            this.destination.next(x);\n            this.destination.complete();\n        }\n    };\n    ElementAtSubscriber.prototype._complete = function () {\n        var destination = this.destination;\n        if (this.index >= 0) {\n            if (typeof this.defaultValue !== 'undefined') {\n                destination.next(this.defaultValue);\n            }\n            else {\n                destination.error(new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError);\n            }\n        }\n        destination.complete();\n    };\n    return ElementAtSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=elementAt.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/elementAt.js\n ** module id = 202\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/elementAt.js?");

/***/ },
/* 203 */
/***/ function(module, exports) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/**\n * An error thrown when an element was queried at a certain index of an\n * Observable, but no such index or position exists in that sequence.\n *\n * @see {@link elementAt}\n * @see {@link take}\n * @see {@link takeLast}\n *\n * @class ArgumentOutOfRangeError\n */\nvar ArgumentOutOfRangeError = (function (_super) {\n    __extends(ArgumentOutOfRangeError, _super);\n    function ArgumentOutOfRangeError() {\n        var err = _super.call(this, 'argument out of range');\n        this.name = err.name = 'ArgumentOutOfRangeError';\n        this.stack = err.stack;\n        this.message = err.message;\n    }\n    return ArgumentOutOfRangeError;\n}(Error));\nexports.ArgumentOutOfRangeError = ArgumentOutOfRangeError;\n//# sourceMappingURL=ArgumentOutOfRangeError.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/util/ArgumentOutOfRangeError.js\n ** module id = 203\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/util/ArgumentOutOfRangeError.js?");

/***/ },
/* 204 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar filter_1 = __webpack_require__(205);\nObservable_1.Observable.prototype.filter = filter_1.filter;\n//# sourceMappingURL=filter.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/filter.js\n ** module id = 204\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/filter.js?");

/***/ },
/* 205 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(8);\n/**\n * Filter items emitted by the source Observable by only emitting those that\n * satisfy a specified predicate.\n *\n * <span class=\"informal\">Like\n * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),\n * it only emits a value from the source if it passes a criterion function.</span>\n *\n * <img src=\"./img/filter.png\" width=\"100%\">\n *\n * Similar to the well-known `Array.prototype.filter` method, this operator\n * takes values from the source Observable, passes them through a `predicate`\n * function and only emits those values that yielded `true`.\n *\n * @example <caption>Emit only click events whose target was a DIV element</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var clicksOnDivs = clicks.filter(ev => ev.target.tagName === 'DIV');\n * clicksOnDivs.subscribe(x => console.log(x));\n *\n * @see {@link distinct}\n * @see {@link distinctKey}\n * @see {@link distinctUntilChanged}\n * @see {@link distinctUntilKeyChanged}\n * @see {@link ignoreElements}\n * @see {@link partition}\n * @see {@link skip}\n *\n * @param {function(value: T, index: number): boolean} predicate A function that\n * evaluates each value emitted by the source Observable. If it returns `true`,\n * the value is emitted, if `false` the value is not passed to the output\n * Observable. The `index` parameter is the number `i` for the i-th source\n * emission that has happened since the subscription, starting from the number\n * `0`.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {Observable} An Observable of values from the source that were\n * allowed by the `predicate` function.\n * @method filter\n * @owner Observable\n */\nfunction filter(predicate, thisArg) {\n    return this.lift(new FilterOperator(predicate, thisArg));\n}\nexports.filter = filter;\nvar FilterOperator = (function () {\n    function FilterOperator(predicate, thisArg) {\n        this.predicate = predicate;\n        this.thisArg = thisArg;\n    }\n    FilterOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));\n    };\n    return FilterOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar FilterSubscriber = (function (_super) {\n    __extends(FilterSubscriber, _super);\n    function FilterSubscriber(destination, predicate, thisArg) {\n        _super.call(this, destination);\n        this.predicate = predicate;\n        this.thisArg = thisArg;\n        this.count = 0;\n        this.predicate = predicate;\n    }\n    // the try catch block below is left specifically for\n    // optimization and perf reasons. a tryCatcher is not necessary here.\n    FilterSubscriber.prototype._next = function (value) {\n        var result;\n        try {\n            result = this.predicate.call(this.thisArg, value, this.count++);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        if (result) {\n            this.destination.next(value);\n        }\n    };\n    return FilterSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=filter.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/filter.js\n ** module id = 205\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/filter.js?");

/***/ },
/* 206 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar finally_1 = __webpack_require__(207);\nObservable_1.Observable.prototype.finally = finally_1._finally;\nObservable_1.Observable.prototype._finally = finally_1._finally;\n//# sourceMappingURL=finally.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/finally.js\n ** module id = 206\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/finally.js?");

/***/ },
/* 207 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(8);\nvar Subscription_1 = __webpack_require__(10);\n/**\n * Returns an Observable that mirrors the source Observable, but will call a specified function when\n * the source terminates on complete or error.\n * @param {function} callback function to be called when source terminates.\n * @return {Observable} an Observable that mirrors the source, but will call the specified function on termination.\n * @method finally\n * @owner Observable\n */\nfunction _finally(callback) {\n    return this.lift(new FinallyOperator(callback));\n}\nexports._finally = _finally;\nvar FinallyOperator = (function () {\n    function FinallyOperator(callback) {\n        this.callback = callback;\n    }\n    FinallyOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new FinallySubscriber(subscriber, this.callback));\n    };\n    return FinallyOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar FinallySubscriber = (function (_super) {\n    __extends(FinallySubscriber, _super);\n    function FinallySubscriber(destination, callback) {\n        _super.call(this, destination);\n        this.add(new Subscription_1.Subscription(callback));\n    }\n    return FinallySubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=finally.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/finally.js\n ** module id = 207\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/finally.js?");

/***/ },
/* 208 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar find_1 = __webpack_require__(209);\nObservable_1.Observable.prototype.find = find_1.find;\n//# sourceMappingURL=find.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/find.js\n ** module id = 208\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/find.js?");

/***/ },
/* 209 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(8);\n/**\n * Emits only the first value emitted by the source Observable that meets some\n * condition.\n *\n * <span class=\"informal\">Finds the first value that passes some test and emits\n * that.</span>\n *\n * <img src=\"./img/find.png\" width=\"100%\">\n *\n * `find` searches for the first item in the source Observable that matches the\n * specified condition embodied by the `predicate`, and returns the first\n * occurrence in the source. Unlike {@link first}, the `predicate` is required\n * in `find`, and does not emit an error if a valid value is not found.\n *\n * @example <caption>Find and emit the first click that happens on a DIV element</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.find(ev => ev.target.tagName === 'DIV');\n * result.subscribe(x => console.log(x));\n *\n * @see {@link filter}\n * @see {@link first}\n * @see {@link findIndex}\n * @see {@link take}\n *\n * @param {function(value: T, index: number, source: Observable<T>): boolean} predicate\n * A function called with each item to test for condition matching.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {Observable<T>} An Observable of the first item that matches the\n * condition.\n * @method find\n * @owner Observable\n */\nfunction find(predicate, thisArg) {\n    if (typeof predicate !== 'function') {\n        throw new TypeError('predicate is not a function');\n    }\n    return this.lift(new FindValueOperator(predicate, this, false, thisArg));\n}\nexports.find = find;\nvar FindValueOperator = (function () {\n    function FindValueOperator(predicate, source, yieldIndex, thisArg) {\n        this.predicate = predicate;\n        this.source = source;\n        this.yieldIndex = yieldIndex;\n        this.thisArg = thisArg;\n    }\n    FindValueOperator.prototype.call = function (observer, source) {\n        return source._subscribe(new FindValueSubscriber(observer, this.predicate, this.source, this.yieldIndex, this.thisArg));\n    };\n    return FindValueOperator;\n}());\nexports.FindValueOperator = FindValueOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar FindValueSubscriber = (function (_super) {\n    __extends(FindValueSubscriber, _super);\n    function FindValueSubscriber(destination, predicate, source, yieldIndex, thisArg) {\n        _super.call(this, destination);\n        this.predicate = predicate;\n        this.source = source;\n        this.yieldIndex = yieldIndex;\n        this.thisArg = thisArg;\n        this.index = 0;\n    }\n    FindValueSubscriber.prototype.notifyComplete = function (value) {\n        var destination = this.destination;\n        destination.next(value);\n        destination.complete();\n    };\n    FindValueSubscriber.prototype._next = function (value) {\n        var _a = this, predicate = _a.predicate, thisArg = _a.thisArg;\n        var index = this.index++;\n        try {\n            var result = predicate.call(thisArg || this, value, index, this.source);\n            if (result) {\n                this.notifyComplete(this.yieldIndex ? index : value);\n            }\n        }\n        catch (err) {\n            this.destination.error(err);\n        }\n    };\n    FindValueSubscriber.prototype._complete = function () {\n        this.notifyComplete(this.yieldIndex ? -1 : undefined);\n    };\n    return FindValueSubscriber;\n}(Subscriber_1.Subscriber));\nexports.FindValueSubscriber = FindValueSubscriber;\n//# sourceMappingURL=find.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/find.js\n ** module id = 209\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/find.js?");

/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar findIndex_1 = __webpack_require__(211);\nObservable_1.Observable.prototype.findIndex = findIndex_1.findIndex;\n//# sourceMappingURL=findIndex.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/findIndex.js\n ** module id = 210\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/findIndex.js?");

/***/ },
/* 211 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar find_1 = __webpack_require__(209);\n/**\n * Emits only the index of the first value emitted by the source Observable that\n * meets some condition.\n *\n * <span class=\"informal\">It's like {@link find}, but emits the index of the\n * found value, not the value itself.</span>\n *\n * <img src=\"./img/findIndex.png\" width=\"100%\">\n *\n * `findIndex` searches for the first item in the source Observable that matches\n * the specified condition embodied by the `predicate`, and returns the\n * (zero-based) index of the first occurrence in the source. Unlike\n * {@link first}, the `predicate` is required in `findIndex`, and does not emit\n * an error if a valid value is not found.\n *\n * @example <caption>Emit the index of first click that happens on a DIV element</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.findIndex(ev => ev.target.tagName === 'DIV');\n * result.subscribe(x => console.log(x));\n *\n * @see {@link filter}\n * @see {@link find}\n * @see {@link first}\n * @see {@link take}\n *\n * @param {function(value: T, index: number, source: Observable<T>): boolean} predicate\n * A function called with each item to test for condition matching.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {Observable} An Observable of the index of the first item that\n * matches the condition.\n * @method find\n * @owner Observable\n */\nfunction findIndex(predicate, thisArg) {\n    return this.lift(new find_1.FindValueOperator(predicate, this, true, thisArg));\n}\nexports.findIndex = findIndex;\n//# sourceMappingURL=findIndex.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/findIndex.js\n ** module id = 211\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/findIndex.js?");

/***/ },
/* 212 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar first_1 = __webpack_require__(213);\nObservable_1.Observable.prototype.first = first_1.first;\n//# sourceMappingURL=first.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/first.js\n ** module id = 212\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/first.js?");

/***/ },
/* 213 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(8);\nvar EmptyError_1 = __webpack_require__(214);\n/**\n * Emits only the first value (or the first value that meets some condition)\n * emitted by the source Observable.\n *\n * <span class=\"informal\">Emits only the first value. Or emits only the first\n * value that passes some test.</span>\n *\n * <img src=\"./img/first.png\" width=\"100%\">\n *\n * If called with no arguments, `first` emits the first value of the source\n * Observable, then completes. If called with a `predicate` function, `first`\n * emits the first value of the source that matches the specified condition. It\n * may also take a `resultSelector` function to produce the output value from\n * the input value, and a `defaultValue` to emit in case the source completes\n * before it is able to emit a valid value. Throws an error if `defaultValue`\n * was not provided and a matching element is not found.\n *\n * @example <caption>Emit only the first click that happens on the DOM</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.first();\n * result.subscribe(x => console.log(x));\n *\n * @example <caption>Emits the first click that happens on a DIV</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.first(ev => ev.target.tagName === 'DIV');\n * result.subscribe(x => console.log(x));\n *\n * @see {@link filter}\n * @see {@link find}\n * @see {@link take}\n *\n * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`\n * callback if the Observable completes before any `next` notification was sent.\n *\n * @param {function(value: T, index: number, source: Observable<T>): boolean} [predicate]\n * An optional function called with each item to test for condition matching.\n * @param {function(value: T, index: number): R} [resultSelector] A function to\n * produce the value on the output Observable based on the values\n * and the indices of the source Observable. The arguments passed to this\n * function are:\n * - `value`: the value that was emitted on the source.\n * - `index`: the \"index\" of the value from the source.\n * @param {R} [defaultValue] The default value emitted in case no valid value\n * was found on the source.\n * @return {Observable<T|R>} an Observable of the first item that matches the\n * condition.\n * @method first\n * @owner Observable\n */\nfunction first(predicate, resultSelector, defaultValue) {\n    return this.lift(new FirstOperator(predicate, resultSelector, defaultValue, this));\n}\nexports.first = first;\nvar FirstOperator = (function () {\n    function FirstOperator(predicate, resultSelector, defaultValue, source) {\n        this.predicate = predicate;\n        this.resultSelector = resultSelector;\n        this.defaultValue = defaultValue;\n        this.source = source;\n    }\n    FirstOperator.prototype.call = function (observer, source) {\n        return source._subscribe(new FirstSubscriber(observer, this.predicate, this.resultSelector, this.defaultValue, this.source));\n    };\n    return FirstOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar FirstSubscriber = (function (_super) {\n    __extends(FirstSubscriber, _super);\n    function FirstSubscriber(destination, predicate, resultSelector, defaultValue, source) {\n        _super.call(this, destination);\n        this.predicate = predicate;\n        this.resultSelector = resultSelector;\n        this.defaultValue = defaultValue;\n        this.source = source;\n        this.index = 0;\n        this.hasCompleted = false;\n    }\n    FirstSubscriber.prototype._next = function (value) {\n        var index = this.index++;\n        if (this.predicate) {\n            this._tryPredicate(value, index);\n        }\n        else {\n            this._emit(value, index);\n        }\n    };\n    FirstSubscriber.prototype._tryPredicate = function (value, index) {\n        var result;\n        try {\n            result = this.predicate(value, index, this.source);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        if (result) {\n            this._emit(value, index);\n        }\n    };\n    FirstSubscriber.prototype._emit = function (value, index) {\n        if (this.resultSelector) {\n            this._tryResultSelector(value, index);\n            return;\n        }\n        this._emitFinal(value);\n    };\n    FirstSubscriber.prototype._tryResultSelector = function (value, index) {\n        var result;\n        try {\n            result = this.resultSelector(value, index);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this._emitFinal(result);\n    };\n    FirstSubscriber.prototype._emitFinal = function (value) {\n        var destination = this.destination;\n        destination.next(value);\n        destination.complete();\n        this.hasCompleted = true;\n    };\n    FirstSubscriber.prototype._complete = function () {\n        var destination = this.destination;\n        if (!this.hasCompleted && typeof this.defaultValue !== 'undefined') {\n            destination.next(this.defaultValue);\n            destination.complete();\n        }\n        else if (!this.hasCompleted) {\n            destination.error(new EmptyError_1.EmptyError);\n        }\n    };\n    return FirstSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=first.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/first.js\n ** module id = 213\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/first.js?");

/***/ },
/* 214 */
/***/ function(module, exports) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/**\n * An error thrown when an Observable or a sequence was queried but has no\n * elements.\n *\n * @see {@link first}\n * @see {@link last}\n * @see {@link single}\n *\n * @class EmptyError\n */\nvar EmptyError = (function (_super) {\n    __extends(EmptyError, _super);\n    function EmptyError() {\n        var err = _super.call(this, 'no elements in sequence');\n        this.name = err.name = 'EmptyError';\n        this.stack = err.stack;\n        this.message = err.message;\n    }\n    return EmptyError;\n}(Error));\nexports.EmptyError = EmptyError;\n//# sourceMappingURL=EmptyError.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/util/EmptyError.js\n ** module id = 214\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/util/EmptyError.js?");

/***/ },
/* 215 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar groupBy_1 = __webpack_require__(216);\nObservable_1.Observable.prototype.groupBy = groupBy_1.groupBy;\n//# sourceMappingURL=groupBy.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/groupBy.js\n ** module id = 215\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/groupBy.js?");

/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(8);\nvar Subscription_1 = __webpack_require__(10);\nvar Observable_1 = __webpack_require__(5);\nvar Subject_1 = __webpack_require__(4);\nvar Map_1 = __webpack_require__(217);\nvar FastMap_1 = __webpack_require__(219);\n/**\n * Groups the items emitted by an Observable according to a specified criterion,\n * and emits these grouped items as `GroupedObservables`, one\n * {@link GroupedObservable} per group.\n *\n * <img src=\"./img/groupBy.png\" width=\"100%\">\n *\n * @param {function(value: T): K} keySelector a function that extracts the key\n * for each item.\n * @param {function(value: T): R} [elementSelector] a function that extracts the\n * return element for each item.\n * @param {function(grouped: GroupedObservable<K,R>): Observable<any>} [durationSelector]\n * a function that returns an Observable to determine how long each group should\n * exist.\n * @return {Observable<GroupedObservable<K,R>>} an Observable that emits\n * GroupedObservables, each of which corresponds to a unique key value and each\n * of which emits those items from the source Observable that share that key\n * value.\n * @method groupBy\n * @owner Observable\n */\nfunction groupBy(keySelector, elementSelector, durationSelector) {\n    return this.lift(new GroupByOperator(this, keySelector, elementSelector, durationSelector));\n}\nexports.groupBy = groupBy;\nvar GroupByOperator = (function () {\n    function GroupByOperator(source, keySelector, elementSelector, durationSelector) {\n        this.source = source;\n        this.keySelector = keySelector;\n        this.elementSelector = elementSelector;\n        this.durationSelector = durationSelector;\n    }\n    GroupByOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new GroupBySubscriber(subscriber, this.keySelector, this.elementSelector, this.durationSelector));\n    };\n    return GroupByOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar GroupBySubscriber = (function (_super) {\n    __extends(GroupBySubscriber, _super);\n    function GroupBySubscriber(destination, keySelector, elementSelector, durationSelector) {\n        _super.call(this, destination);\n        this.keySelector = keySelector;\n        this.elementSelector = elementSelector;\n        this.durationSelector = durationSelector;\n        this.groups = null;\n        this.attemptedToUnsubscribe = false;\n        this.count = 0;\n    }\n    GroupBySubscriber.prototype._next = function (value) {\n        var key;\n        try {\n            key = this.keySelector(value);\n        }\n        catch (err) {\n            this.error(err);\n            return;\n        }\n        this._group(value, key);\n    };\n    GroupBySubscriber.prototype._group = function (value, key) {\n        var groups = this.groups;\n        if (!groups) {\n            groups = this.groups = typeof key === 'string' ? new FastMap_1.FastMap() : new Map_1.Map();\n        }\n        var group = groups.get(key);\n        var element;\n        if (this.elementSelector) {\n            try {\n                element = this.elementSelector(value);\n            }\n            catch (err) {\n                this.error(err);\n            }\n        }\n        else {\n            element = value;\n        }\n        if (!group) {\n            groups.set(key, group = new Subject_1.Subject());\n            var groupedObservable = new GroupedObservable(key, group, this);\n            this.destination.next(groupedObservable);\n            if (this.durationSelector) {\n                var duration = void 0;\n                try {\n                    duration = this.durationSelector(new GroupedObservable(key, group));\n                }\n                catch (err) {\n                    this.error(err);\n                    return;\n                }\n                this.add(duration.subscribe(new GroupDurationSubscriber(key, group, this)));\n            }\n        }\n        if (!group.closed) {\n            group.next(element);\n        }\n    };\n    GroupBySubscriber.prototype._error = function (err) {\n        var groups = this.groups;\n        if (groups) {\n            groups.forEach(function (group, key) {\n                group.error(err);\n            });\n            groups.clear();\n        }\n        this.destination.error(err);\n    };\n    GroupBySubscriber.prototype._complete = function () {\n        var groups = this.groups;\n        if (groups) {\n            groups.forEach(function (group, key) {\n                group.complete();\n            });\n            groups.clear();\n        }\n        this.destination.complete();\n    };\n    GroupBySubscriber.prototype.removeGroup = function (key) {\n        this.groups.delete(key);\n    };\n    GroupBySubscriber.prototype.unsubscribe = function () {\n        if (!this.closed && !this.attemptedToUnsubscribe) {\n            this.attemptedToUnsubscribe = true;\n            if (this.count === 0) {\n                _super.prototype.unsubscribe.call(this);\n            }\n        }\n    };\n    return GroupBySubscriber;\n}(Subscriber_1.Subscriber));\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar GroupDurationSubscriber = (function (_super) {\n    __extends(GroupDurationSubscriber, _super);\n    function GroupDurationSubscriber(key, group, parent) {\n        _super.call(this);\n        this.key = key;\n        this.group = group;\n        this.parent = parent;\n    }\n    GroupDurationSubscriber.prototype._next = function (value) {\n        this._complete();\n    };\n    GroupDurationSubscriber.prototype._error = function (err) {\n        var group = this.group;\n        if (!group.closed) {\n            group.error(err);\n        }\n        this.parent.removeGroup(this.key);\n    };\n    GroupDurationSubscriber.prototype._complete = function () {\n        var group = this.group;\n        if (!group.closed) {\n            group.complete();\n        }\n        this.parent.removeGroup(this.key);\n    };\n    return GroupDurationSubscriber;\n}(Subscriber_1.Subscriber));\n/**\n * An Observable representing values belonging to the same group represented by\n * a common key. The values emitted by a GroupedObservable come from the source\n * Observable. The common key is available as the field `key` on a\n * GroupedObservable instance.\n *\n * @class GroupedObservable<K, T>\n */\nvar GroupedObservable = (function (_super) {\n    __extends(GroupedObservable, _super);\n    function GroupedObservable(key, groupSubject, refCountSubscription) {\n        _super.call(this);\n        this.key = key;\n        this.groupSubject = groupSubject;\n        this.refCountSubscription = refCountSubscription;\n    }\n    GroupedObservable.prototype._subscribe = function (subscriber) {\n        var subscription = new Subscription_1.Subscription();\n        var _a = this, refCountSubscription = _a.refCountSubscription, groupSubject = _a.groupSubject;\n        if (refCountSubscription && !refCountSubscription.closed) {\n            subscription.add(new InnerRefCountSubscription(refCountSubscription));\n        }\n        subscription.add(groupSubject.subscribe(subscriber));\n        return subscription;\n    };\n    return GroupedObservable;\n}(Observable_1.Observable));\nexports.GroupedObservable = GroupedObservable;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar InnerRefCountSubscription = (function (_super) {\n    __extends(InnerRefCountSubscription, _super);\n    function InnerRefCountSubscription(parent) {\n        _super.call(this);\n        this.parent = parent;\n        parent.count++;\n    }\n    InnerRefCountSubscription.prototype.unsubscribe = function () {\n        var parent = this.parent;\n        if (!parent.closed && !this.closed) {\n            _super.prototype.unsubscribe.call(this);\n            parent.count -= 1;\n            if (parent.count === 0 && parent.attemptedToUnsubscribe) {\n                parent.unsubscribe();\n            }\n        }\n    };\n    return InnerRefCountSubscription;\n}(Subscription_1.Subscription));\n//# sourceMappingURL=groupBy.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/groupBy.js\n ** module id = 216\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/groupBy.js?");

/***/ },
/* 217 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar root_1 = __webpack_require__(6);\nvar MapPolyfill_1 = __webpack_require__(218);\nexports.Map = root_1.root.Map || (function () { return MapPolyfill_1.MapPolyfill; })();\n//# sourceMappingURL=Map.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/util/Map.js\n ** module id = 217\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/util/Map.js?");

/***/ },
/* 218 */
/***/ function(module, exports) {

	eval("\"use strict\";\nvar MapPolyfill = (function () {\n    function MapPolyfill() {\n        this.size = 0;\n        this._values = [];\n        this._keys = [];\n    }\n    MapPolyfill.prototype.get = function (key) {\n        var i = this._keys.indexOf(key);\n        return i === -1 ? undefined : this._values[i];\n    };\n    MapPolyfill.prototype.set = function (key, value) {\n        var i = this._keys.indexOf(key);\n        if (i === -1) {\n            this._keys.push(key);\n            this._values.push(value);\n            this.size++;\n        }\n        else {\n            this._values[i] = value;\n        }\n        return this;\n    };\n    MapPolyfill.prototype.delete = function (key) {\n        var i = this._keys.indexOf(key);\n        if (i === -1) {\n            return false;\n        }\n        this._values.splice(i, 1);\n        this._keys.splice(i, 1);\n        this.size--;\n        return true;\n    };\n    MapPolyfill.prototype.clear = function () {\n        this._keys.length = 0;\n        this._values.length = 0;\n        this.size = 0;\n    };\n    MapPolyfill.prototype.forEach = function (cb, thisArg) {\n        for (var i = 0; i < this.size; i++) {\n            cb.call(thisArg, this._values[i], this._keys[i]);\n        }\n    };\n    return MapPolyfill;\n}());\nexports.MapPolyfill = MapPolyfill;\n//# sourceMappingURL=MapPolyfill.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/util/MapPolyfill.js\n ** module id = 218\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/util/MapPolyfill.js?");

/***/ },
/* 219 */
/***/ function(module, exports) {

	eval("\"use strict\";\nvar FastMap = (function () {\n    function FastMap() {\n        this.values = {};\n    }\n    FastMap.prototype.delete = function (key) {\n        this.values[key] = null;\n        return true;\n    };\n    FastMap.prototype.set = function (key, value) {\n        this.values[key] = value;\n        return this;\n    };\n    FastMap.prototype.get = function (key) {\n        return this.values[key];\n    };\n    FastMap.prototype.forEach = function (cb, thisArg) {\n        var values = this.values;\n        for (var key in values) {\n            if (values.hasOwnProperty(key) && values[key] !== null) {\n                cb.call(thisArg, values[key], key);\n            }\n        }\n    };\n    FastMap.prototype.clear = function () {\n        this.values = {};\n    };\n    return FastMap;\n}());\nexports.FastMap = FastMap;\n//# sourceMappingURL=FastMap.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/util/FastMap.js\n ** module id = 219\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/util/FastMap.js?");

/***/ },
/* 220 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar ignoreElements_1 = __webpack_require__(221);\nObservable_1.Observable.prototype.ignoreElements = ignoreElements_1.ignoreElements;\n//# sourceMappingURL=ignoreElements.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/ignoreElements.js\n ** module id = 220\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/ignoreElements.js?");

/***/ },
/* 221 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(8);\nvar noop_1 = __webpack_require__(109);\n/**\n * Ignores all items emitted by the source Observable and only passes calls of `complete` or `error`.\n *\n * <img src=\"./img/ignoreElements.png\" width=\"100%\">\n *\n * @return {Observable} an empty Observable that only calls `complete`\n * or `error`, based on which one is called by the source Observable.\n * @method ignoreElements\n * @owner Observable\n */\nfunction ignoreElements() {\n    return this.lift(new IgnoreElementsOperator());\n}\nexports.ignoreElements = ignoreElements;\n;\nvar IgnoreElementsOperator = (function () {\n    function IgnoreElementsOperator() {\n    }\n    IgnoreElementsOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new IgnoreElementsSubscriber(subscriber));\n    };\n    return IgnoreElementsOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar IgnoreElementsSubscriber = (function (_super) {\n    __extends(IgnoreElementsSubscriber, _super);\n    function IgnoreElementsSubscriber() {\n        _super.apply(this, arguments);\n    }\n    IgnoreElementsSubscriber.prototype._next = function (unused) {\n        noop_1.noop();\n    };\n    return IgnoreElementsSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=ignoreElements.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/ignoreElements.js\n ** module id = 221\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/ignoreElements.js?");

/***/ },
/* 222 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar isEmpty_1 = __webpack_require__(223);\nObservable_1.Observable.prototype.isEmpty = isEmpty_1.isEmpty;\n//# sourceMappingURL=isEmpty.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/isEmpty.js\n ** module id = 222\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/isEmpty.js?");

/***/ },
/* 223 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(8);\n/**\n * If the source Observable is empty it returns an Observable that emits true, otherwise it emits false.\n *\n * <img src=\"./img/isEmpty.png\" width=\"100%\">\n *\n * @return {Observable} an Observable that emits a Boolean.\n * @method isEmpty\n * @owner Observable\n */\nfunction isEmpty() {\n    return this.lift(new IsEmptyOperator());\n}\nexports.isEmpty = isEmpty;\nvar IsEmptyOperator = (function () {\n    function IsEmptyOperator() {\n    }\n    IsEmptyOperator.prototype.call = function (observer, source) {\n        return source._subscribe(new IsEmptySubscriber(observer));\n    };\n    return IsEmptyOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar IsEmptySubscriber = (function (_super) {\n    __extends(IsEmptySubscriber, _super);\n    function IsEmptySubscriber(destination) {\n        _super.call(this, destination);\n    }\n    IsEmptySubscriber.prototype.notifyComplete = function (isEmpty) {\n        var destination = this.destination;\n        destination.next(isEmpty);\n        destination.complete();\n    };\n    IsEmptySubscriber.prototype._next = function (value) {\n        this.notifyComplete(false);\n    };\n    IsEmptySubscriber.prototype._complete = function () {\n        this.notifyComplete(true);\n    };\n    return IsEmptySubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=isEmpty.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/isEmpty.js\n ** module id = 223\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/isEmpty.js?");

/***/ },
/* 224 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar audit_1 = __webpack_require__(225);\nObservable_1.Observable.prototype.audit = audit_1.audit;\n//# sourceMappingURL=audit.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/audit.js\n ** module id = 224\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/audit.js?");

/***/ },
/* 225 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar tryCatch_1 = __webpack_require__(13);\nvar errorObject_1 = __webpack_require__(14);\nvar OuterSubscriber_1 = __webpack_require__(54);\nvar subscribeToResult_1 = __webpack_require__(55);\n/**\n * Ignores source values for a duration determined by another Observable, then\n * emits the most recent value from the source Observable, then repeats this\n * process.\n *\n * <span class=\"informal\">It's like {@link auditTime}, but the silencing\n * duration is determined by a second Observable.</span>\n *\n * <img src=\"./img/audit.png\" width=\"100%\">\n *\n * `audit` is similar to `throttle`, but emits the last value from the silenced\n * time window, instead of the first value. `audit` emits the most recent value\n * from the source Observable on the output Observable as soon as its internal\n * timer becomes disabled, and ignores source values while the timer is enabled.\n * Initially, the timer is disabled. As soon as the first source value arrives,\n * the timer is enabled by calling the `durationSelector` function with the\n * source value, which returns the \"duration\" Observable. When the duration\n * Observable emits a value or completes, the timer is disabled, then the most\n * recent source value is emitted on the output Observable, and this process\n * repeats for the next source value.\n *\n * @example <caption>Emit clicks at a rate of at most one click per second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.audit(ev => Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link auditTime}\n * @see {@link debounce}\n * @see {@link delayWhen}\n * @see {@link sample}\n * @see {@link throttle}\n *\n * @param {function(value: T): Observable|Promise} durationSelector A function\n * that receives a value from the source Observable, for computing the silencing\n * duration, returned as an Observable or a Promise.\n * @return {Observable<T>} An Observable that performs rate-limiting of\n * emissions from the source Observable.\n * @method audit\n * @owner Observable\n */\nfunction audit(durationSelector) {\n    return this.lift(new AuditOperator(durationSelector));\n}\nexports.audit = audit;\nvar AuditOperator = (function () {\n    function AuditOperator(durationSelector) {\n        this.durationSelector = durationSelector;\n    }\n    AuditOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new AuditSubscriber(subscriber, this.durationSelector));\n    };\n    return AuditOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar AuditSubscriber = (function (_super) {\n    __extends(AuditSubscriber, _super);\n    function AuditSubscriber(destination, durationSelector) {\n        _super.call(this, destination);\n        this.durationSelector = durationSelector;\n        this.hasValue = false;\n    }\n    AuditSubscriber.prototype._next = function (value) {\n        this.value = value;\n        this.hasValue = true;\n        if (!this.throttled) {\n            var duration = tryCatch_1.tryCatch(this.durationSelector)(value);\n            if (duration === errorObject_1.errorObject) {\n                this.destination.error(errorObject_1.errorObject.e);\n            }\n            else {\n                this.add(this.throttled = subscribeToResult_1.subscribeToResult(this, duration));\n            }\n        }\n    };\n    AuditSubscriber.prototype.clearThrottle = function () {\n        var _a = this, value = _a.value, hasValue = _a.hasValue, throttled = _a.throttled;\n        if (throttled) {\n            this.remove(throttled);\n            this.throttled = null;\n            throttled.unsubscribe();\n        }\n        if (hasValue) {\n            this.value = null;\n            this.hasValue = false;\n            this.destination.next(value);\n        }\n    };\n    AuditSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {\n        this.clearThrottle();\n    };\n    AuditSubscriber.prototype.notifyComplete = function () {\n        this.clearThrottle();\n    };\n    return AuditSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=audit.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/audit.js\n ** module id = 225\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/audit.js?");

/***/ },
/* 226 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar auditTime_1 = __webpack_require__(227);\nObservable_1.Observable.prototype.auditTime = auditTime_1.auditTime;\n//# sourceMappingURL=auditTime.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/auditTime.js\n ** module id = 226\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/auditTime.js?");

/***/ },
/* 227 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar async_1 = __webpack_require__(96);\nvar Subscriber_1 = __webpack_require__(8);\n/**\n * Ignores source values for `duration` milliseconds, then emits the most recent\n * value from the source Observable, then repeats this process.\n *\n * <span class=\"informal\">When it sees a source values, it ignores that plus\n * the next ones for `duration` milliseconds, and then it emits the most recent\n * value from the source.</span>\n *\n * <img src=\"./img/auditTime.png\" width=\"100%\">\n *\n * `auditTime` is similar to `throttleTime`, but emits the last value from the\n * silenced time window, instead of the first value. `auditTime` emits the most\n * recent value from the source Observable on the output Observable as soon as\n * its internal timer becomes disabled, and ignores source values while the\n * timer is enabled. Initially, the timer is disabled. As soon as the first\n * source value arrives, the timer is enabled. After `duration` milliseconds (or\n * the time unit determined internally by the optional `scheduler`) has passed,\n * the timer is disabled, then the most recent source value is emitted on the\n * output Observable, and this process repeats for the next source value.\n * Optionally takes a {@link Scheduler} for managing timers.\n *\n * @example <caption>Emit clicks at a rate of at most one click per second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.auditTime(1000);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link audit}\n * @see {@link debounceTime}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttleTime}\n *\n * @param {number} duration Time to wait before emitting the most recent source\n * value, measured in milliseconds or the time unit determined internally\n * by the optional `scheduler`.\n * @param {Scheduler} [scheduler=async] The {@link Scheduler} to use for\n * managing the timers that handle the rate-limiting behavior.\n * @return {Observable<T>} An Observable that performs rate-limiting of\n * emissions from the source Observable.\n * @method auditTime\n * @owner Observable\n */\nfunction auditTime(duration, scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    return this.lift(new AuditTimeOperator(duration, scheduler));\n}\nexports.auditTime = auditTime;\nvar AuditTimeOperator = (function () {\n    function AuditTimeOperator(duration, scheduler) {\n        this.duration = duration;\n        this.scheduler = scheduler;\n    }\n    AuditTimeOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new AuditTimeSubscriber(subscriber, this.duration, this.scheduler));\n    };\n    return AuditTimeOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar AuditTimeSubscriber = (function (_super) {\n    __extends(AuditTimeSubscriber, _super);\n    function AuditTimeSubscriber(destination, duration, scheduler) {\n        _super.call(this, destination);\n        this.duration = duration;\n        this.scheduler = scheduler;\n        this.hasValue = false;\n    }\n    AuditTimeSubscriber.prototype._next = function (value) {\n        this.value = value;\n        this.hasValue = true;\n        if (!this.throttled) {\n            this.add(this.throttled = this.scheduler.schedule(dispatchNext, this.duration, this));\n        }\n    };\n    AuditTimeSubscriber.prototype.clearThrottle = function () {\n        var _a = this, value = _a.value, hasValue = _a.hasValue, throttled = _a.throttled;\n        if (throttled) {\n            this.remove(throttled);\n            this.throttled = null;\n            throttled.unsubscribe();\n        }\n        if (hasValue) {\n            this.value = null;\n            this.hasValue = false;\n            this.destination.next(value);\n        }\n    };\n    return AuditTimeSubscriber;\n}(Subscriber_1.Subscriber));\nfunction dispatchNext(subscriber) {\n    subscriber.clearThrottle();\n}\n//# sourceMappingURL=auditTime.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/auditTime.js\n ** module id = 227\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/auditTime.js?");

/***/ },
/* 228 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar last_1 = __webpack_require__(229);\nObservable_1.Observable.prototype.last = last_1.last;\n//# sourceMappingURL=last.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/last.js\n ** module id = 228\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/last.js?");

/***/ },
/* 229 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(8);\nvar EmptyError_1 = __webpack_require__(214);\n/**\n * Returns an Observable that emits only the last item emitted by the source Observable.\n * It optionally takes a predicate function as a parameter, in which case, rather than emitting\n * the last item from the source Observable, the resulting Observable will emit the last item\n * from the source Observable that satisfies the predicate.\n *\n * <img src=\"./img/last.png\" width=\"100%\">\n *\n * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`\n * callback if the Observable completes before any `next` notification was sent.\n * @param {function} predicate - the condition any source emitted item has to satisfy.\n * @return {Observable} an Observable that emits only the last item satisfying the given condition\n * from the source, or an NoSuchElementException if no such items are emitted.\n * @throws - Throws if no items that match the predicate are emitted by the source Observable.\n * @method last\n * @owner Observable\n */\nfunction last(predicate, resultSelector, defaultValue) {\n    return this.lift(new LastOperator(predicate, resultSelector, defaultValue, this));\n}\nexports.last = last;\nvar LastOperator = (function () {\n    function LastOperator(predicate, resultSelector, defaultValue, source) {\n        this.predicate = predicate;\n        this.resultSelector = resultSelector;\n        this.defaultValue = defaultValue;\n        this.source = source;\n    }\n    LastOperator.prototype.call = function (observer, source) {\n        return source._subscribe(new LastSubscriber(observer, this.predicate, this.resultSelector, this.defaultValue, this.source));\n    };\n    return LastOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar LastSubscriber = (function (_super) {\n    __extends(LastSubscriber, _super);\n    function LastSubscriber(destination, predicate, resultSelector, defaultValue, source) {\n        _super.call(this, destination);\n        this.predicate = predicate;\n        this.resultSelector = resultSelector;\n        this.defaultValue = defaultValue;\n        this.source = source;\n        this.hasValue = false;\n        this.index = 0;\n        if (typeof defaultValue !== 'undefined') {\n            this.lastValue = defaultValue;\n            this.hasValue = true;\n        }\n    }\n    LastSubscriber.prototype._next = function (value) {\n        var index = this.index++;\n        if (this.predicate) {\n            this._tryPredicate(value, index);\n        }\n        else {\n            if (this.resultSelector) {\n                this._tryResultSelector(value, index);\n                return;\n            }\n            this.lastValue = value;\n            this.hasValue = true;\n        }\n    };\n    LastSubscriber.prototype._tryPredicate = function (value, index) {\n        var result;\n        try {\n            result = this.predicate(value, index, this.source);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        if (result) {\n            if (this.resultSelector) {\n                this._tryResultSelector(value, index);\n                return;\n            }\n            this.lastValue = value;\n            this.hasValue = true;\n        }\n    };\n    LastSubscriber.prototype._tryResultSelector = function (value, index) {\n        var result;\n        try {\n            result = this.resultSelector(value, index);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.lastValue = result;\n        this.hasValue = true;\n    };\n    LastSubscriber.prototype._complete = function () {\n        var destination = this.destination;\n        if (this.hasValue) {\n            destination.next(this.lastValue);\n            destination.complete();\n        }\n        else {\n            destination.error(new EmptyError_1.EmptyError);\n        }\n    };\n    return LastSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=last.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/last.js\n ** module id = 229\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/last.js?");

/***/ },
/* 230 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar let_1 = __webpack_require__(231);\nObservable_1.Observable.prototype.let = let_1.letProto;\nObservable_1.Observable.prototype.letBind = let_1.letProto;\n//# sourceMappingURL=let.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/let.js\n ** module id = 230\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/let.js?");

/***/ },
/* 231 */
/***/ function(module, exports) {

	eval("\"use strict\";\n/**\n * @param func\n * @return {Observable<R>}\n * @method let\n * @owner Observable\n */\nfunction letProto(func) {\n    return func(this);\n}\nexports.letProto = letProto;\n//# sourceMappingURL=let.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/let.js\n ** module id = 231\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/let.js?");

/***/ },
/* 232 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar every_1 = __webpack_require__(233);\nObservable_1.Observable.prototype.every = every_1.every;\n//# sourceMappingURL=every.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/every.js\n ** module id = 232\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/every.js?");

/***/ },
/* 233 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(8);\n/**\n * Returns an Observable that emits whether or not every item of the source satisfies the condition specified.\n * @param {function} predicate a function for determining if an item meets a specified condition.\n * @param {any} [thisArg] optional object to use for `this` in the callback\n * @return {Observable} an Observable of booleans that determines if all items of the source Observable meet the condition specified.\n * @method every\n * @owner Observable\n */\nfunction every(predicate, thisArg) {\n    return this.lift(new EveryOperator(predicate, thisArg, this));\n}\nexports.every = every;\nvar EveryOperator = (function () {\n    function EveryOperator(predicate, thisArg, source) {\n        this.predicate = predicate;\n        this.thisArg = thisArg;\n        this.source = source;\n    }\n    EveryOperator.prototype.call = function (observer, source) {\n        return source._subscribe(new EverySubscriber(observer, this.predicate, this.thisArg, this.source));\n    };\n    return EveryOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar EverySubscriber = (function (_super) {\n    __extends(EverySubscriber, _super);\n    function EverySubscriber(destination, predicate, thisArg, source) {\n        _super.call(this, destination);\n        this.predicate = predicate;\n        this.thisArg = thisArg;\n        this.source = source;\n        this.index = 0;\n        this.thisArg = thisArg || this;\n    }\n    EverySubscriber.prototype.notifyComplete = function (everyValueMatch) {\n        this.destination.next(everyValueMatch);\n        this.destination.complete();\n    };\n    EverySubscriber.prototype._next = function (value) {\n        var result = false;\n        try {\n            result = this.predicate.call(this.thisArg, value, this.index++, this.source);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        if (!result) {\n            this.notifyComplete(false);\n        }\n    };\n    EverySubscriber.prototype._complete = function () {\n        this.notifyComplete(true);\n    };\n    return EverySubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=every.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/every.js\n ** module id = 233\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/every.js?");

/***/ },
/* 234 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar map_1 = __webpack_require__(136);\nObservable_1.Observable.prototype.map = map_1.map;\n//# sourceMappingURL=map.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/map.js\n ** module id = 234\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/map.js?");

/***/ },
/* 235 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar mapTo_1 = __webpack_require__(236);\nObservable_1.Observable.prototype.mapTo = mapTo_1.mapTo;\n//# sourceMappingURL=mapTo.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/mapTo.js\n ** module id = 235\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/mapTo.js?");

/***/ },
/* 236 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(8);\n/**\n * Emits the given constant value on the output Observable every time the source\n * Observable emits a value.\n *\n * <span class=\"informal\">Like {@link map}, but it maps every source value to\n * the same output value every time.</span>\n *\n * <img src=\"./img/mapTo.png\" width=\"100%\">\n *\n * Takes a constant `value` as argument, and emits that whenever the source\n * Observable emits a value. In other words, ignores the actual source value,\n * and simply uses the emission moment to know when to emit the given `value`.\n *\n * @example <caption>Map every every click to the string 'Hi'</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var greetings = clicks.mapTo('Hi');\n * greetings.subscribe(x => console.log(x));\n *\n * @see {@link map}\n *\n * @param {any} value The value to map each source value to.\n * @return {Observable} An Observable that emits the given `value` every time\n * the source Observable emits something.\n * @method mapTo\n * @owner Observable\n */\nfunction mapTo(value) {\n    return this.lift(new MapToOperator(value));\n}\nexports.mapTo = mapTo;\nvar MapToOperator = (function () {\n    function MapToOperator(value) {\n        this.value = value;\n    }\n    MapToOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new MapToSubscriber(subscriber, this.value));\n    };\n    return MapToOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar MapToSubscriber = (function (_super) {\n    __extends(MapToSubscriber, _super);\n    function MapToSubscriber(destination, value) {\n        _super.call(this, destination);\n        this.value = value;\n    }\n    MapToSubscriber.prototype._next = function (x) {\n        this.destination.next(this.value);\n    };\n    return MapToSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=mapTo.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/mapTo.js\n ** module id = 236\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/mapTo.js?");

/***/ },
/* 237 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar materialize_1 = __webpack_require__(238);\nObservable_1.Observable.prototype.materialize = materialize_1.materialize;\n//# sourceMappingURL=materialize.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/materialize.js\n ** module id = 237\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/materialize.js?");

/***/ },
/* 238 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(8);\nvar Notification_1 = __webpack_require__(78);\n/**\n * Represents all of the notifications from the source Observable as `next`\n * emissions marked with their original types within {@link Notification}\n * objects.\n *\n * <span class=\"informal\">Wraps `next`, `error` and `complete` emissions in\n * {@link Notification} objects, emitted as `next` on the output Observable.\n * </span>\n *\n * <img src=\"./img/materialize.png\" width=\"100%\">\n *\n * `materialize` returns an Observable that emits a `next` notification for each\n * `next`, `error`, or `complete` emission of the source Observable. When the\n * source Observable emits `complete`, the output Observable will emit `next` as\n * a Notification of type \"complete\", and then it will emit `complete` as well.\n * When the source Observable emits `error`, the output will emit `next` as a\n * Notification of type \"error\", and then `complete`.\n *\n * This operator is useful for producing metadata of the source Observable, to\n * be consumed as `next` emissions. Use it in conjunction with\n * {@link dematerialize}.\n *\n * @example <caption>Convert a faulty Observable to an Observable of Notifications</caption>\n * var letters = Rx.Observable.of('a', 'b', 13, 'd');\n * var upperCase = letters.map(x => x.toUpperCase());\n * var materialized = upperCase.materialize();\n * materialized.subscribe(x => console.log(x));\n *\n * @see {@link Notification}\n * @see {@link dematerialize}\n *\n * @return {Observable<Notification<T>>} An Observable that emits\n * {@link Notification} objects that wrap the original emissions from the source\n * Observable with metadata.\n * @method materialize\n * @owner Observable\n */\nfunction materialize() {\n    return this.lift(new MaterializeOperator());\n}\nexports.materialize = materialize;\nvar MaterializeOperator = (function () {\n    function MaterializeOperator() {\n    }\n    MaterializeOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new MaterializeSubscriber(subscriber));\n    };\n    return MaterializeOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar MaterializeSubscriber = (function (_super) {\n    __extends(MaterializeSubscriber, _super);\n    function MaterializeSubscriber(destination) {\n        _super.call(this, destination);\n    }\n    MaterializeSubscriber.prototype._next = function (value) {\n        this.destination.next(Notification_1.Notification.createNext(value));\n    };\n    MaterializeSubscriber.prototype._error = function (err) {\n        var destination = this.destination;\n        destination.next(Notification_1.Notification.createError(err));\n        destination.complete();\n    };\n    MaterializeSubscriber.prototype._complete = function () {\n        var destination = this.destination;\n        destination.next(Notification_1.Notification.createComplete());\n        destination.complete();\n    };\n    return MaterializeSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=materialize.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/materialize.js\n ** module id = 238\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/materialize.js?");

/***/ },
/* 239 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar max_1 = __webpack_require__(240);\nObservable_1.Observable.prototype.max = max_1.max;\n//# sourceMappingURL=max.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/max.js\n ** module id = 239\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/max.js?");

/***/ },
/* 240 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar reduce_1 = __webpack_require__(241);\n/**\n * The Max operator operates on an Observable that emits numbers (or items that can be evaluated as numbers),\n * and when source Observable completes it emits a single item: the item with the largest number.\n *\n * <img src=\"./img/max.png\" width=\"100%\">\n *\n * @param {Function} optional comparer function that it will use instead of its default to compare the value of two\n * items.\n * @return {Observable} an Observable that emits item with the largest number.\n * @method max\n * @owner Observable\n */\nfunction max(comparer) {\n    var max = (typeof comparer === 'function')\n        ? function (x, y) { return comparer(x, y) > 0 ? x : y; }\n        : function (x, y) { return x > y ? x : y; };\n    return this.lift(new reduce_1.ReduceOperator(max));\n}\nexports.max = max;\n//# sourceMappingURL=max.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/max.js\n ** module id = 240\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/max.js?");

/***/ },
/* 241 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(8);\n/**\n * Applies an accumulator function over the source Observable, and returns the\n * accumulated result when the source completes, given an optional seed value.\n *\n * <span class=\"informal\">Combines together all values emitted on the source,\n * using an accumulator function that knows how to join a new source value into\n * the accumulation from the past.</span>\n *\n * <img src=\"./img/reduce.png\" width=\"100%\">\n *\n * Like\n * [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce),\n * `reduce` applies an `accumulator` function against an accumulation and each\n * value of the source Observable (from the past) to reduce it to a single\n * value, emitted on the output Observable. Note that `reduce` will only emit\n * one value, only when the source Observable completes. It is equivalent to\n * applying operator {@link scan} followed by operator {@link last}.\n *\n * Returns an Observable that applies a specified `accumulator` function to each\n * item emitted by the source Observable. If a `seed` value is specified, then\n * that value will be used as the initial value for the accumulator. If no seed\n * value is specified, the first item of the source is used as the seed.\n *\n * @example <caption>Count the number of click events that happened in 5 seconds</caption>\n * var clicksInFiveSeconds = Rx.Observable.fromEvent(document, 'click')\n *   .takeUntil(Rx.Observable.interval(5000));\n * var ones = clicksInFiveSeconds.mapTo(1);\n * var seed = 0;\n * var count = ones.reduce((acc, one) => acc + one, seed);\n * count.subscribe(x => console.log(x));\n *\n * @see {@link count}\n * @see {@link expand}\n * @see {@link mergeScan}\n * @see {@link scan}\n *\n * @param {function(acc: R, value: T): R} accumulator The accumulator function\n * called on each source value.\n * @param {R} [seed] The initial accumulation value.\n * @return {Observable<R>} An observable of the accumulated values.\n * @return {Observable<R>} An Observable that emits a single value that is the\n * result of accumulating the values emitted by the source Observable.\n * @method reduce\n * @owner Observable\n */\nfunction reduce(accumulator, seed) {\n    return this.lift(new ReduceOperator(accumulator, seed));\n}\nexports.reduce = reduce;\nvar ReduceOperator = (function () {\n    function ReduceOperator(accumulator, seed) {\n        this.accumulator = accumulator;\n        this.seed = seed;\n    }\n    ReduceOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new ReduceSubscriber(subscriber, this.accumulator, this.seed));\n    };\n    return ReduceOperator;\n}());\nexports.ReduceOperator = ReduceOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar ReduceSubscriber = (function (_super) {\n    __extends(ReduceSubscriber, _super);\n    function ReduceSubscriber(destination, accumulator, seed) {\n        _super.call(this, destination);\n        this.accumulator = accumulator;\n        this.hasValue = false;\n        this.acc = seed;\n        this.accumulator = accumulator;\n        this.hasSeed = typeof seed !== 'undefined';\n    }\n    ReduceSubscriber.prototype._next = function (value) {\n        if (this.hasValue || (this.hasValue = this.hasSeed)) {\n            this._tryReduce(value);\n        }\n        else {\n            this.acc = value;\n            this.hasValue = true;\n        }\n    };\n    ReduceSubscriber.prototype._tryReduce = function (value) {\n        var result;\n        try {\n            result = this.accumulator(this.acc, value);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.acc = result;\n    };\n    ReduceSubscriber.prototype._complete = function () {\n        if (this.hasValue || this.hasSeed) {\n            this.destination.next(this.acc);\n        }\n        this.destination.complete();\n    };\n    return ReduceSubscriber;\n}(Subscriber_1.Subscriber));\nexports.ReduceSubscriber = ReduceSubscriber;\n//# sourceMappingURL=reduce.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/reduce.js\n ** module id = 241\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/reduce.js?");

/***/ },
/* 242 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar merge_1 = __webpack_require__(103);\nObservable_1.Observable.prototype.merge = merge_1.merge;\n//# sourceMappingURL=merge.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/merge.js\n ** module id = 242\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/merge.js?");

/***/ },
/* 243 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar mergeAll_1 = __webpack_require__(62);\nObservable_1.Observable.prototype.mergeAll = mergeAll_1.mergeAll;\n//# sourceMappingURL=mergeAll.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/mergeAll.js\n ** module id = 243\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/mergeAll.js?");

/***/ },
/* 244 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar mergeMap_1 = __webpack_require__(167);\nObservable_1.Observable.prototype.mergeMap = mergeMap_1.mergeMap;\nObservable_1.Observable.prototype.flatMap = mergeMap_1.mergeMap;\n//# sourceMappingURL=mergeMap.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/mergeMap.js\n ** module id = 244\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/mergeMap.js?");

/***/ },
/* 245 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar mergeMapTo_1 = __webpack_require__(170);\nObservable_1.Observable.prototype.flatMapTo = mergeMapTo_1.mergeMapTo;\nObservable_1.Observable.prototype.mergeMapTo = mergeMapTo_1.mergeMapTo;\n//# sourceMappingURL=mergeMapTo.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/mergeMapTo.js\n ** module id = 245\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/mergeMapTo.js?");

/***/ },
/* 246 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar mergeScan_1 = __webpack_require__(247);\nObservable_1.Observable.prototype.mergeScan = mergeScan_1.mergeScan;\n//# sourceMappingURL=mergeScan.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/mergeScan.js\n ** module id = 246\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/mergeScan.js?");

/***/ },
/* 247 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar tryCatch_1 = __webpack_require__(13);\nvar errorObject_1 = __webpack_require__(14);\nvar subscribeToResult_1 = __webpack_require__(55);\nvar OuterSubscriber_1 = __webpack_require__(54);\n/**\n * @param project\n * @param seed\n * @param concurrent\n * @return {Observable<R>|WebSocketSubject<T>|Observable<T>}\n * @method mergeScan\n * @owner Observable\n */\nfunction mergeScan(project, seed, concurrent) {\n    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n    return this.lift(new MergeScanOperator(project, seed, concurrent));\n}\nexports.mergeScan = mergeScan;\nvar MergeScanOperator = (function () {\n    function MergeScanOperator(project, seed, concurrent) {\n        this.project = project;\n        this.seed = seed;\n        this.concurrent = concurrent;\n    }\n    MergeScanOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new MergeScanSubscriber(subscriber, this.project, this.seed, this.concurrent));\n    };\n    return MergeScanOperator;\n}());\nexports.MergeScanOperator = MergeScanOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar MergeScanSubscriber = (function (_super) {\n    __extends(MergeScanSubscriber, _super);\n    function MergeScanSubscriber(destination, project, acc, concurrent) {\n        _super.call(this, destination);\n        this.project = project;\n        this.acc = acc;\n        this.concurrent = concurrent;\n        this.hasValue = false;\n        this.hasCompleted = false;\n        this.buffer = [];\n        this.active = 0;\n        this.index = 0;\n    }\n    MergeScanSubscriber.prototype._next = function (value) {\n        if (this.active < this.concurrent) {\n            var index = this.index++;\n            var ish = tryCatch_1.tryCatch(this.project)(this.acc, value);\n            var destination = this.destination;\n            if (ish === errorObject_1.errorObject) {\n                destination.error(errorObject_1.errorObject.e);\n            }\n            else {\n                this.active++;\n                this._innerSub(ish, value, index);\n            }\n        }\n        else {\n            this.buffer.push(value);\n        }\n    };\n    MergeScanSubscriber.prototype._innerSub = function (ish, value, index) {\n        this.add(subscribeToResult_1.subscribeToResult(this, ish, value, index));\n    };\n    MergeScanSubscriber.prototype._complete = function () {\n        this.hasCompleted = true;\n        if (this.active === 0 && this.buffer.length === 0) {\n            if (this.hasValue === false) {\n                this.destination.next(this.acc);\n            }\n            this.destination.complete();\n        }\n    };\n    MergeScanSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        var destination = this.destination;\n        this.acc = innerValue;\n        this.hasValue = true;\n        destination.next(innerValue);\n    };\n    MergeScanSubscriber.prototype.notifyComplete = function (innerSub) {\n        var buffer = this.buffer;\n        this.remove(innerSub);\n        this.active--;\n        if (buffer.length > 0) {\n            this._next(buffer.shift());\n        }\n        else if (this.active === 0 && this.hasCompleted) {\n            if (this.hasValue === false) {\n                this.destination.next(this.acc);\n            }\n            this.destination.complete();\n        }\n    };\n    return MergeScanSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\nexports.MergeScanSubscriber = MergeScanSubscriber;\n//# sourceMappingURL=mergeScan.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/mergeScan.js\n ** module id = 247\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/mergeScan.js?");

/***/ },
/* 248 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar min_1 = __webpack_require__(249);\nObservable_1.Observable.prototype.min = min_1.min;\n//# sourceMappingURL=min.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/min.js\n ** module id = 248\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/min.js?");

/***/ },
/* 249 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar reduce_1 = __webpack_require__(241);\n/**\n * The Min operator operates on an Observable that emits numbers (or items that can be evaluated as numbers),\n * and when source Observable completes it emits a single item: the item with the smallest number.\n *\n * <img src=\"./img/min.png\" width=\"100%\">\n *\n * @param {Function} optional comparer function that it will use instead of its default to compare the value of two items.\n * @return {Observable<R>} an Observable that emits item with the smallest number.\n * @method min\n * @owner Observable\n */\nfunction min(comparer) {\n    var min = (typeof comparer === 'function')\n        ? function (x, y) { return comparer(x, y) < 0 ? x : y; }\n        : function (x, y) { return x < y ? x : y; };\n    return this.lift(new reduce_1.ReduceOperator(min));\n}\nexports.min = min;\n//# sourceMappingURL=min.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/min.js\n ** module id = 249\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/min.js?");

/***/ },
/* 250 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar multicast_1 = __webpack_require__(251);\nObservable_1.Observable.prototype.multicast = multicast_1.multicast;\n//# sourceMappingURL=multicast.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/multicast.js\n ** module id = 250\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/multicast.js?");

/***/ },
/* 251 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar MulticastObservable_1 = __webpack_require__(252);\nvar ConnectableObservable_1 = __webpack_require__(253);\n/**\n * Returns an Observable that emits the results of invoking a specified selector on items\n * emitted by a ConnectableObservable that shares a single subscription to the underlying stream.\n *\n * <img src=\"./img/multicast.png\" width=\"100%\">\n *\n * @param {Function|Subject} Factory function to create an intermediate subject through\n * which the source sequence's elements will be multicast to the selector function\n * or Subject to push source elements into.\n * @param {Function} Optional selector function that can use the multicasted source stream\n * as many times as needed, without causing multiple subscriptions to the source stream.\n * Subscribers to the given source will receive all notifications of the source from the\n * time of the subscription forward.\n * @return {Observable} an Observable that emits the results of invoking the selector\n * on the items emitted by a `ConnectableObservable` that shares a single subscription to\n * the underlying stream.\n * @method multicast\n * @owner Observable\n */\nfunction multicast(subjectOrSubjectFactory, selector) {\n    var subjectFactory;\n    if (typeof subjectOrSubjectFactory === 'function') {\n        subjectFactory = subjectOrSubjectFactory;\n    }\n    else {\n        subjectFactory = function subjectFactory() {\n            return subjectOrSubjectFactory;\n        };\n    }\n    return !selector ?\n        new ConnectableObservable_1.ConnectableObservable(this, subjectFactory) :\n        new MulticastObservable_1.MulticastObservable(this, subjectFactory, selector);\n}\nexports.multicast = multicast;\n//# sourceMappingURL=multicast.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/multicast.js\n ** module id = 251\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/multicast.js?");

/***/ },
/* 252 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = __webpack_require__(5);\nvar ConnectableObservable_1 = __webpack_require__(253);\nvar MulticastObservable = (function (_super) {\n    __extends(MulticastObservable, _super);\n    function MulticastObservable(source, subjectFactory, selector) {\n        _super.call(this);\n        this.source = source;\n        this.subjectFactory = subjectFactory;\n        this.selector = selector;\n    }\n    MulticastObservable.prototype._subscribe = function (subscriber) {\n        var _a = this, selector = _a.selector, source = _a.source;\n        var connectable = new ConnectableObservable_1.ConnectableObservable(source, this.subjectFactory);\n        var subscription = selector(connectable).subscribe(subscriber);\n        subscription.add(connectable.connect());\n        return subscription;\n    };\n    return MulticastObservable;\n}(Observable_1.Observable));\nexports.MulticastObservable = MulticastObservable;\n//# sourceMappingURL=MulticastObservable.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/observable/MulticastObservable.js\n ** module id = 252\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/observable/MulticastObservable.js?");

/***/ },
/* 253 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = __webpack_require__(4);\nvar Observable_1 = __webpack_require__(5);\nvar Subscriber_1 = __webpack_require__(8);\nvar Subscription_1 = __webpack_require__(10);\n/**\n * @class ConnectableObservable<T>\n */\nvar ConnectableObservable = (function (_super) {\n    __extends(ConnectableObservable, _super);\n    function ConnectableObservable(source, subjectFactory) {\n        _super.call(this);\n        this.source = source;\n        this.subjectFactory = subjectFactory;\n        this._refCount = 0;\n    }\n    ConnectableObservable.prototype._subscribe = function (subscriber) {\n        return this.getSubject().subscribe(subscriber);\n    };\n    ConnectableObservable.prototype.getSubject = function () {\n        var subject = this._subject;\n        if (!subject || subject.isStopped) {\n            this._subject = this.subjectFactory();\n        }\n        return this._subject;\n    };\n    ConnectableObservable.prototype.connect = function () {\n        var connection = this._connection;\n        if (!connection) {\n            connection = this._connection = new Subscription_1.Subscription();\n            connection.add(this.source\n                .subscribe(new ConnectableSubscriber(this.getSubject(), this)));\n            if (connection.closed) {\n                this._connection = null;\n                connection = Subscription_1.Subscription.EMPTY;\n            }\n            else {\n                this._connection = connection;\n            }\n        }\n        return connection;\n    };\n    ConnectableObservable.prototype.refCount = function () {\n        return this.lift(new RefCountOperator(this));\n    };\n    return ConnectableObservable;\n}(Observable_1.Observable));\nexports.ConnectableObservable = ConnectableObservable;\nvar ConnectableSubscriber = (function (_super) {\n    __extends(ConnectableSubscriber, _super);\n    function ConnectableSubscriber(destination, connectable) {\n        _super.call(this, destination);\n        this.connectable = connectable;\n    }\n    ConnectableSubscriber.prototype._error = function (err) {\n        this._unsubscribe();\n        _super.prototype._error.call(this, err);\n    };\n    ConnectableSubscriber.prototype._complete = function () {\n        this._unsubscribe();\n        _super.prototype._complete.call(this);\n    };\n    ConnectableSubscriber.prototype._unsubscribe = function () {\n        var connectable = this.connectable;\n        if (connectable) {\n            this.connectable = null;\n            var connection = connectable._connection;\n            connectable._refCount = 0;\n            connectable._subject = null;\n            connectable._connection = null;\n            if (connection) {\n                connection.unsubscribe();\n            }\n        }\n    };\n    return ConnectableSubscriber;\n}(Subject_1.SubjectSubscriber));\nvar RefCountOperator = (function () {\n    function RefCountOperator(connectable) {\n        this.connectable = connectable;\n    }\n    RefCountOperator.prototype.call = function (subscriber, source) {\n        var connectable = this.connectable;\n        connectable._refCount++;\n        var refCounter = new RefCountSubscriber(subscriber, connectable);\n        var subscription = source._subscribe(refCounter);\n        if (!refCounter.closed) {\n            refCounter.connection = connectable.connect();\n        }\n        return subscription;\n    };\n    return RefCountOperator;\n}());\nvar RefCountSubscriber = (function (_super) {\n    __extends(RefCountSubscriber, _super);\n    function RefCountSubscriber(destination, connectable) {\n        _super.call(this, destination);\n        this.connectable = connectable;\n    }\n    RefCountSubscriber.prototype._unsubscribe = function () {\n        var connectable = this.connectable;\n        if (!connectable) {\n            this.connection = null;\n            return;\n        }\n        this.connectable = null;\n        var refCount = connectable._refCount;\n        if (refCount <= 0) {\n            this.connection = null;\n            return;\n        }\n        connectable._refCount = refCount - 1;\n        if (refCount > 1) {\n            this.connection = null;\n            return;\n        }\n        ///\n        // Compare the local RefCountSubscriber's connection Subscription to the\n        // connection Subscription on the shared ConnectableObservable. In cases\n        // where the ConnectableObservable source synchronously emits values, and\n        // the RefCountSubscriber's dowstream Observers synchronously unsubscribe,\n        // execution continues to here before the RefCountOperator has a chance to\n        // supply the RefCountSubscriber with the shared connection Subscription.\n        // For example:\n        // ```\n        // Observable.range(0, 10)\n        //   .publish()\n        //   .refCount()\n        //   .take(5)\n        //   .subscribe();\n        // ```\n        // In order to account for this case, RefCountSubscriber should only dispose\n        // the ConnectableObservable's shared connection Subscription if the\n        // connection Subscription exists, *and* either:\n        //   a. RefCountSubscriber doesn't have a reference to the shared connection\n        //      Subscription yet, or,\n        //   b. RefCountSubscriber's connection Subscription reference is identical\n        //      to the shared connection Subscription\n        ///\n        var connection = this.connection;\n        var sharedConnection = connectable._connection;\n        this.connection = null;\n        if (sharedConnection && (!connection || sharedConnection === connection)) {\n            sharedConnection.unsubscribe();\n        }\n    };\n    return RefCountSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=ConnectableObservable.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/observable/ConnectableObservable.js\n ** module id = 253\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/observable/ConnectableObservable.js?");

/***/ },
/* 254 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar observeOn_1 = __webpack_require__(77);\nObservable_1.Observable.prototype.observeOn = observeOn_1.observeOn;\n//# sourceMappingURL=observeOn.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/observeOn.js\n ** module id = 254\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/observeOn.js?");

/***/ },
/* 255 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar onErrorResumeNext_1 = __webpack_require__(113);\nObservable_1.Observable.prototype.onErrorResumeNext = onErrorResumeNext_1.onErrorResumeNext;\n//# sourceMappingURL=onErrorResumeNext.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/onErrorResumeNext.js\n ** module id = 255\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/onErrorResumeNext.js?");

/***/ },
/* 256 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar pairwise_1 = __webpack_require__(257);\nObservable_1.Observable.prototype.pairwise = pairwise_1.pairwise;\n//# sourceMappingURL=pairwise.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/pairwise.js\n ** module id = 256\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/pairwise.js?");

/***/ },
/* 257 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(8);\n/**\n * Groups pairs of consecutive emissions together and emits them as an array of\n * two values.\n *\n * <span class=\"informal\">Puts the current value and previous value together as\n * an array, and emits that.</span>\n *\n * <img src=\"./img/pairwise.png\" width=\"100%\">\n *\n * The Nth emission from the source Observable will cause the output Observable\n * to emit an array [(N-1)th, Nth] of the previous and the current value, as a\n * pair. For this reason, `pairwise` emits on the second and subsequent\n * emissions from the source Observable, but not on the first emission, because\n * there is no previous value in that case.\n *\n * @example <caption>On every click (starting from the second), emit the relative distance to the previous click</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var pairs = clicks.pairwise();\n * var distance = pairs.map(pair => {\n *   var x0 = pair[0].clientX;\n *   var y0 = pair[0].clientY;\n *   var x1 = pair[1].clientX;\n *   var y1 = pair[1].clientY;\n *   return Math.sqrt(Math.pow(x0 - x1, 2) + Math.pow(y0 - y1, 2));\n * });\n * distance.subscribe(x => console.log(x));\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n *\n * @return {Observable<Array<T>>} An Observable of pairs (as arrays) of\n * consecutive values from the source Observable.\n * @method pairwise\n * @owner Observable\n */\nfunction pairwise() {\n    return this.lift(new PairwiseOperator());\n}\nexports.pairwise = pairwise;\nvar PairwiseOperator = (function () {\n    function PairwiseOperator() {\n    }\n    PairwiseOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new PairwiseSubscriber(subscriber));\n    };\n    return PairwiseOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar PairwiseSubscriber = (function (_super) {\n    __extends(PairwiseSubscriber, _super);\n    function PairwiseSubscriber(destination) {\n        _super.call(this, destination);\n        this.hasPrev = false;\n    }\n    PairwiseSubscriber.prototype._next = function (value) {\n        if (this.hasPrev) {\n            this.destination.next([this.prev, value]);\n        }\n        else {\n            this.hasPrev = true;\n        }\n        this.prev = value;\n    };\n    return PairwiseSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=pairwise.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/pairwise.js\n ** module id = 257\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/pairwise.js?");

/***/ },
/* 258 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar partition_1 = __webpack_require__(259);\nObservable_1.Observable.prototype.partition = partition_1.partition;\n//# sourceMappingURL=partition.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/partition.js\n ** module id = 258\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/partition.js?");

/***/ },
/* 259 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar not_1 = __webpack_require__(260);\nvar filter_1 = __webpack_require__(205);\n/**\n * Splits the source Observable into two, one with values that satisfy a\n * predicate, and another with values that don't satisfy the predicate.\n *\n * <span class=\"informal\">It's like {@link filter}, but returns two Observables:\n * one like the output of {@link filter}, and the other with values that did not\n * pass the condition.</span>\n *\n * <img src=\"./img/partition.png\" width=\"100%\">\n *\n * `partition` outputs an array with two Observables that partition the values\n * from the source Observable through the given `predicate` function. The first\n * Observable in that array emits source values for which the predicate argument\n * returns true. The second Observable emits source values for which the\n * predicate returns false. The first behaves like {@link filter} and the second\n * behaves like {@link filter} with the predicate negated.\n *\n * @example <caption>Partition click events into those on DIV elements and those elsewhere</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var parts = clicks.partition(ev => ev.target.tagName === 'DIV');\n * var clicksOnDivs = parts[0];\n * var clicksElsewhere = parts[1];\n * clicksOnDivs.subscribe(x => console.log('DIV clicked: ', x));\n * clicksElsewhere.subscribe(x => console.log('Other clicked: ', x));\n *\n * @see {@link filter}\n *\n * @param {function(value: T, index: number): boolean} predicate A function that\n * evaluates each value emitted by the source Observable. If it returns `true`,\n * the value is emitted on the first Observable in the returned array, if\n * `false` the value is emitted on the second Observable in the array. The\n * `index` parameter is the number `i` for the i-th source emission that has\n * happened since the subscription, starting from the number `0`.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {[Observable<T>, Observable<T>]} An array with two Observables: one\n * with values that passed the predicate, and another with values that did not\n * pass the predicate.\n * @method partition\n * @owner Observable\n */\nfunction partition(predicate, thisArg) {\n    return [\n        filter_1.filter.call(this, predicate),\n        filter_1.filter.call(this, not_1.not(predicate, thisArg))\n    ];\n}\nexports.partition = partition;\n//# sourceMappingURL=partition.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/partition.js\n ** module id = 259\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/partition.js?");

/***/ },
/* 260 */
/***/ function(module, exports) {

	eval("\"use strict\";\nfunction not(pred, thisArg) {\n    function notPred() {\n        return !(notPred.pred.apply(notPred.thisArg, arguments));\n    }\n    notPred.pred = pred;\n    notPred.thisArg = thisArg;\n    return notPred;\n}\nexports.not = not;\n//# sourceMappingURL=not.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/util/not.js\n ** module id = 260\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/util/not.js?");

/***/ },
/* 261 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar pluck_1 = __webpack_require__(262);\nObservable_1.Observable.prototype.pluck = pluck_1.pluck;\n//# sourceMappingURL=pluck.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/pluck.js\n ** module id = 261\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/pluck.js?");

/***/ },
/* 262 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar map_1 = __webpack_require__(136);\n/**\n * Maps each source value (an object) to its specified nested property.\n *\n * <span class=\"informal\">Like {@link map}, but meant only for picking one of\n * the nested properties of every emitted object.</span>\n *\n * <img src=\"./img/pluck.png\" width=\"100%\">\n *\n * Given a list of strings describing a path to an object property, retrieves\n * the value of a specified nested property from all values in the source\n * Observable. If a property can't be resolved, it will return `undefined` for\n * that value.\n *\n * @example <caption>Map every every click to the tagName of the clicked target element</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var tagNames = clicks.pluck('target', 'tagName');\n * tagNames.subscribe(x => console.log(x));\n *\n * @see {@link map}\n *\n * @param {...string} properties The nested properties to pluck from each source\n * value (an object).\n * @return {Observable} Returns a new Observable of property values from the\n * source values.\n * @method pluck\n * @owner Observable\n */\nfunction pluck() {\n    var properties = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        properties[_i - 0] = arguments[_i];\n    }\n    var length = properties.length;\n    if (length === 0) {\n        throw new Error('list of properties cannot be empty.');\n    }\n    return map_1.map.call(this, plucker(properties, length));\n}\nexports.pluck = pluck;\nfunction plucker(props, length) {\n    var mapper = function (x) {\n        var currentProp = x;\n        for (var i = 0; i < length; i++) {\n            var p = currentProp[props[i]];\n            if (typeof p !== 'undefined') {\n                currentProp = p;\n            }\n            else {\n                return undefined;\n            }\n        }\n        return currentProp;\n    };\n    return mapper;\n}\n//# sourceMappingURL=pluck.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/pluck.js\n ** module id = 262\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/pluck.js?");

/***/ },
/* 263 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar publish_1 = __webpack_require__(264);\nObservable_1.Observable.prototype.publish = publish_1.publish;\n//# sourceMappingURL=publish.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/publish.js\n ** module id = 263\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/publish.js?");

/***/ },
/* 264 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Subject_1 = __webpack_require__(4);\nvar multicast_1 = __webpack_require__(251);\n/**\n * Returns a ConnectableObservable, which is a variety of Observable that waits until its connect method is called\n * before it begins emitting items to those Observers that have subscribed to it.\n *\n * <img src=\"./img/publish.png\" width=\"100%\">\n *\n * @param {Function} Optional selector function which can use the multicasted source sequence as many times as needed,\n * without causing multiple subscriptions to the source sequence.\n * Subscribers to the given source will receive all notifications of the source from the time of the subscription on.\n * @return a ConnectableObservable that upon connection causes the source Observable to emit items to its Observers.\n * @method publish\n * @owner Observable\n */\nfunction publish(selector) {\n    return selector ? multicast_1.multicast.call(this, function () { return new Subject_1.Subject(); }, selector) :\n        multicast_1.multicast.call(this, new Subject_1.Subject());\n}\nexports.publish = publish;\n//# sourceMappingURL=publish.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/publish.js\n ** module id = 264\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/publish.js?");

/***/ },
/* 265 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar publishBehavior_1 = __webpack_require__(266);\nObservable_1.Observable.prototype.publishBehavior = publishBehavior_1.publishBehavior;\n//# sourceMappingURL=publishBehavior.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/publishBehavior.js\n ** module id = 265\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/publishBehavior.js?");

/***/ },
/* 266 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar BehaviorSubject_1 = __webpack_require__(267);\nvar multicast_1 = __webpack_require__(251);\n/**\n * @param value\n * @return {ConnectableObservable<T>}\n * @method publishBehavior\n * @owner Observable\n */\nfunction publishBehavior(value) {\n    return multicast_1.multicast.call(this, new BehaviorSubject_1.BehaviorSubject(value));\n}\nexports.publishBehavior = publishBehavior;\n//# sourceMappingURL=publishBehavior.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/publishBehavior.js\n ** module id = 266\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/publishBehavior.js?");

/***/ },
/* 267 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = __webpack_require__(4);\nvar ObjectUnsubscribedError_1 = __webpack_require__(19);\n/**\n * @class BehaviorSubject<T>\n */\nvar BehaviorSubject = (function (_super) {\n    __extends(BehaviorSubject, _super);\n    function BehaviorSubject(_value) {\n        _super.call(this);\n        this._value = _value;\n    }\n    Object.defineProperty(BehaviorSubject.prototype, \"value\", {\n        get: function () {\n            return this.getValue();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    BehaviorSubject.prototype._subscribe = function (subscriber) {\n        var subscription = _super.prototype._subscribe.call(this, subscriber);\n        if (subscription && !subscription.closed) {\n            subscriber.next(this._value);\n        }\n        return subscription;\n    };\n    BehaviorSubject.prototype.getValue = function () {\n        if (this.hasError) {\n            throw this.thrownError;\n        }\n        else if (this.closed) {\n            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n        }\n        else {\n            return this._value;\n        }\n    };\n    BehaviorSubject.prototype.next = function (value) {\n        _super.prototype.next.call(this, this._value = value);\n    };\n    return BehaviorSubject;\n}(Subject_1.Subject));\nexports.BehaviorSubject = BehaviorSubject;\n//# sourceMappingURL=BehaviorSubject.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/BehaviorSubject.js\n ** module id = 267\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/BehaviorSubject.js?");

/***/ },
/* 268 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar publishReplay_1 = __webpack_require__(269);\nObservable_1.Observable.prototype.publishReplay = publishReplay_1.publishReplay;\n//# sourceMappingURL=publishReplay.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/publishReplay.js\n ** module id = 268\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/publishReplay.js?");

/***/ },
/* 269 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar ReplaySubject_1 = __webpack_require__(140);\nvar multicast_1 = __webpack_require__(251);\n/**\n * @param bufferSize\n * @param windowTime\n * @param scheduler\n * @return {ConnectableObservable<T>}\n * @method publishReplay\n * @owner Observable\n */\nfunction publishReplay(bufferSize, windowTime, scheduler) {\n    if (bufferSize === void 0) { bufferSize = Number.POSITIVE_INFINITY; }\n    if (windowTime === void 0) { windowTime = Number.POSITIVE_INFINITY; }\n    return multicast_1.multicast.call(this, new ReplaySubject_1.ReplaySubject(bufferSize, windowTime, scheduler));\n}\nexports.publishReplay = publishReplay;\n//# sourceMappingURL=publishReplay.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/publishReplay.js\n ** module id = 269\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/publishReplay.js?");

/***/ },
/* 270 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar publishLast_1 = __webpack_require__(271);\nObservable_1.Observable.prototype.publishLast = publishLast_1.publishLast;\n//# sourceMappingURL=publishLast.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/publishLast.js\n ** module id = 270\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/publishLast.js?");

/***/ },
/* 271 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar AsyncSubject_1 = __webpack_require__(43);\nvar multicast_1 = __webpack_require__(251);\n/**\n * @return {ConnectableObservable<T>}\n * @method publishLast\n * @owner Observable\n */\nfunction publishLast() {\n    return multicast_1.multicast.call(this, new AsyncSubject_1.AsyncSubject());\n}\nexports.publishLast = publishLast;\n//# sourceMappingURL=publishLast.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/publishLast.js\n ** module id = 271\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/publishLast.js?");

/***/ },
/* 272 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar race_1 = __webpack_require__(105);\nObservable_1.Observable.prototype.race = race_1.race;\n//# sourceMappingURL=race.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/race.js\n ** module id = 272\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/race.js?");

/***/ },
/* 273 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar reduce_1 = __webpack_require__(241);\nObservable_1.Observable.prototype.reduce = reduce_1.reduce;\n//# sourceMappingURL=reduce.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/reduce.js\n ** module id = 273\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/reduce.js?");

/***/ },
/* 274 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar repeat_1 = __webpack_require__(275);\nObservable_1.Observable.prototype.repeat = repeat_1.repeat;\n//# sourceMappingURL=repeat.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/repeat.js\n ** module id = 274\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/repeat.js?");

/***/ },
/* 275 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(8);\nvar EmptyObservable_1 = __webpack_require__(52);\n/**\n * Returns an Observable that repeats the stream of items emitted by the source Observable at most count times,\n * on a particular Scheduler.\n *\n * <img src=\"./img/repeat.png\" width=\"100%\">\n *\n * @param {Scheduler} [scheduler] the Scheduler to emit the items on.\n * @param {number} [count] the number of times the source Observable items are repeated, a count of 0 will yield\n * an empty Observable.\n * @return {Observable} an Observable that repeats the stream of items emitted by the source Observable at most\n * count times.\n * @method repeat\n * @owner Observable\n */\nfunction repeat(count) {\n    if (count === void 0) { count = -1; }\n    if (count === 0) {\n        return new EmptyObservable_1.EmptyObservable();\n    }\n    else if (count < 0) {\n        return this.lift(new RepeatOperator(-1, this));\n    }\n    else {\n        return this.lift(new RepeatOperator(count - 1, this));\n    }\n}\nexports.repeat = repeat;\nvar RepeatOperator = (function () {\n    function RepeatOperator(count, source) {\n        this.count = count;\n        this.source = source;\n    }\n    RepeatOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new RepeatSubscriber(subscriber, this.count, this.source));\n    };\n    return RepeatOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar RepeatSubscriber = (function (_super) {\n    __extends(RepeatSubscriber, _super);\n    function RepeatSubscriber(destination, count, source) {\n        _super.call(this, destination);\n        this.count = count;\n        this.source = source;\n    }\n    RepeatSubscriber.prototype.complete = function () {\n        if (!this.isStopped) {\n            var _a = this, source = _a.source, count = _a.count;\n            if (count === 0) {\n                return _super.prototype.complete.call(this);\n            }\n            else if (count > -1) {\n                this.count = count - 1;\n            }\n            this.unsubscribe();\n            this.isStopped = false;\n            this.closed = false;\n            source.subscribe(this);\n        }\n    };\n    return RepeatSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=repeat.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/repeat.js\n ** module id = 275\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/repeat.js?");

/***/ },
/* 276 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar repeatWhen_1 = __webpack_require__(277);\nObservable_1.Observable.prototype.repeatWhen = repeatWhen_1.repeatWhen;\n//# sourceMappingURL=repeatWhen.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/repeatWhen.js\n ** module id = 276\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/repeatWhen.js?");

/***/ },
/* 277 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = __webpack_require__(4);\nvar tryCatch_1 = __webpack_require__(13);\nvar errorObject_1 = __webpack_require__(14);\nvar OuterSubscriber_1 = __webpack_require__(54);\nvar subscribeToResult_1 = __webpack_require__(55);\n/**\n * Returns an Observable that emits the same values as the source observable with the exception of a `complete`.\n * A `complete` will cause the emission of the Throwable that cause the complete to the Observable returned from\n * notificationHandler. If that Observable calls onComplete or `complete` then retry will call `complete` or `error`\n * on the child subscription. Otherwise, this Observable will resubscribe to the source observable, on a particular\n * Scheduler.\n *\n * <img src=\"./img/repeatWhen.png\" width=\"100%\">\n *\n * @param {notificationHandler} receives an Observable of notifications with which a user can `complete` or `error`,\n * aborting the retry.\n * @param {scheduler} the Scheduler on which to subscribe to the source Observable.\n * @return {Observable} the source Observable modified with retry logic.\n * @method repeatWhen\n * @owner Observable\n */\nfunction repeatWhen(notifier) {\n    return this.lift(new RepeatWhenOperator(notifier, this));\n}\nexports.repeatWhen = repeatWhen;\nvar RepeatWhenOperator = (function () {\n    function RepeatWhenOperator(notifier, source) {\n        this.notifier = notifier;\n        this.source = source;\n    }\n    RepeatWhenOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new RepeatWhenSubscriber(subscriber, this.notifier, this.source));\n    };\n    return RepeatWhenOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar RepeatWhenSubscriber = (function (_super) {\n    __extends(RepeatWhenSubscriber, _super);\n    function RepeatWhenSubscriber(destination, notifier, source) {\n        _super.call(this, destination);\n        this.notifier = notifier;\n        this.source = source;\n    }\n    RepeatWhenSubscriber.prototype.complete = function () {\n        if (!this.isStopped) {\n            var notifications = this.notifications;\n            var retries = this.retries;\n            var retriesSubscription = this.retriesSubscription;\n            if (!retries) {\n                notifications = new Subject_1.Subject();\n                retries = tryCatch_1.tryCatch(this.notifier)(notifications);\n                if (retries === errorObject_1.errorObject) {\n                    return _super.prototype.complete.call(this);\n                }\n                retriesSubscription = subscribeToResult_1.subscribeToResult(this, retries);\n            }\n            else {\n                this.notifications = null;\n                this.retriesSubscription = null;\n            }\n            this.unsubscribe();\n            this.closed = false;\n            this.notifications = notifications;\n            this.retries = retries;\n            this.retriesSubscription = retriesSubscription;\n            notifications.next();\n        }\n    };\n    RepeatWhenSubscriber.prototype._unsubscribe = function () {\n        var _a = this, notifications = _a.notifications, retriesSubscription = _a.retriesSubscription;\n        if (notifications) {\n            notifications.unsubscribe();\n            this.notifications = null;\n        }\n        if (retriesSubscription) {\n            retriesSubscription.unsubscribe();\n            this.retriesSubscription = null;\n        }\n        this.retries = null;\n    };\n    RepeatWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        var _a = this, notifications = _a.notifications, retries = _a.retries, retriesSubscription = _a.retriesSubscription;\n        this.notifications = null;\n        this.retries = null;\n        this.retriesSubscription = null;\n        this.unsubscribe();\n        this.isStopped = false;\n        this.closed = false;\n        this.notifications = notifications;\n        this.retries = retries;\n        this.retriesSubscription = retriesSubscription;\n        this.source.subscribe(this);\n    };\n    return RepeatWhenSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=repeatWhen.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/repeatWhen.js\n ** module id = 277\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/repeatWhen.js?");

/***/ },
/* 278 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar retry_1 = __webpack_require__(279);\nObservable_1.Observable.prototype.retry = retry_1.retry;\n//# sourceMappingURL=retry.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/retry.js\n ** module id = 278\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/retry.js?");

/***/ },
/* 279 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(8);\n/**\n * Returns an Observable that mirrors the source Observable, resubscribing to it if it calls `error` and the\n * predicate returns true for that specific exception and retry count.\n * If the source Observable calls `error`, this method will resubscribe to the source Observable for a maximum of\n * count resubscriptions (given as a number parameter) rather than propagating the `error` call.\n *\n * <img src=\"./img/retry.png\" width=\"100%\">\n *\n * Any and all items emitted by the source Observable will be emitted by the resulting Observable, even those emitted\n * during failed subscriptions. For example, if an Observable fails at first but emits [1, 2] then succeeds the second\n * time and emits: [1, 2, 3, 4, 5] then the complete stream of emissions and notifications\n * would be: [1, 2, 1, 2, 3, 4, 5, `complete`].\n * @param {number} number of retry attempts before failing.\n * @return {Observable} the source Observable modified with the retry logic.\n * @method retry\n * @owner Observable\n */\nfunction retry(count) {\n    if (count === void 0) { count = -1; }\n    return this.lift(new RetryOperator(count, this));\n}\nexports.retry = retry;\nvar RetryOperator = (function () {\n    function RetryOperator(count, source) {\n        this.count = count;\n        this.source = source;\n    }\n    RetryOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new RetrySubscriber(subscriber, this.count, this.source));\n    };\n    return RetryOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar RetrySubscriber = (function (_super) {\n    __extends(RetrySubscriber, _super);\n    function RetrySubscriber(destination, count, source) {\n        _super.call(this, destination);\n        this.count = count;\n        this.source = source;\n    }\n    RetrySubscriber.prototype.error = function (err) {\n        if (!this.isStopped) {\n            var _a = this, source = _a.source, count = _a.count;\n            if (count === 0) {\n                return _super.prototype.error.call(this, err);\n            }\n            else if (count > -1) {\n                this.count = count - 1;\n            }\n            this.unsubscribe();\n            this.isStopped = false;\n            this.closed = false;\n            source.subscribe(this);\n        }\n    };\n    return RetrySubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=retry.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/retry.js\n ** module id = 279\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/retry.js?");

/***/ },
/* 280 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar retryWhen_1 = __webpack_require__(281);\nObservable_1.Observable.prototype.retryWhen = retryWhen_1.retryWhen;\n//# sourceMappingURL=retryWhen.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/retryWhen.js\n ** module id = 280\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/retryWhen.js?");

/***/ },
/* 281 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = __webpack_require__(4);\nvar tryCatch_1 = __webpack_require__(13);\nvar errorObject_1 = __webpack_require__(14);\nvar OuterSubscriber_1 = __webpack_require__(54);\nvar subscribeToResult_1 = __webpack_require__(55);\n/**\n * Returns an Observable that emits the same values as the source observable with the exception of an `error`.\n * An `error` will cause the emission of the Throwable that cause the error to the Observable returned from\n * notificationHandler. If that Observable calls onComplete or `error` then retry will call `complete` or `error`\n * on the child subscription. Otherwise, this Observable will resubscribe to the source observable, on a particular\n * Scheduler.\n *\n * <img src=\"./img/retryWhen.png\" width=\"100%\">\n *\n * @param {notificationHandler} receives an Observable of notifications with which a user can `complete` or `error`,\n * aborting the retry.\n * @param {scheduler} the Scheduler on which to subscribe to the source Observable.\n * @return {Observable} the source Observable modified with retry logic.\n * @method retryWhen\n * @owner Observable\n */\nfunction retryWhen(notifier) {\n    return this.lift(new RetryWhenOperator(notifier, this));\n}\nexports.retryWhen = retryWhen;\nvar RetryWhenOperator = (function () {\n    function RetryWhenOperator(notifier, source) {\n        this.notifier = notifier;\n        this.source = source;\n    }\n    RetryWhenOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new RetryWhenSubscriber(subscriber, this.notifier, this.source));\n    };\n    return RetryWhenOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar RetryWhenSubscriber = (function (_super) {\n    __extends(RetryWhenSubscriber, _super);\n    function RetryWhenSubscriber(destination, notifier, source) {\n        _super.call(this, destination);\n        this.notifier = notifier;\n        this.source = source;\n    }\n    RetryWhenSubscriber.prototype.error = function (err) {\n        if (!this.isStopped) {\n            var errors = this.errors;\n            var retries = this.retries;\n            var retriesSubscription = this.retriesSubscription;\n            if (!retries) {\n                errors = new Subject_1.Subject();\n                retries = tryCatch_1.tryCatch(this.notifier)(errors);\n                if (retries === errorObject_1.errorObject) {\n                    return _super.prototype.error.call(this, errorObject_1.errorObject.e);\n                }\n                retriesSubscription = subscribeToResult_1.subscribeToResult(this, retries);\n            }\n            else {\n                this.errors = null;\n                this.retriesSubscription = null;\n            }\n            this.unsubscribe();\n            this.closed = false;\n            this.errors = errors;\n            this.retries = retries;\n            this.retriesSubscription = retriesSubscription;\n            errors.next(err);\n        }\n    };\n    RetryWhenSubscriber.prototype._unsubscribe = function () {\n        var _a = this, errors = _a.errors, retriesSubscription = _a.retriesSubscription;\n        if (errors) {\n            errors.unsubscribe();\n            this.errors = null;\n        }\n        if (retriesSubscription) {\n            retriesSubscription.unsubscribe();\n            this.retriesSubscription = null;\n        }\n        this.retries = null;\n    };\n    RetryWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        var _a = this, errors = _a.errors, retries = _a.retries, retriesSubscription = _a.retriesSubscription;\n        this.errors = null;\n        this.retries = null;\n        this.retriesSubscription = null;\n        this.unsubscribe();\n        this.isStopped = false;\n        this.closed = false;\n        this.errors = errors;\n        this.retries = retries;\n        this.retriesSubscription = retriesSubscription;\n        this.source.subscribe(this);\n    };\n    return RetryWhenSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=retryWhen.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/retryWhen.js\n ** module id = 281\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/retryWhen.js?");

/***/ },
/* 282 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar sample_1 = __webpack_require__(283);\nObservable_1.Observable.prototype.sample = sample_1.sample;\n//# sourceMappingURL=sample.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/sample.js\n ** module id = 282\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/sample.js?");

/***/ },
/* 283 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = __webpack_require__(54);\nvar subscribeToResult_1 = __webpack_require__(55);\n/**\n * Emits the most recently emitted value from the source Observable whenever\n * another Observable, the `notifier`, emits.\n *\n * <span class=\"informal\">It's like {@link sampleTime}, but samples whenever\n * the `notifier` Observable emits something.</span>\n *\n * <img src=\"./img/sample.png\" width=\"100%\">\n *\n * Whenever the `notifier` Observable emits a value or completes, `sample`\n * looks at the source Observable and emits whichever value it has most recently\n * emitted since the previous sampling, unless the source has not emitted\n * anything since the previous sampling. The `notifier` is subscribed to as soon\n * as the output Observable is subscribed.\n *\n * @example <caption>On every click, sample the most recent \"seconds\" timer</caption>\n * var seconds = Rx.Observable.interval(1000);\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = seconds.sample(clicks);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link audit}\n * @see {@link debounce}\n * @see {@link sampleTime}\n * @see {@link throttle}\n *\n * @param {Observable<any>} notifier The Observable to use for sampling the\n * source Observable.\n * @return {Observable<T>} An Observable that emits the results of sampling the\n * values emitted by the source Observable whenever the notifier Observable\n * emits value or completes.\n * @method sample\n * @owner Observable\n */\nfunction sample(notifier) {\n    return this.lift(new SampleOperator(notifier));\n}\nexports.sample = sample;\nvar SampleOperator = (function () {\n    function SampleOperator(notifier) {\n        this.notifier = notifier;\n    }\n    SampleOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new SampleSubscriber(subscriber, this.notifier));\n    };\n    return SampleOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SampleSubscriber = (function (_super) {\n    __extends(SampleSubscriber, _super);\n    function SampleSubscriber(destination, notifier) {\n        _super.call(this, destination);\n        this.hasValue = false;\n        this.add(subscribeToResult_1.subscribeToResult(this, notifier));\n    }\n    SampleSubscriber.prototype._next = function (value) {\n        this.value = value;\n        this.hasValue = true;\n    };\n    SampleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.emitValue();\n    };\n    SampleSubscriber.prototype.notifyComplete = function () {\n        this.emitValue();\n    };\n    SampleSubscriber.prototype.emitValue = function () {\n        if (this.hasValue) {\n            this.hasValue = false;\n            this.destination.next(this.value);\n        }\n    };\n    return SampleSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=sample.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/sample.js\n ** module id = 283\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/sample.js?");

/***/ },
/* 284 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar sampleTime_1 = __webpack_require__(285);\nObservable_1.Observable.prototype.sampleTime = sampleTime_1.sampleTime;\n//# sourceMappingURL=sampleTime.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/sampleTime.js\n ** module id = 284\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/sampleTime.js?");

/***/ },
/* 285 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(8);\nvar async_1 = __webpack_require__(96);\n/**\n * Emits the most recently emitted value from the source Observable within\n * periodic time intervals.\n *\n * <span class=\"informal\">Samples the source Observable at periodic time\n * intervals, emitting what it samples.</span>\n *\n * <img src=\"./img/sampleTime.png\" width=\"100%\">\n *\n * `sampleTime` periodically looks at the source Observable and emits whichever\n * value it has most recently emitted since the previous sampling, unless the\n * source has not emitted anything since the previous sampling. The sampling\n * happens periodically in time every `period` milliseconds (or the time unit\n * defined by the optional `scheduler` argument). The sampling starts as soon as\n * the output Observable is subscribed.\n *\n * @example <caption>Every second, emit the most recent click at most once</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.sampleTime(1000);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link auditTime}\n * @see {@link debounceTime}\n * @see {@link delay}\n * @see {@link sample}\n * @see {@link throttleTime}\n *\n * @param {number} period The sampling period expressed in milliseconds or the\n * time unit determined internally by the optional `scheduler`.\n * @param {Scheduler} [scheduler=async] The {@link Scheduler} to use for\n * managing the timers that handle the sampling.\n * @return {Observable<T>} An Observable that emits the results of sampling the\n * values emitted by the source Observable at the specified time interval.\n * @method sampleTime\n * @owner Observable\n */\nfunction sampleTime(period, scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    return this.lift(new SampleTimeOperator(period, scheduler));\n}\nexports.sampleTime = sampleTime;\nvar SampleTimeOperator = (function () {\n    function SampleTimeOperator(period, scheduler) {\n        this.period = period;\n        this.scheduler = scheduler;\n    }\n    SampleTimeOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new SampleTimeSubscriber(subscriber, this.period, this.scheduler));\n    };\n    return SampleTimeOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SampleTimeSubscriber = (function (_super) {\n    __extends(SampleTimeSubscriber, _super);\n    function SampleTimeSubscriber(destination, period, scheduler) {\n        _super.call(this, destination);\n        this.period = period;\n        this.scheduler = scheduler;\n        this.hasValue = false;\n        this.add(scheduler.schedule(dispatchNotification, period, { subscriber: this, period: period }));\n    }\n    SampleTimeSubscriber.prototype._next = function (value) {\n        this.lastValue = value;\n        this.hasValue = true;\n    };\n    SampleTimeSubscriber.prototype.notifyNext = function () {\n        if (this.hasValue) {\n            this.hasValue = false;\n            this.destination.next(this.lastValue);\n        }\n    };\n    return SampleTimeSubscriber;\n}(Subscriber_1.Subscriber));\nfunction dispatchNotification(state) {\n    var subscriber = state.subscriber, period = state.period;\n    subscriber.notifyNext();\n    this.schedule(state, period);\n}\n//# sourceMappingURL=sampleTime.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/sampleTime.js\n ** module id = 285\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/sampleTime.js?");

/***/ },
/* 286 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar scan_1 = __webpack_require__(287);\nObservable_1.Observable.prototype.scan = scan_1.scan;\n//# sourceMappingURL=scan.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/scan.js\n ** module id = 286\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/scan.js?");

/***/ },
/* 287 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(8);\n/**\n * Applies an accumulator function over the source Observable, and returns each\n * intermediate result, with an optional seed value.\n *\n * <span class=\"informal\">It's like {@link reduce}, but emits the current\n * accumulation whenever the source emits a value.</span>\n *\n * <img src=\"./img/scan.png\" width=\"100%\">\n *\n * Combines together all values emitted on the source, using an accumulator\n * function that knows how to join a new source value into the accumulation from\n * the past. Is similar to {@link reduce}, but emits the intermediate\n * accumulations.\n *\n * Returns an Observable that applies a specified `accumulator` function to each\n * item emitted by the source Observable. If a `seed` value is specified, then\n * that value will be used as the initial value for the accumulator. If no seed\n * value is specified, the first item of the source is used as the seed.\n *\n * @example <caption>Count the number of click events</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var ones = clicks.mapTo(1);\n * var seed = 0;\n * var count = ones.scan((acc, one) => acc + one, seed);\n * count.subscribe(x => console.log(x));\n *\n * @see {@link expand}\n * @see {@link mergeScan}\n * @see {@link reduce}\n *\n * @param {function(acc: R, value: T, index: number): R} accumulator\n * The accumulator function called on each source value.\n * @param {T|R} [seed] The initial accumulation value.\n * @return {Observable<R>} An observable of the accumulated values.\n * @method scan\n * @owner Observable\n */\nfunction scan(accumulator, seed) {\n    return this.lift(new ScanOperator(accumulator, seed));\n}\nexports.scan = scan;\nvar ScanOperator = (function () {\n    function ScanOperator(accumulator, seed) {\n        this.accumulator = accumulator;\n        this.seed = seed;\n    }\n    ScanOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new ScanSubscriber(subscriber, this.accumulator, this.seed));\n    };\n    return ScanOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar ScanSubscriber = (function (_super) {\n    __extends(ScanSubscriber, _super);\n    function ScanSubscriber(destination, accumulator, seed) {\n        _super.call(this, destination);\n        this.accumulator = accumulator;\n        this.index = 0;\n        this.accumulatorSet = false;\n        this.seed = seed;\n        this.accumulatorSet = typeof seed !== 'undefined';\n    }\n    Object.defineProperty(ScanSubscriber.prototype, \"seed\", {\n        get: function () {\n            return this._seed;\n        },\n        set: function (value) {\n            this.accumulatorSet = true;\n            this._seed = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ScanSubscriber.prototype._next = function (value) {\n        if (!this.accumulatorSet) {\n            this.seed = value;\n            this.destination.next(value);\n        }\n        else {\n            return this._tryNext(value);\n        }\n    };\n    ScanSubscriber.prototype._tryNext = function (value) {\n        var index = this.index++;\n        var result;\n        try {\n            result = this.accumulator(this.seed, value, index);\n        }\n        catch (err) {\n            this.destination.error(err);\n        }\n        this.seed = result;\n        this.destination.next(result);\n    };\n    return ScanSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=scan.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/scan.js\n ** module id = 287\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/scan.js?");

/***/ },
/* 288 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar sequenceEqual_1 = __webpack_require__(289);\nObservable_1.Observable.prototype.sequenceEqual = sequenceEqual_1.sequenceEqual;\n//# sourceMappingURL=sequenceEqual.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/sequenceEqual.js\n ** module id = 288\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/sequenceEqual.js?");

/***/ },
/* 289 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(8);\nvar tryCatch_1 = __webpack_require__(13);\nvar errorObject_1 = __webpack_require__(14);\n/**\n * Compares all values of two observables in sequence using an optional comparor function\n * and returns an observable of a single boolean value representing whether or not the two sequences\n * are equal.\n *\n * <span class=\"informal\">Checks to see of all values emitted by both observables are equal, in order.</span>\n *\n * <img src=\"./img/sequenceEqual.png\" width=\"100%\">\n *\n * `sequenceEqual` subscribes to two observables and buffers incoming values from each observable. Whenever either\n * observable emits a value, the value is buffered and the buffers are shifted and compared from the bottom\n * up; If any value pair doesn't match, the returned observable will emit `false` and complete. If one of the\n * observables completes, the operator will wait for the other observable to complete; If the other\n * observable emits before completing, the returned observable will emit `false` and complete. If one observable never\n * completes or emits after the other complets, the returned observable will never complete.\n *\n * @example <caption>figure out if the Konami code matches</caption>\n * var code = Observable.from([\n *  \"ArrowUp\",\n *  \"ArrowUp\",\n *  \"ArrowDown\",\n *  \"ArrowDown\",\n *  \"ArrowLeft\",\n *  \"ArrowRight\",\n *  \"ArrowLeft\",\n *  \"ArrowRight\",\n *  \"KeyB\",\n *  \"KeyA\",\n *  \"Enter\" // no start key, clearly.\n * ]);\n *\n * var keys = Rx.Observable.fromEvent(document, 'keyup')\n *  .map(e => e.code);\n * var matches = keys.bufferCount(11, 1)\n *  .mergeMap(\n *    last11 =>\n *      Rx.Observable.from(last11)\n *        .sequenceEqual(code)\n *   );\n * matches.subscribe(matched => console.log('Successful cheat at Contra? ', matched));\n *\n * @see {@link combineLatest}\n * @see {@link zip}\n * @see {@link withLatestFrom}\n *\n * @param {Observable} compareTo the observable sequence to compare the source sequence to.\n * @param {function} [comparor] An optional function to compare each value pair\n * @return {Observable} An Observable of a single boolean value representing whether or not\n * the values emitted by both observables were equal in sequence\n * @method sequenceEqual\n * @owner Observable\n */\nfunction sequenceEqual(compareTo, comparor) {\n    return this.lift(new SequenceEqualOperator(compareTo, comparor));\n}\nexports.sequenceEqual = sequenceEqual;\nvar SequenceEqualOperator = (function () {\n    function SequenceEqualOperator(compareTo, comparor) {\n        this.compareTo = compareTo;\n        this.comparor = comparor;\n    }\n    SequenceEqualOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new SequenceEqualSubscriber(subscriber, this.compareTo, this.comparor));\n    };\n    return SequenceEqualOperator;\n}());\nexports.SequenceEqualOperator = SequenceEqualOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SequenceEqualSubscriber = (function (_super) {\n    __extends(SequenceEqualSubscriber, _super);\n    function SequenceEqualSubscriber(destination, compareTo, comparor) {\n        _super.call(this, destination);\n        this.compareTo = compareTo;\n        this.comparor = comparor;\n        this._a = [];\n        this._b = [];\n        this._oneComplete = false;\n        this.add(compareTo.subscribe(new SequenceEqualCompareToSubscriber(destination, this)));\n    }\n    SequenceEqualSubscriber.prototype._next = function (value) {\n        if (this._oneComplete && this._b.length === 0) {\n            this.emit(false);\n        }\n        else {\n            this._a.push(value);\n            this.checkValues();\n        }\n    };\n    SequenceEqualSubscriber.prototype._complete = function () {\n        if (this._oneComplete) {\n            this.emit(this._a.length === 0 && this._b.length === 0);\n        }\n        else {\n            this._oneComplete = true;\n        }\n    };\n    SequenceEqualSubscriber.prototype.checkValues = function () {\n        var _c = this, _a = _c._a, _b = _c._b, comparor = _c.comparor;\n        while (_a.length > 0 && _b.length > 0) {\n            var a = _a.shift();\n            var b = _b.shift();\n            var areEqual = false;\n            if (comparor) {\n                areEqual = tryCatch_1.tryCatch(comparor)(a, b);\n                if (areEqual === errorObject_1.errorObject) {\n                    this.destination.error(errorObject_1.errorObject.e);\n                }\n            }\n            else {\n                areEqual = a === b;\n            }\n            if (!areEqual) {\n                this.emit(false);\n            }\n        }\n    };\n    SequenceEqualSubscriber.prototype.emit = function (value) {\n        var destination = this.destination;\n        destination.next(value);\n        destination.complete();\n    };\n    SequenceEqualSubscriber.prototype.nextB = function (value) {\n        if (this._oneComplete && this._a.length === 0) {\n            this.emit(false);\n        }\n        else {\n            this._b.push(value);\n            this.checkValues();\n        }\n    };\n    return SequenceEqualSubscriber;\n}(Subscriber_1.Subscriber));\nexports.SequenceEqualSubscriber = SequenceEqualSubscriber;\nvar SequenceEqualCompareToSubscriber = (function (_super) {\n    __extends(SequenceEqualCompareToSubscriber, _super);\n    function SequenceEqualCompareToSubscriber(destination, parent) {\n        _super.call(this, destination);\n        this.parent = parent;\n    }\n    SequenceEqualCompareToSubscriber.prototype._next = function (value) {\n        this.parent.nextB(value);\n    };\n    SequenceEqualCompareToSubscriber.prototype._error = function (err) {\n        this.parent.error(err);\n    };\n    SequenceEqualCompareToSubscriber.prototype._complete = function () {\n        this.parent._complete();\n    };\n    return SequenceEqualCompareToSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=sequenceEqual.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/sequenceEqual.js\n ** module id = 289\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/sequenceEqual.js?");

/***/ },
/* 290 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar share_1 = __webpack_require__(291);\nObservable_1.Observable.prototype.share = share_1.share;\n//# sourceMappingURL=share.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/share.js\n ** module id = 290\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/share.js?");

/***/ },
/* 291 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar multicast_1 = __webpack_require__(251);\nvar Subject_1 = __webpack_require__(4);\nfunction shareSubjectFactory() {\n    return new Subject_1.Subject();\n}\n/**\n * Returns a new Observable that multicasts (shares) the original Observable. As long as there is at least one\n * Subscriber this Observable will be subscribed and emitting data. When all subscribers have unsubscribed it will\n * unsubscribe from the source Observable. Because the Observable is multicasting it makes the stream `hot`.\n * This is an alias for .publish().refCount().\n *\n * <img src=\"./img/share.png\" width=\"100%\">\n *\n * @return {Observable<T>} an Observable that upon connection causes the source Observable to emit items to its Observers\n * @method share\n * @owner Observable\n */\nfunction share() {\n    return multicast_1.multicast.call(this, shareSubjectFactory).refCount();\n}\nexports.share = share;\n;\n//# sourceMappingURL=share.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/share.js\n ** module id = 291\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/share.js?");

/***/ },
/* 292 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar single_1 = __webpack_require__(293);\nObservable_1.Observable.prototype.single = single_1.single;\n//# sourceMappingURL=single.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/single.js\n ** module id = 292\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/single.js?");

/***/ },
/* 293 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(8);\nvar EmptyError_1 = __webpack_require__(214);\n/**\n * Returns an Observable that emits the single item emitted by the source Observable that matches a specified\n * predicate, if that Observable emits one such item. If the source Observable emits more than one such item or no\n * such items, notify of an IllegalArgumentException or NoSuchElementException respectively.\n *\n * <img src=\"./img/single.png\" width=\"100%\">\n *\n * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`\n * callback if the Observable completes before any `next` notification was sent.\n * @param {Function} a predicate function to evaluate items emitted by the source Observable.\n * @return {Observable<T>} an Observable that emits the single item emitted by the source Observable that matches\n * the predicate.\n .\n * @method single\n * @owner Observable\n */\nfunction single(predicate) {\n    return this.lift(new SingleOperator(predicate, this));\n}\nexports.single = single;\nvar SingleOperator = (function () {\n    function SingleOperator(predicate, source) {\n        this.predicate = predicate;\n        this.source = source;\n    }\n    SingleOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new SingleSubscriber(subscriber, this.predicate, this.source));\n    };\n    return SingleOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SingleSubscriber = (function (_super) {\n    __extends(SingleSubscriber, _super);\n    function SingleSubscriber(destination, predicate, source) {\n        _super.call(this, destination);\n        this.predicate = predicate;\n        this.source = source;\n        this.seenValue = false;\n        this.index = 0;\n    }\n    SingleSubscriber.prototype.applySingleValue = function (value) {\n        if (this.seenValue) {\n            this.destination.error('Sequence contains more than one element');\n        }\n        else {\n            this.seenValue = true;\n            this.singleValue = value;\n        }\n    };\n    SingleSubscriber.prototype._next = function (value) {\n        var predicate = this.predicate;\n        this.index++;\n        if (predicate) {\n            this.tryNext(value);\n        }\n        else {\n            this.applySingleValue(value);\n        }\n    };\n    SingleSubscriber.prototype.tryNext = function (value) {\n        try {\n            var result = this.predicate(value, this.index, this.source);\n            if (result) {\n                this.applySingleValue(value);\n            }\n        }\n        catch (err) {\n            this.destination.error(err);\n        }\n    };\n    SingleSubscriber.prototype._complete = function () {\n        var destination = this.destination;\n        if (this.index > 0) {\n            destination.next(this.seenValue ? this.singleValue : undefined);\n            destination.complete();\n        }\n        else {\n            destination.error(new EmptyError_1.EmptyError);\n        }\n    };\n    return SingleSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=single.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/single.js\n ** module id = 293\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/single.js?");

/***/ },
/* 294 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar skip_1 = __webpack_require__(295);\nObservable_1.Observable.prototype.skip = skip_1.skip;\n//# sourceMappingURL=skip.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/skip.js\n ** module id = 294\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/skip.js?");

/***/ },
/* 295 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(8);\n/**\n * Returns an Observable that skips `n` items emitted by an Observable.\n *\n * <img src=\"./img/skip.png\" width=\"100%\">\n *\n * @param {Number} the `n` of times, items emitted by source Observable should be skipped.\n * @return {Observable} an Observable that skips values emitted by the source Observable.\n *\n * @method skip\n * @owner Observable\n */\nfunction skip(total) {\n    return this.lift(new SkipOperator(total));\n}\nexports.skip = skip;\nvar SkipOperator = (function () {\n    function SkipOperator(total) {\n        this.total = total;\n    }\n    SkipOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new SkipSubscriber(subscriber, this.total));\n    };\n    return SkipOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SkipSubscriber = (function (_super) {\n    __extends(SkipSubscriber, _super);\n    function SkipSubscriber(destination, total) {\n        _super.call(this, destination);\n        this.total = total;\n        this.count = 0;\n    }\n    SkipSubscriber.prototype._next = function (x) {\n        if (++this.count > this.total) {\n            this.destination.next(x);\n        }\n    };\n    return SkipSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=skip.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/skip.js\n ** module id = 295\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/skip.js?");

/***/ },
/* 296 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar skipUntil_1 = __webpack_require__(297);\nObservable_1.Observable.prototype.skipUntil = skipUntil_1.skipUntil;\n//# sourceMappingURL=skipUntil.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/skipUntil.js\n ** module id = 296\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/skipUntil.js?");

/***/ },
/* 297 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = __webpack_require__(54);\nvar subscribeToResult_1 = __webpack_require__(55);\n/**\n * Returns an Observable that skips items emitted by the source Observable until a second Observable emits an item.\n *\n * <img src=\"./img/skipUntil.png\" width=\"100%\">\n *\n * @param {Observable} the second Observable that has to emit an item before the source Observable's elements begin to\n * be mirrored by the resulting Observable.\n * @return {Observable<T>} an Observable that skips items from the source Observable until the second Observable emits\n * an item, then emits the remaining items.\n * @method skipUntil\n * @owner Observable\n */\nfunction skipUntil(notifier) {\n    return this.lift(new SkipUntilOperator(notifier));\n}\nexports.skipUntil = skipUntil;\nvar SkipUntilOperator = (function () {\n    function SkipUntilOperator(notifier) {\n        this.notifier = notifier;\n    }\n    SkipUntilOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new SkipUntilSubscriber(subscriber, this.notifier));\n    };\n    return SkipUntilOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SkipUntilSubscriber = (function (_super) {\n    __extends(SkipUntilSubscriber, _super);\n    function SkipUntilSubscriber(destination, notifier) {\n        _super.call(this, destination);\n        this.hasValue = false;\n        this.isInnerStopped = false;\n        this.add(subscribeToResult_1.subscribeToResult(this, notifier));\n    }\n    SkipUntilSubscriber.prototype._next = function (value) {\n        if (this.hasValue) {\n            _super.prototype._next.call(this, value);\n        }\n    };\n    SkipUntilSubscriber.prototype._complete = function () {\n        if (this.isInnerStopped) {\n            _super.prototype._complete.call(this);\n        }\n        else {\n            this.unsubscribe();\n        }\n    };\n    SkipUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.hasValue = true;\n    };\n    SkipUntilSubscriber.prototype.notifyComplete = function () {\n        this.isInnerStopped = true;\n        if (this.isStopped) {\n            _super.prototype._complete.call(this);\n        }\n    };\n    return SkipUntilSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=skipUntil.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/skipUntil.js\n ** module id = 297\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/skipUntil.js?");

/***/ },
/* 298 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar skipWhile_1 = __webpack_require__(299);\nObservable_1.Observable.prototype.skipWhile = skipWhile_1.skipWhile;\n//# sourceMappingURL=skipWhile.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/skipWhile.js\n ** module id = 298\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/skipWhile.js?");

/***/ },
/* 299 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(8);\n/**\n * Returns an Observable that skips all items emitted by the source Observable as long as a specified condition holds\n * true, but emits all further source items as soon as the condition becomes false.\n *\n * <img src=\"./img/skipWhile.png\" width=\"100%\">\n *\n * @param {Function} predicate - a function to test each item emitted from the source Observable.\n * @return {Observable<T>} an Observable that begins emitting items emitted by the source Observable when the\n * specified predicate becomes false.\n * @method skipWhile\n * @owner Observable\n */\nfunction skipWhile(predicate) {\n    return this.lift(new SkipWhileOperator(predicate));\n}\nexports.skipWhile = skipWhile;\nvar SkipWhileOperator = (function () {\n    function SkipWhileOperator(predicate) {\n        this.predicate = predicate;\n    }\n    SkipWhileOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new SkipWhileSubscriber(subscriber, this.predicate));\n    };\n    return SkipWhileOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SkipWhileSubscriber = (function (_super) {\n    __extends(SkipWhileSubscriber, _super);\n    function SkipWhileSubscriber(destination, predicate) {\n        _super.call(this, destination);\n        this.predicate = predicate;\n        this.skipping = true;\n        this.index = 0;\n    }\n    SkipWhileSubscriber.prototype._next = function (value) {\n        var destination = this.destination;\n        if (this.skipping) {\n            this.tryCallPredicate(value);\n        }\n        if (!this.skipping) {\n            destination.next(value);\n        }\n    };\n    SkipWhileSubscriber.prototype.tryCallPredicate = function (value) {\n        try {\n            var result = this.predicate(value, this.index++);\n            this.skipping = Boolean(result);\n        }\n        catch (err) {\n            this.destination.error(err);\n        }\n    };\n    return SkipWhileSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=skipWhile.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/skipWhile.js\n ** module id = 299\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/skipWhile.js?");

/***/ },
/* 300 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar startWith_1 = __webpack_require__(301);\nObservable_1.Observable.prototype.startWith = startWith_1.startWith;\n//# sourceMappingURL=startWith.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/startWith.js\n ** module id = 300\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/startWith.js?");

/***/ },
/* 301 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar ArrayObservable_1 = __webpack_require__(50);\nvar ScalarObservable_1 = __webpack_require__(51);\nvar EmptyObservable_1 = __webpack_require__(52);\nvar concat_1 = __webpack_require__(61);\nvar isScheduler_1 = __webpack_require__(49);\n/**\n * Returns an Observable that emits the items in a specified Iterable before it begins to emit items emitted by the\n * source Observable.\n *\n * <img src=\"./img/startWith.png\" width=\"100%\">\n *\n * @param {Values} an Iterable that contains the items you want the modified Observable to emit first.\n * @return {Observable} an Observable that emits the items in the specified Iterable and then emits the items\n * emitted by the source Observable.\n * @method startWith\n * @owner Observable\n */\nfunction startWith() {\n    var array = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        array[_i - 0] = arguments[_i];\n    }\n    var scheduler = array[array.length - 1];\n    if (isScheduler_1.isScheduler(scheduler)) {\n        array.pop();\n    }\n    else {\n        scheduler = null;\n    }\n    var len = array.length;\n    if (len === 1) {\n        return concat_1.concatStatic(new ScalarObservable_1.ScalarObservable(array[0], scheduler), this);\n    }\n    else if (len > 1) {\n        return concat_1.concatStatic(new ArrayObservable_1.ArrayObservable(array, scheduler), this);\n    }\n    else {\n        return concat_1.concatStatic(new EmptyObservable_1.EmptyObservable(scheduler), this);\n    }\n}\nexports.startWith = startWith;\n//# sourceMappingURL=startWith.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/startWith.js\n ** module id = 301\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/startWith.js?");

/***/ },
/* 302 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar subscribeOn_1 = __webpack_require__(303);\nObservable_1.Observable.prototype.subscribeOn = subscribeOn_1.subscribeOn;\n//# sourceMappingURL=subscribeOn.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/subscribeOn.js\n ** module id = 302\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/subscribeOn.js?");

/***/ },
/* 303 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar SubscribeOnObservable_1 = __webpack_require__(304);\n/**\n * Asynchronously subscribes Observers to this Observable on the specified Scheduler.\n *\n * <img src=\"./img/subscribeOn.png\" width=\"100%\">\n *\n * @param {Scheduler} the Scheduler to perform subscription actions on.\n * @return {Observable<T>} the source Observable modified so that its subscriptions happen on the specified Scheduler\n .\n * @method subscribeOn\n * @owner Observable\n */\nfunction subscribeOn(scheduler, delay) {\n    if (delay === void 0) { delay = 0; }\n    return new SubscribeOnObservable_1.SubscribeOnObservable(this, delay, scheduler);\n}\nexports.subscribeOn = subscribeOn;\n//# sourceMappingURL=subscribeOn.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/subscribeOn.js\n ** module id = 303\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/subscribeOn.js?");

/***/ },
/* 304 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = __webpack_require__(5);\nvar asap_1 = __webpack_require__(305);\nvar isNumeric_1 = __webpack_require__(95);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar SubscribeOnObservable = (function (_super) {\n    __extends(SubscribeOnObservable, _super);\n    function SubscribeOnObservable(source, delayTime, scheduler) {\n        if (delayTime === void 0) { delayTime = 0; }\n        if (scheduler === void 0) { scheduler = asap_1.asap; }\n        _super.call(this);\n        this.source = source;\n        this.delayTime = delayTime;\n        this.scheduler = scheduler;\n        if (!isNumeric_1.isNumeric(delayTime) || delayTime < 0) {\n            this.delayTime = 0;\n        }\n        if (!scheduler || typeof scheduler.schedule !== 'function') {\n            this.scheduler = asap_1.asap;\n        }\n    }\n    SubscribeOnObservable.create = function (source, delay, scheduler) {\n        if (delay === void 0) { delay = 0; }\n        if (scheduler === void 0) { scheduler = asap_1.asap; }\n        return new SubscribeOnObservable(source, delay, scheduler);\n    };\n    SubscribeOnObservable.dispatch = function (arg) {\n        var source = arg.source, subscriber = arg.subscriber;\n        return source.subscribe(subscriber);\n    };\n    SubscribeOnObservable.prototype._subscribe = function (subscriber) {\n        var delay = this.delayTime;\n        var source = this.source;\n        var scheduler = this.scheduler;\n        return scheduler.schedule(SubscribeOnObservable.dispatch, delay, {\n            source: source, subscriber: subscriber\n        });\n    };\n    return SubscribeOnObservable;\n}(Observable_1.Observable));\nexports.SubscribeOnObservable = SubscribeOnObservable;\n//# sourceMappingURL=SubscribeOnObservable.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/observable/SubscribeOnObservable.js\n ** module id = 304\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/observable/SubscribeOnObservable.js?");

/***/ },
/* 305 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar AsapAction_1 = __webpack_require__(306);\nvar AsapScheduler_1 = __webpack_require__(309);\nexports.asap = new AsapScheduler_1.AsapScheduler(AsapAction_1.AsapAction);\n//# sourceMappingURL=asap.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/scheduler/asap.js\n ** module id = 305\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/scheduler/asap.js?");

/***/ },
/* 306 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Immediate_1 = __webpack_require__(307);\nvar AsyncAction_1 = __webpack_require__(97);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar AsapAction = (function (_super) {\n    __extends(AsapAction, _super);\n    function AsapAction(scheduler, work) {\n        _super.call(this, scheduler, work);\n        this.scheduler = scheduler;\n        this.work = work;\n    }\n    AsapAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) { delay = 0; }\n        // If delay is greater than 0, request as an async action.\n        if (delay !== null && delay > 0) {\n            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);\n        }\n        // Push the action to the end of the scheduler queue.\n        scheduler.actions.push(this);\n        // If a microtask has already been scheduled, don't schedule another\n        // one. If a microtask hasn't been scheduled yet, schedule one now. Return\n        // the current scheduled microtask id.\n        return scheduler.scheduled || (scheduler.scheduled = Immediate_1.Immediate.setImmediate(scheduler.flush.bind(scheduler, null)));\n    };\n    AsapAction.prototype.recycleAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) { delay = 0; }\n        // If delay exists and is greater than 0, recycle as an async action.\n        if (delay !== null && delay > 0) {\n            return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);\n        }\n        // If the scheduler queue is empty, cancel the requested microtask and\n        // set the scheduled flag to undefined so the next AsapAction will schedule\n        // its own.\n        if (scheduler.actions.length === 0) {\n            Immediate_1.Immediate.clearImmediate(id);\n            scheduler.scheduled = undefined;\n        }\n        // Return undefined so the action knows to request a new async id if it's rescheduled.\n        return undefined;\n    };\n    return AsapAction;\n}(AsyncAction_1.AsyncAction));\nexports.AsapAction = AsapAction;\n//# sourceMappingURL=AsapAction.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/scheduler/AsapAction.js\n ** module id = 306\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/scheduler/AsapAction.js?");

/***/ },
/* 307 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(clearImmediate, setImmediate) {/**\nSome credit for this helper goes to http://github.com/YuzuJS/setImmediate\n*/\n\"use strict\";\nvar root_1 = __webpack_require__(6);\nvar ImmediateDefinition = (function () {\n    function ImmediateDefinition(root) {\n        this.root = root;\n        if (root.setImmediate && typeof root.setImmediate === 'function') {\n            this.setImmediate = root.setImmediate.bind(root);\n            this.clearImmediate = root.clearImmediate.bind(root);\n        }\n        else {\n            this.nextHandle = 1;\n            this.tasksByHandle = {};\n            this.currentlyRunningATask = false;\n            // Don't get fooled by e.g. browserify environments.\n            if (this.canUseProcessNextTick()) {\n                // For Node.js before 0.9\n                this.setImmediate = this.createProcessNextTickSetImmediate();\n            }\n            else if (this.canUsePostMessage()) {\n                // For non-IE10 modern browsers\n                this.setImmediate = this.createPostMessageSetImmediate();\n            }\n            else if (this.canUseMessageChannel()) {\n                // For web workers, where supported\n                this.setImmediate = this.createMessageChannelSetImmediate();\n            }\n            else if (this.canUseReadyStateChange()) {\n                // For IE 6–8\n                this.setImmediate = this.createReadyStateChangeSetImmediate();\n            }\n            else {\n                // For older browsers\n                this.setImmediate = this.createSetTimeoutSetImmediate();\n            }\n            var ci = function clearImmediate(handle) {\n                delete clearImmediate.instance.tasksByHandle[handle];\n            };\n            ci.instance = this;\n            this.clearImmediate = ci;\n        }\n    }\n    ImmediateDefinition.prototype.identify = function (o) {\n        return this.root.Object.prototype.toString.call(o);\n    };\n    ImmediateDefinition.prototype.canUseProcessNextTick = function () {\n        return this.identify(this.root.process) === '[object process]';\n    };\n    ImmediateDefinition.prototype.canUseMessageChannel = function () {\n        return Boolean(this.root.MessageChannel);\n    };\n    ImmediateDefinition.prototype.canUseReadyStateChange = function () {\n        var document = this.root.document;\n        return Boolean(document && 'onreadystatechange' in document.createElement('script'));\n    };\n    ImmediateDefinition.prototype.canUsePostMessage = function () {\n        var root = this.root;\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `root.postMessage` means something completely different and can't be used for this purpose.\n        if (root.postMessage && !root.importScripts) {\n            var postMessageIsAsynchronous_1 = true;\n            var oldOnMessage = root.onmessage;\n            root.onmessage = function () {\n                postMessageIsAsynchronous_1 = false;\n            };\n            root.postMessage('', '*');\n            root.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous_1;\n        }\n        return false;\n    };\n    // This function accepts the same arguments as setImmediate, but\n    // returns a function that requires no arguments.\n    ImmediateDefinition.prototype.partiallyApplied = function (handler) {\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        var fn = function result() {\n            var _a = result, handler = _a.handler, args = _a.args;\n            if (typeof handler === 'function') {\n                handler.apply(undefined, args);\n            }\n            else {\n                (new Function('' + handler))();\n            }\n        };\n        fn.handler = handler;\n        fn.args = args;\n        return fn;\n    };\n    ImmediateDefinition.prototype.addFromSetImmediateArguments = function (args) {\n        this.tasksByHandle[this.nextHandle] = this.partiallyApplied.apply(undefined, args);\n        return this.nextHandle++;\n    };\n    ImmediateDefinition.prototype.createProcessNextTickSetImmediate = function () {\n        var fn = function setImmediate() {\n            var instance = setImmediate.instance;\n            var handle = instance.addFromSetImmediateArguments(arguments);\n            instance.root.process.nextTick(instance.partiallyApplied(instance.runIfPresent, handle));\n            return handle;\n        };\n        fn.instance = this;\n        return fn;\n    };\n    ImmediateDefinition.prototype.createPostMessageSetImmediate = function () {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n        var root = this.root;\n        var messagePrefix = 'setImmediate$' + root.Math.random() + '$';\n        var onGlobalMessage = function globalMessageHandler(event) {\n            var instance = globalMessageHandler.instance;\n            if (event.source === root &&\n                typeof event.data === 'string' &&\n                event.data.indexOf(messagePrefix) === 0) {\n                instance.runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n        onGlobalMessage.instance = this;\n        root.addEventListener('message', onGlobalMessage, false);\n        var fn = function setImmediate() {\n            var _a = setImmediate, messagePrefix = _a.messagePrefix, instance = _a.instance;\n            var handle = instance.addFromSetImmediateArguments(arguments);\n            instance.root.postMessage(messagePrefix + handle, '*');\n            return handle;\n        };\n        fn.instance = this;\n        fn.messagePrefix = messagePrefix;\n        return fn;\n    };\n    ImmediateDefinition.prototype.runIfPresent = function (handle) {\n        // From the spec: 'Wait until any invocations of this algorithm started before this one have completed.'\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (this.currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // 'too much recursion' error.\n            this.root.setTimeout(this.partiallyApplied(this.runIfPresent, handle), 0);\n        }\n        else {\n            var task = this.tasksByHandle[handle];\n            if (task) {\n                this.currentlyRunningATask = true;\n                try {\n                    task();\n                }\n                finally {\n                    this.clearImmediate(handle);\n                    this.currentlyRunningATask = false;\n                }\n            }\n        }\n    };\n    ImmediateDefinition.prototype.createMessageChannelSetImmediate = function () {\n        var _this = this;\n        var channel = new this.root.MessageChannel();\n        channel.port1.onmessage = function (event) {\n            var handle = event.data;\n            _this.runIfPresent(handle);\n        };\n        var fn = function setImmediate() {\n            var _a = setImmediate, channel = _a.channel, instance = _a.instance;\n            var handle = instance.addFromSetImmediateArguments(arguments);\n            channel.port2.postMessage(handle);\n            return handle;\n        };\n        fn.channel = channel;\n        fn.instance = this;\n        return fn;\n    };\n    ImmediateDefinition.prototype.createReadyStateChangeSetImmediate = function () {\n        var fn = function setImmediate() {\n            var instance = setImmediate.instance;\n            var root = instance.root;\n            var doc = root.document;\n            var html = doc.documentElement;\n            var handle = instance.addFromSetImmediateArguments(arguments);\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement('script');\n            script.onreadystatechange = function () {\n                instance.runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n            return handle;\n        };\n        fn.instance = this;\n        return fn;\n    };\n    ImmediateDefinition.prototype.createSetTimeoutSetImmediate = function () {\n        var fn = function setImmediate() {\n            var instance = setImmediate.instance;\n            var handle = instance.addFromSetImmediateArguments(arguments);\n            instance.root.setTimeout(instance.partiallyApplied(instance.runIfPresent, handle), 0);\n            return handle;\n        };\n        fn.instance = this;\n        return fn;\n    };\n    return ImmediateDefinition;\n}());\nexports.ImmediateDefinition = ImmediateDefinition;\nexports.Immediate = new ImmediateDefinition(root_1.root);\n//# sourceMappingURL=Immediate.js.map\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(308).clearImmediate, __webpack_require__(308).setImmediate))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/util/Immediate.js\n ** module id = 307\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/util/Immediate.js?");

/***/ },
/* 308 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(setImmediate, clearImmediate) {var nextTick = __webpack_require__(38).nextTick;\nvar apply = Function.prototype.apply;\nvar slice = Array.prototype.slice;\nvar immediateIds = {};\nvar nextImmediateId = 0;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) { timeout.close(); };\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// That's not how node.js implements it but the exposed api is the same.\nexports.setImmediate = typeof setImmediate === \"function\" ? setImmediate : function(fn) {\n  var id = nextImmediateId++;\n  var args = arguments.length < 2 ? false : slice.call(arguments, 1);\n\n  immediateIds[id] = true;\n\n  nextTick(function onNextTick() {\n    if (immediateIds[id]) {\n      // fn.call() is faster so we optimize for the common use-case\n      // @see http://jsperf.com/call-apply-segu\n      if (args) {\n        fn.apply(null, args);\n      } else {\n        fn.call(null);\n      }\n      // Prevent ids from leaking\n      exports.clearImmediate(id);\n    }\n  });\n\n  return id;\n};\n\nexports.clearImmediate = typeof clearImmediate === \"function\" ? clearImmediate : function(id) {\n  delete immediateIds[id];\n};\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(308).setImmediate, __webpack_require__(308).clearImmediate))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/timers-browserify/main.js\n ** module id = 308\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/timers-browserify/main.js?");

/***/ },
/* 309 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar AsyncScheduler_1 = __webpack_require__(99);\nvar AsapScheduler = (function (_super) {\n    __extends(AsapScheduler, _super);\n    function AsapScheduler() {\n        _super.apply(this, arguments);\n    }\n    AsapScheduler.prototype.flush = function () {\n        this.active = true;\n        this.scheduled = undefined;\n        var actions = this.actions;\n        var error;\n        var index = -1;\n        var count = actions.length;\n        var action = actions.shift();\n        do {\n            if (error = action.execute(action.state, action.delay)) {\n                break;\n            }\n        } while (++index < count && (action = actions.shift()));\n        this.active = false;\n        if (error) {\n            while (++index < count && (action = actions.shift())) {\n                action.unsubscribe();\n            }\n            throw error;\n        }\n    };\n    return AsapScheduler;\n}(AsyncScheduler_1.AsyncScheduler));\nexports.AsapScheduler = AsapScheduler;\n//# sourceMappingURL=AsapScheduler.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/scheduler/AsapScheduler.js\n ** module id = 309\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/scheduler/AsapScheduler.js?");

/***/ },
/* 310 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar switch_1 = __webpack_require__(311);\nObservable_1.Observable.prototype.switch = switch_1._switch;\nObservable_1.Observable.prototype._switch = switch_1._switch;\n//# sourceMappingURL=switch.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/switch.js\n ** module id = 310\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/switch.js?");

/***/ },
/* 311 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = __webpack_require__(54);\nvar subscribeToResult_1 = __webpack_require__(55);\n/**\n * Converts a higher-order Observable into a first-order Observable by\n * subscribing to only the most recently emitted of those inner Observables.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables by dropping the\n * previous inner Observable once a new one appears.</span>\n *\n * <img src=\"./img/switch.png\" width=\"100%\">\n *\n * `switch` subscribes to an Observable that emits Observables, also known as a\n * higher-order Observable. Each time it observes one of these emitted inner\n * Observables, the output Observable subscribes to the inner Observable and\n * begins emitting the items emitted by that. So far, it behaves\n * like {@link mergeAll}. However, when a new inner Observable is emitted,\n * `switch` unsubscribes from the earlier-emitted inner Observable and\n * subscribes to the new inner Observable and begins emitting items from it. It\n * continues to behave like this for subsequent inner Observables.\n *\n * @example <caption>Rerun an interval Observable on every click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * // Each click event is mapped to an Observable that ticks every second\n * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));\n * var switched = higherOrder.switch();\n * // The outcome is that `switched` is essentially a timer that restarts\n * // on every click. The interval Observables from older clicks do not merge\n * // with the current interval Observable.\n * switched.subscribe(x => console.log(x));\n *\n * @see {@link combineAll}\n * @see {@link concatAll}\n * @see {@link exhaust}\n * @see {@link mergeAll}\n * @see {@link switchMap}\n * @see {@link switchMapTo}\n * @see {@link zipAll}\n *\n * @return {Observable<T>} An Observable that emits the items emitted by the\n * Observable most recently emitted by the source Observable.\n * @method switch\n * @name switch\n * @owner Observable\n */\nfunction _switch() {\n    return this.lift(new SwitchOperator());\n}\nexports._switch = _switch;\nvar SwitchOperator = (function () {\n    function SwitchOperator() {\n    }\n    SwitchOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new SwitchSubscriber(subscriber));\n    };\n    return SwitchOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SwitchSubscriber = (function (_super) {\n    __extends(SwitchSubscriber, _super);\n    function SwitchSubscriber(destination) {\n        _super.call(this, destination);\n        this.active = 0;\n        this.hasCompleted = false;\n    }\n    SwitchSubscriber.prototype._next = function (value) {\n        this.unsubscribeInner();\n        this.active++;\n        this.add(this.innerSubscription = subscribeToResult_1.subscribeToResult(this, value));\n    };\n    SwitchSubscriber.prototype._complete = function () {\n        this.hasCompleted = true;\n        if (this.active === 0) {\n            this.destination.complete();\n        }\n    };\n    SwitchSubscriber.prototype.unsubscribeInner = function () {\n        this.active = this.active > 0 ? this.active - 1 : 0;\n        var innerSubscription = this.innerSubscription;\n        if (innerSubscription) {\n            innerSubscription.unsubscribe();\n            this.remove(innerSubscription);\n        }\n    };\n    SwitchSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.destination.next(innerValue);\n    };\n    SwitchSubscriber.prototype.notifyError = function (err) {\n        this.destination.error(err);\n    };\n    SwitchSubscriber.prototype.notifyComplete = function () {\n        this.unsubscribeInner();\n        if (this.hasCompleted && this.active === 0) {\n            this.destination.complete();\n        }\n    };\n    return SwitchSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=switch.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/switch.js\n ** module id = 311\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/switch.js?");

/***/ },
/* 312 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar switchMap_1 = __webpack_require__(313);\nObservable_1.Observable.prototype.switchMap = switchMap_1.switchMap;\n//# sourceMappingURL=switchMap.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/switchMap.js\n ** module id = 312\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/switchMap.js?");

/***/ },
/* 313 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = __webpack_require__(54);\nvar subscribeToResult_1 = __webpack_require__(55);\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable, emitting values only from the most recently projected Observable.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link switch}.</span>\n *\n * <img src=\"./img/switchMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. Each time it observes one of these\n * inner Observables, the output Observable begins emitting the items emitted by\n * that inner Observable. When a new inner Observable is emitted, `switchMap`\n * stops emitting items from the earlier-emitted inner Observable and begins\n * emitting items from the new one. It continues to behave like this for\n * subsequent inner Observables.\n *\n * @example <caption>Rerun an interval Observable on every click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.switchMap((ev) => Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatMap}\n * @see {@link exhaustMap}\n * @see {@link mergeMap}\n * @see {@link switch}\n * @see {@link switchMapTo}\n *\n * @param {function(value: T, ?index: number): Observable} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} An Observable that emits the result of applying the\n * projection function (and the optional `resultSelector`) to each item emitted\n * by the source Observable and taking only the values from the most recently\n * projected inner Observable.\n * @method switchMap\n * @owner Observable\n */\nfunction switchMap(project, resultSelector) {\n    return this.lift(new SwitchMapOperator(project, resultSelector));\n}\nexports.switchMap = switchMap;\nvar SwitchMapOperator = (function () {\n    function SwitchMapOperator(project, resultSelector) {\n        this.project = project;\n        this.resultSelector = resultSelector;\n    }\n    SwitchMapOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new SwitchMapSubscriber(subscriber, this.project, this.resultSelector));\n    };\n    return SwitchMapOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SwitchMapSubscriber = (function (_super) {\n    __extends(SwitchMapSubscriber, _super);\n    function SwitchMapSubscriber(destination, project, resultSelector) {\n        _super.call(this, destination);\n        this.project = project;\n        this.resultSelector = resultSelector;\n        this.index = 0;\n    }\n    SwitchMapSubscriber.prototype._next = function (value) {\n        var result;\n        var index = this.index++;\n        try {\n            result = this.project(value, index);\n        }\n        catch (error) {\n            this.destination.error(error);\n            return;\n        }\n        this._innerSub(result, value, index);\n    };\n    SwitchMapSubscriber.prototype._innerSub = function (result, value, index) {\n        var innerSubscription = this.innerSubscription;\n        if (innerSubscription) {\n            innerSubscription.unsubscribe();\n        }\n        this.add(this.innerSubscription = subscribeToResult_1.subscribeToResult(this, result, value, index));\n    };\n    SwitchMapSubscriber.prototype._complete = function () {\n        var innerSubscription = this.innerSubscription;\n        if (!innerSubscription || innerSubscription.closed) {\n            _super.prototype._complete.call(this);\n        }\n    };\n    SwitchMapSubscriber.prototype._unsubscribe = function () {\n        this.innerSubscription = null;\n    };\n    SwitchMapSubscriber.prototype.notifyComplete = function (innerSub) {\n        this.remove(innerSub);\n        this.innerSubscription = null;\n        if (this.isStopped) {\n            _super.prototype._complete.call(this);\n        }\n    };\n    SwitchMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        if (this.resultSelector) {\n            this._tryNotifyNext(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        else {\n            this.destination.next(innerValue);\n        }\n    };\n    SwitchMapSubscriber.prototype._tryNotifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {\n        var result;\n        try {\n            result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.destination.next(result);\n    };\n    return SwitchMapSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=switchMap.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/switchMap.js\n ** module id = 313\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/switchMap.js?");

/***/ },
/* 314 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar switchMapTo_1 = __webpack_require__(315);\nObservable_1.Observable.prototype.switchMapTo = switchMapTo_1.switchMapTo;\n//# sourceMappingURL=switchMapTo.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/switchMapTo.js\n ** module id = 314\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/switchMapTo.js?");

/***/ },
/* 315 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = __webpack_require__(54);\nvar subscribeToResult_1 = __webpack_require__(55);\n/**\n * Projects each source value to the same Observable which is flattened multiple\n * times with {@link switch} in the output Observable.\n *\n * <span class=\"informal\">It's like {@link switchMap}, but maps each value\n * always to the same inner Observable.</span>\n *\n * <img src=\"./img/switchMapTo.png\" width=\"100%\">\n *\n * Maps each source value to the given Observable `innerObservable` regardless\n * of the source value, and then flattens those resulting Observables into one\n * single Observable, which is the output Observable. The output Observables\n * emits values only from the most recently emitted instance of\n * `innerObservable`.\n *\n * @example <caption>Rerun an interval Observable on every click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.switchMapTo(Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatMapTo}\n * @see {@link switch}\n * @see {@link switchMap}\n * @see {@link mergeMapTo}\n *\n * @param {Observable} innerObservable An Observable to replace each value from\n * the source Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} An Observable that emits items from the given\n * `innerObservable` every time a value is emitted on the source Observable.\n * @return {Observable} An Observable that emits items from the given\n * `innerObservable` (and optionally transformed through `resultSelector`) every\n * time a value is emitted on the source Observable, and taking only the values\n * from the most recently projected inner Observable.\n * @method switchMapTo\n * @owner Observable\n */\nfunction switchMapTo(innerObservable, resultSelector) {\n    return this.lift(new SwitchMapToOperator(innerObservable, resultSelector));\n}\nexports.switchMapTo = switchMapTo;\nvar SwitchMapToOperator = (function () {\n    function SwitchMapToOperator(observable, resultSelector) {\n        this.observable = observable;\n        this.resultSelector = resultSelector;\n    }\n    SwitchMapToOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new SwitchMapToSubscriber(subscriber, this.observable, this.resultSelector));\n    };\n    return SwitchMapToOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SwitchMapToSubscriber = (function (_super) {\n    __extends(SwitchMapToSubscriber, _super);\n    function SwitchMapToSubscriber(destination, inner, resultSelector) {\n        _super.call(this, destination);\n        this.inner = inner;\n        this.resultSelector = resultSelector;\n        this.index = 0;\n    }\n    SwitchMapToSubscriber.prototype._next = function (value) {\n        var innerSubscription = this.innerSubscription;\n        if (innerSubscription) {\n            innerSubscription.unsubscribe();\n        }\n        this.add(this.innerSubscription = subscribeToResult_1.subscribeToResult(this, this.inner, value, this.index++));\n    };\n    SwitchMapToSubscriber.prototype._complete = function () {\n        var innerSubscription = this.innerSubscription;\n        if (!innerSubscription || innerSubscription.closed) {\n            _super.prototype._complete.call(this);\n        }\n    };\n    SwitchMapToSubscriber.prototype._unsubscribe = function () {\n        this.innerSubscription = null;\n    };\n    SwitchMapToSubscriber.prototype.notifyComplete = function (innerSub) {\n        this.remove(innerSub);\n        this.innerSubscription = null;\n        if (this.isStopped) {\n            _super.prototype._complete.call(this);\n        }\n    };\n    SwitchMapToSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;\n        if (resultSelector) {\n            this.tryResultSelector(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        else {\n            destination.next(innerValue);\n        }\n    };\n    SwitchMapToSubscriber.prototype.tryResultSelector = function (outerValue, innerValue, outerIndex, innerIndex) {\n        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;\n        var result;\n        try {\n            result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        catch (err) {\n            destination.error(err);\n            return;\n        }\n        destination.next(result);\n    };\n    return SwitchMapToSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=switchMapTo.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/switchMapTo.js\n ** module id = 315\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/switchMapTo.js?");

/***/ },
/* 316 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar take_1 = __webpack_require__(317);\nObservable_1.Observable.prototype.take = take_1.take;\n//# sourceMappingURL=take.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/take.js\n ** module id = 316\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/take.js?");

/***/ },
/* 317 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(8);\nvar ArgumentOutOfRangeError_1 = __webpack_require__(203);\nvar EmptyObservable_1 = __webpack_require__(52);\n/**\n * Emits only the first `count` values emitted by the source Observable.\n *\n * <span class=\"informal\">Takes the first `count` values from the source, then\n * completes.</span>\n *\n * <img src=\"./img/take.png\" width=\"100%\">\n *\n * `take` returns an Observable that emits only the first `count` values emitted\n * by the source Observable. If the source emits fewer than `count` values then\n * all of its values are emitted. After that, it completes, regardless if the\n * source completes.\n *\n * @example <caption>Take the first 5 seconds of an infinite 1-second interval Observable</caption>\n * var interval = Rx.Observable.interval(1000);\n * var five = interval.take(5);\n * five.subscribe(x => console.log(x));\n *\n * @see {@link takeLast}\n * @see {@link takeUntil}\n * @see {@link takeWhile}\n * @see {@link skip}\n *\n * @throws {ArgumentOutOfRangeError} When using `take(i)`, it delivers an\n * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.\n *\n * @param {number} count The maximum number of `next` values to emit.\n * @return {Observable<T>} An Observable that emits only the first `count`\n * values emitted by the source Observable, or all of the values from the source\n * if the source emits fewer than `count` values.\n * @method take\n * @owner Observable\n */\nfunction take(count) {\n    if (count === 0) {\n        return new EmptyObservable_1.EmptyObservable();\n    }\n    else {\n        return this.lift(new TakeOperator(count));\n    }\n}\nexports.take = take;\nvar TakeOperator = (function () {\n    function TakeOperator(total) {\n        this.total = total;\n        if (this.total < 0) {\n            throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;\n        }\n    }\n    TakeOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new TakeSubscriber(subscriber, this.total));\n    };\n    return TakeOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar TakeSubscriber = (function (_super) {\n    __extends(TakeSubscriber, _super);\n    function TakeSubscriber(destination, total) {\n        _super.call(this, destination);\n        this.total = total;\n        this.count = 0;\n    }\n    TakeSubscriber.prototype._next = function (value) {\n        var total = this.total;\n        if (++this.count <= total) {\n            this.destination.next(value);\n            if (this.count === total) {\n                this.destination.complete();\n                this.unsubscribe();\n            }\n        }\n    };\n    return TakeSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=take.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/take.js\n ** module id = 317\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/take.js?");

/***/ },
/* 318 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar takeLast_1 = __webpack_require__(319);\nObservable_1.Observable.prototype.takeLast = takeLast_1.takeLast;\n//# sourceMappingURL=takeLast.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/takeLast.js\n ** module id = 318\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/takeLast.js?");

/***/ },
/* 319 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(8);\nvar ArgumentOutOfRangeError_1 = __webpack_require__(203);\nvar EmptyObservable_1 = __webpack_require__(52);\n/**\n * Emits only the last `count` values emitted by the source Observable.\n *\n * <span class=\"informal\">Remembers the latest `count` values, then emits those\n * only when the source completes.</span>\n *\n * <img src=\"./img/takeLast.png\" width=\"100%\">\n *\n * `takeLast` returns an Observable that emits at most the last `count` values\n * emitted by the source Observable. If the source emits fewer than `count`\n * values then all of its values are emitted. This operator must wait until the\n * `complete` notification emission from the source in order to emit the `next`\n * values on the output Observable, because otherwise it is impossible to know\n * whether or not more values will be emitted on the source. For this reason,\n * all values are emitted synchronously, followed by the complete notification.\n *\n * @example <caption>Take the last 3 values of an Observable with many values</caption>\n * var many = Rx.Observable.range(1, 100);\n * var lastThree = many.takeLast(3);\n * lastThree.subscribe(x => console.log(x));\n *\n * @see {@link take}\n * @see {@link takeUntil}\n * @see {@link takeWhile}\n * @see {@link skip}\n *\n * @throws {ArgumentOutOfRangeError} When using `takeLast(i)`, it delivers an\n * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.\n *\n * @param {number} count The maximum number of values to emit from the end of\n * the sequence of values emitted by the source Observable.\n * @return {Observable<T>} An Observable that emits at most the last count\n * values emitted by the source Observable.\n * @method takeLast\n * @owner Observable\n */\nfunction takeLast(count) {\n    if (count === 0) {\n        return new EmptyObservable_1.EmptyObservable();\n    }\n    else {\n        return this.lift(new TakeLastOperator(count));\n    }\n}\nexports.takeLast = takeLast;\nvar TakeLastOperator = (function () {\n    function TakeLastOperator(total) {\n        this.total = total;\n        if (this.total < 0) {\n            throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;\n        }\n    }\n    TakeLastOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new TakeLastSubscriber(subscriber, this.total));\n    };\n    return TakeLastOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar TakeLastSubscriber = (function (_super) {\n    __extends(TakeLastSubscriber, _super);\n    function TakeLastSubscriber(destination, total) {\n        _super.call(this, destination);\n        this.total = total;\n        this.ring = new Array();\n        this.count = 0;\n    }\n    TakeLastSubscriber.prototype._next = function (value) {\n        var ring = this.ring;\n        var total = this.total;\n        var count = this.count++;\n        if (ring.length < total) {\n            ring.push(value);\n        }\n        else {\n            var index = count % total;\n            ring[index] = value;\n        }\n    };\n    TakeLastSubscriber.prototype._complete = function () {\n        var destination = this.destination;\n        var count = this.count;\n        if (count > 0) {\n            var total = this.count >= this.total ? this.total : this.count;\n            var ring = this.ring;\n            for (var i = 0; i < total; i++) {\n                var idx = (count++) % total;\n                destination.next(ring[idx]);\n            }\n        }\n        destination.complete();\n    };\n    return TakeLastSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=takeLast.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/takeLast.js\n ** module id = 319\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/takeLast.js?");

/***/ },
/* 320 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar takeUntil_1 = __webpack_require__(321);\nObservable_1.Observable.prototype.takeUntil = takeUntil_1.takeUntil;\n//# sourceMappingURL=takeUntil.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/takeUntil.js\n ** module id = 320\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/takeUntil.js?");

/***/ },
/* 321 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = __webpack_require__(54);\nvar subscribeToResult_1 = __webpack_require__(55);\n/**\n * Emits the values emitted by the source Observable until a `notifier`\n * Observable emits a value.\n *\n * <span class=\"informal\">Lets values pass until a second Observable,\n * `notifier`, emits something. Then, it completes.</span>\n *\n * <img src=\"./img/takeUntil.png\" width=\"100%\">\n *\n * `takeUntil` subscribes and begins mirroring the source Observable. It also\n * monitors a second Observable, `notifier` that you provide. If the `notifier`\n * emits a value or a complete notification, the output Observable stops\n * mirroring the source Observable and completes.\n *\n * @example <caption>Tick every second until the first click happens</caption>\n * var interval = Rx.Observable.interval(1000);\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = interval.takeUntil(clicks);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link take}\n * @see {@link takeLast}\n * @see {@link takeWhile}\n * @see {@link skip}\n *\n * @param {Observable} notifier The Observable whose first emitted value will\n * cause the output Observable of `takeUntil` to stop emitting values from the\n * source Observable.\n * @return {Observable<T>} An Observable that emits the values from the source\n * Observable until such time as `notifier` emits its first value.\n * @method takeUntil\n * @owner Observable\n */\nfunction takeUntil(notifier) {\n    return this.lift(new TakeUntilOperator(notifier));\n}\nexports.takeUntil = takeUntil;\nvar TakeUntilOperator = (function () {\n    function TakeUntilOperator(notifier) {\n        this.notifier = notifier;\n    }\n    TakeUntilOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new TakeUntilSubscriber(subscriber, this.notifier));\n    };\n    return TakeUntilOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar TakeUntilSubscriber = (function (_super) {\n    __extends(TakeUntilSubscriber, _super);\n    function TakeUntilSubscriber(destination, notifier) {\n        _super.call(this, destination);\n        this.notifier = notifier;\n        this.add(subscribeToResult_1.subscribeToResult(this, notifier));\n    }\n    TakeUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.complete();\n    };\n    TakeUntilSubscriber.prototype.notifyComplete = function () {\n        // noop\n    };\n    return TakeUntilSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=takeUntil.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/takeUntil.js\n ** module id = 321\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/takeUntil.js?");

/***/ },
/* 322 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar takeWhile_1 = __webpack_require__(323);\nObservable_1.Observable.prototype.takeWhile = takeWhile_1.takeWhile;\n//# sourceMappingURL=takeWhile.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/takeWhile.js\n ** module id = 322\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/takeWhile.js?");

/***/ },
/* 323 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(8);\n/**\n * Emits values emitted by the source Observable so long as each value satisfies\n * the given `predicate`, and then completes as soon as this `predicate` is not\n * satisfied.\n *\n * <span class=\"informal\">Takes values from the source only while they pass the\n * condition given. When the first value does not satisfy, it completes.</span>\n *\n * <img src=\"./img/takeWhile.png\" width=\"100%\">\n *\n * `takeWhile` subscribes and begins mirroring the source Observable. Each value\n * emitted on the source is given to the `predicate` function which returns a\n * boolean, representing a condition to be satisfied by the source values. The\n * output Observable emits the source values until such time as the `predicate`\n * returns false, at which point `takeWhile` stops mirroring the source\n * Observable and completes the output Observable.\n *\n * @example <caption>Emit click events only while the clientX property is greater than 200</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.takeWhile(ev => ev.clientX > 200);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link take}\n * @see {@link takeLast}\n * @see {@link takeUntil}\n * @see {@link skip}\n *\n * @param {function(value: T, index: number): boolean} predicate A function that\n * evaluates a value emitted by the source Observable and returns a boolean.\n * Also takes the (zero-based) index as the second argument.\n * @return {Observable<T>} An Observable that emits the values from the source\n * Observable so long as each value satisfies the condition defined by the\n * `predicate`, then completes.\n * @method takeWhile\n * @owner Observable\n */\nfunction takeWhile(predicate) {\n    return this.lift(new TakeWhileOperator(predicate));\n}\nexports.takeWhile = takeWhile;\nvar TakeWhileOperator = (function () {\n    function TakeWhileOperator(predicate) {\n        this.predicate = predicate;\n    }\n    TakeWhileOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new TakeWhileSubscriber(subscriber, this.predicate));\n    };\n    return TakeWhileOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar TakeWhileSubscriber = (function (_super) {\n    __extends(TakeWhileSubscriber, _super);\n    function TakeWhileSubscriber(destination, predicate) {\n        _super.call(this, destination);\n        this.predicate = predicate;\n        this.index = 0;\n    }\n    TakeWhileSubscriber.prototype._next = function (value) {\n        var destination = this.destination;\n        var result;\n        try {\n            result = this.predicate(value, this.index++);\n        }\n        catch (err) {\n            destination.error(err);\n            return;\n        }\n        this.nextOrComplete(value, result);\n    };\n    TakeWhileSubscriber.prototype.nextOrComplete = function (value, predicateResult) {\n        var destination = this.destination;\n        if (Boolean(predicateResult)) {\n            destination.next(value);\n        }\n        else {\n            destination.complete();\n        }\n    };\n    return TakeWhileSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=takeWhile.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/takeWhile.js\n ** module id = 323\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/takeWhile.js?");

/***/ },
/* 324 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar throttle_1 = __webpack_require__(325);\nObservable_1.Observable.prototype.throttle = throttle_1.throttle;\n//# sourceMappingURL=throttle.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/throttle.js\n ** module id = 324\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/throttle.js?");

/***/ },
/* 325 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = __webpack_require__(54);\nvar subscribeToResult_1 = __webpack_require__(55);\n/**\n * Emits a value from the source Observable, then ignores subsequent source\n * values for a duration determined by another Observable, then repeats this\n * process.\n *\n * <span class=\"informal\">It's like {@link throttleTime}, but the silencing\n * duration is determined by a second Observable.</span>\n *\n * <img src=\"./img/throttle.png\" width=\"100%\">\n *\n * `throttle` emits the source Observable values on the output Observable\n * when its internal timer is disabled, and ignores source values when the timer\n * is enabled. Initially, the timer is disabled. As soon as the first source\n * value arrives, it is forwarded to the output Observable, and then the timer\n * is enabled by calling the `durationSelector` function with the source value,\n * which returns the \"duration\" Observable. When the duration Observable emits a\n * value or completes, the timer is disabled, and this process repeats for the\n * next source value.\n *\n * @example <caption>Emit clicks at a rate of at most one click per second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.throttle(ev => Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link audit}\n * @see {@link debounce}\n * @see {@link delayWhen}\n * @see {@link sample}\n * @see {@link throttleTime}\n *\n * @param {function(value: T): Observable|Promise} durationSelector A function\n * that receives a value from the source Observable, for computing the silencing\n * duration for each source value, returned as an Observable or a Promise.\n * @return {Observable<T>} An Observable that performs the throttle operation to\n * limit the rate of emissions from the source.\n * @method throttle\n * @owner Observable\n */\nfunction throttle(durationSelector) {\n    return this.lift(new ThrottleOperator(durationSelector));\n}\nexports.throttle = throttle;\nvar ThrottleOperator = (function () {\n    function ThrottleOperator(durationSelector) {\n        this.durationSelector = durationSelector;\n    }\n    ThrottleOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new ThrottleSubscriber(subscriber, this.durationSelector));\n    };\n    return ThrottleOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar ThrottleSubscriber = (function (_super) {\n    __extends(ThrottleSubscriber, _super);\n    function ThrottleSubscriber(destination, durationSelector) {\n        _super.call(this, destination);\n        this.destination = destination;\n        this.durationSelector = durationSelector;\n    }\n    ThrottleSubscriber.prototype._next = function (value) {\n        if (!this.throttled) {\n            this.tryDurationSelector(value);\n        }\n    };\n    ThrottleSubscriber.prototype.tryDurationSelector = function (value) {\n        var duration = null;\n        try {\n            duration = this.durationSelector(value);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.emitAndThrottle(value, duration);\n    };\n    ThrottleSubscriber.prototype.emitAndThrottle = function (value, duration) {\n        this.add(this.throttled = subscribeToResult_1.subscribeToResult(this, duration));\n        this.destination.next(value);\n    };\n    ThrottleSubscriber.prototype._unsubscribe = function () {\n        var throttled = this.throttled;\n        if (throttled) {\n            this.remove(throttled);\n            this.throttled = null;\n            throttled.unsubscribe();\n        }\n    };\n    ThrottleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this._unsubscribe();\n    };\n    ThrottleSubscriber.prototype.notifyComplete = function () {\n        this._unsubscribe();\n    };\n    return ThrottleSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=throttle.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/throttle.js\n ** module id = 325\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/throttle.js?");

/***/ },
/* 326 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar throttleTime_1 = __webpack_require__(327);\nObservable_1.Observable.prototype.throttleTime = throttleTime_1.throttleTime;\n//# sourceMappingURL=throttleTime.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/throttleTime.js\n ** module id = 326\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/throttleTime.js?");

/***/ },
/* 327 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(8);\nvar async_1 = __webpack_require__(96);\n/**\n * Emits a value from the source Observable, then ignores subsequent source\n * values for `duration` milliseconds, then repeats this process.\n *\n * <span class=\"informal\">Lets a value pass, then ignores source values for the\n * next `duration` milliseconds.</span>\n *\n * <img src=\"./img/throttleTime.png\" width=\"100%\">\n *\n * `throttleTime` emits the source Observable values on the output Observable\n * when its internal timer is disabled, and ignores source values when the timer\n * is enabled. Initially, the timer is disabled. As soon as the first source\n * value arrives, it is forwarded to the output Observable, and then the timer\n * is enabled. After `duration` milliseconds (or the time unit determined\n * internally by the optional `scheduler`) has passed, the timer is disabled,\n * and this process repeats for the next source value. Optionally takes a\n * {@link Scheduler} for managing timers.\n *\n * @example <caption>Emit clicks at a rate of at most one click per second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.throttleTime(1000);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link auditTime}\n * @see {@link debounceTime}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttle}\n *\n * @param {number} duration Time to wait before emitting another value after\n * emitting the last value, measured in milliseconds or the time unit determined\n * internally by the optional `scheduler`.\n * @param {Scheduler} [scheduler=async] The {@link Scheduler} to use for\n * managing the timers that handle the sampling.\n * @return {Observable<T>} An Observable that performs the throttle operation to\n * limit the rate of emissions from the source.\n * @method throttleTime\n * @owner Observable\n */\nfunction throttleTime(duration, scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    return this.lift(new ThrottleTimeOperator(duration, scheduler));\n}\nexports.throttleTime = throttleTime;\nvar ThrottleTimeOperator = (function () {\n    function ThrottleTimeOperator(duration, scheduler) {\n        this.duration = duration;\n        this.scheduler = scheduler;\n    }\n    ThrottleTimeOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new ThrottleTimeSubscriber(subscriber, this.duration, this.scheduler));\n    };\n    return ThrottleTimeOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar ThrottleTimeSubscriber = (function (_super) {\n    __extends(ThrottleTimeSubscriber, _super);\n    function ThrottleTimeSubscriber(destination, duration, scheduler) {\n        _super.call(this, destination);\n        this.duration = duration;\n        this.scheduler = scheduler;\n    }\n    ThrottleTimeSubscriber.prototype._next = function (value) {\n        if (!this.throttled) {\n            this.add(this.throttled = this.scheduler.schedule(dispatchNext, this.duration, { subscriber: this }));\n            this.destination.next(value);\n        }\n    };\n    ThrottleTimeSubscriber.prototype.clearThrottle = function () {\n        var throttled = this.throttled;\n        if (throttled) {\n            throttled.unsubscribe();\n            this.remove(throttled);\n            this.throttled = null;\n        }\n    };\n    return ThrottleTimeSubscriber;\n}(Subscriber_1.Subscriber));\nfunction dispatchNext(arg) {\n    var subscriber = arg.subscriber;\n    subscriber.clearThrottle();\n}\n//# sourceMappingURL=throttleTime.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/throttleTime.js\n ** module id = 327\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/throttleTime.js?");

/***/ },
/* 328 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar timeInterval_1 = __webpack_require__(329);\nObservable_1.Observable.prototype.timeInterval = timeInterval_1.timeInterval;\n//# sourceMappingURL=timeInterval.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/timeInterval.js\n ** module id = 328\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/timeInterval.js?");

/***/ },
/* 329 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(8);\nvar async_1 = __webpack_require__(96);\n/**\n * @param scheduler\n * @return {Observable<TimeInterval<any>>|WebSocketSubject<T>|Observable<T>}\n * @method timeInterval\n * @owner Observable\n */\nfunction timeInterval(scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    return this.lift(new TimeIntervalOperator(scheduler));\n}\nexports.timeInterval = timeInterval;\nvar TimeInterval = (function () {\n    function TimeInterval(value, interval) {\n        this.value = value;\n        this.interval = interval;\n    }\n    return TimeInterval;\n}());\nexports.TimeInterval = TimeInterval;\n;\nvar TimeIntervalOperator = (function () {\n    function TimeIntervalOperator(scheduler) {\n        this.scheduler = scheduler;\n    }\n    TimeIntervalOperator.prototype.call = function (observer, source) {\n        return source._subscribe(new TimeIntervalSubscriber(observer, this.scheduler));\n    };\n    return TimeIntervalOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar TimeIntervalSubscriber = (function (_super) {\n    __extends(TimeIntervalSubscriber, _super);\n    function TimeIntervalSubscriber(destination, scheduler) {\n        _super.call(this, destination);\n        this.scheduler = scheduler;\n        this.lastTime = 0;\n        this.lastTime = scheduler.now();\n    }\n    TimeIntervalSubscriber.prototype._next = function (value) {\n        var now = this.scheduler.now();\n        var span = now - this.lastTime;\n        this.lastTime = now;\n        this.destination.next(new TimeInterval(value, span));\n    };\n    return TimeIntervalSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=timeInterval.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/timeInterval.js\n ** module id = 329\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/timeInterval.js?");

/***/ },
/* 330 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar timeout_1 = __webpack_require__(331);\nObservable_1.Observable.prototype.timeout = timeout_1.timeout;\n//# sourceMappingURL=timeout.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/timeout.js\n ** module id = 330\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/timeout.js?");

/***/ },
/* 331 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar async_1 = __webpack_require__(96);\nvar isDate_1 = __webpack_require__(129);\nvar Subscriber_1 = __webpack_require__(8);\n/**\n * @param due\n * @param errorToSend\n * @param scheduler\n * @return {Observable<R>|WebSocketSubject<T>|Observable<T>}\n * @method timeout\n * @owner Observable\n */\nfunction timeout(due, errorToSend, scheduler) {\n    if (errorToSend === void 0) { errorToSend = null; }\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    var absoluteTimeout = isDate_1.isDate(due);\n    var waitFor = absoluteTimeout ? (+due - scheduler.now()) : Math.abs(due);\n    return this.lift(new TimeoutOperator(waitFor, absoluteTimeout, errorToSend, scheduler));\n}\nexports.timeout = timeout;\nvar TimeoutOperator = (function () {\n    function TimeoutOperator(waitFor, absoluteTimeout, errorToSend, scheduler) {\n        this.waitFor = waitFor;\n        this.absoluteTimeout = absoluteTimeout;\n        this.errorToSend = errorToSend;\n        this.scheduler = scheduler;\n    }\n    TimeoutOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new TimeoutSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.errorToSend, this.scheduler));\n    };\n    return TimeoutOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar TimeoutSubscriber = (function (_super) {\n    __extends(TimeoutSubscriber, _super);\n    function TimeoutSubscriber(destination, absoluteTimeout, waitFor, errorToSend, scheduler) {\n        _super.call(this, destination);\n        this.absoluteTimeout = absoluteTimeout;\n        this.waitFor = waitFor;\n        this.errorToSend = errorToSend;\n        this.scheduler = scheduler;\n        this.index = 0;\n        this._previousIndex = 0;\n        this._hasCompleted = false;\n        this.scheduleTimeout();\n    }\n    Object.defineProperty(TimeoutSubscriber.prototype, \"previousIndex\", {\n        get: function () {\n            return this._previousIndex;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(TimeoutSubscriber.prototype, \"hasCompleted\", {\n        get: function () {\n            return this._hasCompleted;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    TimeoutSubscriber.dispatchTimeout = function (state) {\n        var source = state.subscriber;\n        var currentIndex = state.index;\n        if (!source.hasCompleted && source.previousIndex === currentIndex) {\n            source.notifyTimeout();\n        }\n    };\n    TimeoutSubscriber.prototype.scheduleTimeout = function () {\n        var currentIndex = this.index;\n        this.scheduler.schedule(TimeoutSubscriber.dispatchTimeout, this.waitFor, { subscriber: this, index: currentIndex });\n        this.index++;\n        this._previousIndex = currentIndex;\n    };\n    TimeoutSubscriber.prototype._next = function (value) {\n        this.destination.next(value);\n        if (!this.absoluteTimeout) {\n            this.scheduleTimeout();\n        }\n    };\n    TimeoutSubscriber.prototype._error = function (err) {\n        this.destination.error(err);\n        this._hasCompleted = true;\n    };\n    TimeoutSubscriber.prototype._complete = function () {\n        this.destination.complete();\n        this._hasCompleted = true;\n    };\n    TimeoutSubscriber.prototype.notifyTimeout = function () {\n        this.error(this.errorToSend || new Error('timeout'));\n    };\n    return TimeoutSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=timeout.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/timeout.js\n ** module id = 331\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/timeout.js?");

/***/ },
/* 332 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar timeoutWith_1 = __webpack_require__(333);\nObservable_1.Observable.prototype.timeoutWith = timeoutWith_1.timeoutWith;\n//# sourceMappingURL=timeoutWith.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/timeoutWith.js\n ** module id = 332\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/timeoutWith.js?");

/***/ },
/* 333 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar async_1 = __webpack_require__(96);\nvar isDate_1 = __webpack_require__(129);\nvar OuterSubscriber_1 = __webpack_require__(54);\nvar subscribeToResult_1 = __webpack_require__(55);\n/**\n * @param due\n * @param withObservable\n * @param scheduler\n * @return {Observable<R>|WebSocketSubject<T>|Observable<T>}\n * @method timeoutWith\n * @owner Observable\n */\nfunction timeoutWith(due, withObservable, scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    var absoluteTimeout = isDate_1.isDate(due);\n    var waitFor = absoluteTimeout ? (+due - scheduler.now()) : Math.abs(due);\n    return this.lift(new TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler));\n}\nexports.timeoutWith = timeoutWith;\nvar TimeoutWithOperator = (function () {\n    function TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler) {\n        this.waitFor = waitFor;\n        this.absoluteTimeout = absoluteTimeout;\n        this.withObservable = withObservable;\n        this.scheduler = scheduler;\n    }\n    TimeoutWithOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new TimeoutWithSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler));\n    };\n    return TimeoutWithOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar TimeoutWithSubscriber = (function (_super) {\n    __extends(TimeoutWithSubscriber, _super);\n    function TimeoutWithSubscriber(destination, absoluteTimeout, waitFor, withObservable, scheduler) {\n        _super.call(this);\n        this.destination = destination;\n        this.absoluteTimeout = absoluteTimeout;\n        this.waitFor = waitFor;\n        this.withObservable = withObservable;\n        this.scheduler = scheduler;\n        this.timeoutSubscription = undefined;\n        this.index = 0;\n        this._previousIndex = 0;\n        this._hasCompleted = false;\n        destination.add(this);\n        this.scheduleTimeout();\n    }\n    Object.defineProperty(TimeoutWithSubscriber.prototype, \"previousIndex\", {\n        get: function () {\n            return this._previousIndex;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(TimeoutWithSubscriber.prototype, \"hasCompleted\", {\n        get: function () {\n            return this._hasCompleted;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    TimeoutWithSubscriber.dispatchTimeout = function (state) {\n        var source = state.subscriber;\n        var currentIndex = state.index;\n        if (!source.hasCompleted && source.previousIndex === currentIndex) {\n            source.handleTimeout();\n        }\n    };\n    TimeoutWithSubscriber.prototype.scheduleTimeout = function () {\n        var currentIndex = this.index;\n        var timeoutState = { subscriber: this, index: currentIndex };\n        this.scheduler.schedule(TimeoutWithSubscriber.dispatchTimeout, this.waitFor, timeoutState);\n        this.index++;\n        this._previousIndex = currentIndex;\n    };\n    TimeoutWithSubscriber.prototype._next = function (value) {\n        this.destination.next(value);\n        if (!this.absoluteTimeout) {\n            this.scheduleTimeout();\n        }\n    };\n    TimeoutWithSubscriber.prototype._error = function (err) {\n        this.destination.error(err);\n        this._hasCompleted = true;\n    };\n    TimeoutWithSubscriber.prototype._complete = function () {\n        this.destination.complete();\n        this._hasCompleted = true;\n    };\n    TimeoutWithSubscriber.prototype.handleTimeout = function () {\n        if (!this.closed) {\n            var withObservable = this.withObservable;\n            this.unsubscribe();\n            this.destination.add(this.timeoutSubscription = subscribeToResult_1.subscribeToResult(this, withObservable));\n        }\n    };\n    return TimeoutWithSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=timeoutWith.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/timeoutWith.js\n ** module id = 333\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/timeoutWith.js?");

/***/ },
/* 334 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar timestamp_1 = __webpack_require__(335);\nObservable_1.Observable.prototype.timestamp = timestamp_1.timestamp;\n//# sourceMappingURL=timestamp.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/timestamp.js\n ** module id = 334\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/timestamp.js?");

/***/ },
/* 335 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(8);\nvar async_1 = __webpack_require__(96);\n/**\n * @param scheduler\n * @return {Observable<Timestamp<any>>|WebSocketSubject<T>|Observable<T>}\n * @method timestamp\n * @owner Observable\n */\nfunction timestamp(scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    return this.lift(new TimestampOperator(scheduler));\n}\nexports.timestamp = timestamp;\nvar Timestamp = (function () {\n    function Timestamp(value, timestamp) {\n        this.value = value;\n        this.timestamp = timestamp;\n    }\n    return Timestamp;\n}());\nexports.Timestamp = Timestamp;\n;\nvar TimestampOperator = (function () {\n    function TimestampOperator(scheduler) {\n        this.scheduler = scheduler;\n    }\n    TimestampOperator.prototype.call = function (observer, source) {\n        return source._subscribe(new TimestampSubscriber(observer, this.scheduler));\n    };\n    return TimestampOperator;\n}());\nvar TimestampSubscriber = (function (_super) {\n    __extends(TimestampSubscriber, _super);\n    function TimestampSubscriber(destination, scheduler) {\n        _super.call(this, destination);\n        this.scheduler = scheduler;\n    }\n    TimestampSubscriber.prototype._next = function (value) {\n        var now = this.scheduler.now();\n        this.destination.next(new Timestamp(value, now));\n    };\n    return TimestampSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=timestamp.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/timestamp.js\n ** module id = 335\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/timestamp.js?");

/***/ },
/* 336 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar toArray_1 = __webpack_require__(337);\nObservable_1.Observable.prototype.toArray = toArray_1.toArray;\n//# sourceMappingURL=toArray.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/toArray.js\n ** module id = 336\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/toArray.js?");

/***/ },
/* 337 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(8);\n/**\n * @return {Observable<any[]>|WebSocketSubject<T>|Observable<T>}\n * @method toArray\n * @owner Observable\n */\nfunction toArray() {\n    return this.lift(new ToArrayOperator());\n}\nexports.toArray = toArray;\nvar ToArrayOperator = (function () {\n    function ToArrayOperator() {\n    }\n    ToArrayOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new ToArraySubscriber(subscriber));\n    };\n    return ToArrayOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar ToArraySubscriber = (function (_super) {\n    __extends(ToArraySubscriber, _super);\n    function ToArraySubscriber(destination) {\n        _super.call(this, destination);\n        this.array = [];\n    }\n    ToArraySubscriber.prototype._next = function (x) {\n        this.array.push(x);\n    };\n    ToArraySubscriber.prototype._complete = function () {\n        this.destination.next(this.array);\n        this.destination.complete();\n    };\n    return ToArraySubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=toArray.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/toArray.js\n ** module id = 337\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/toArray.js?");

/***/ },
/* 338 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar toPromise_1 = __webpack_require__(339);\nObservable_1.Observable.prototype.toPromise = toPromise_1.toPromise;\n//# sourceMappingURL=toPromise.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/toPromise.js\n ** module id = 338\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/toPromise.js?");

/***/ },
/* 339 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar root_1 = __webpack_require__(6);\n/**\n * @param PromiseCtor\n * @return {Promise<T>}\n * @method toPromise\n * @owner Observable\n */\nfunction toPromise(PromiseCtor) {\n    var _this = this;\n    if (!PromiseCtor) {\n        if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {\n            PromiseCtor = root_1.root.Rx.config.Promise;\n        }\n        else if (root_1.root.Promise) {\n            PromiseCtor = root_1.root.Promise;\n        }\n    }\n    if (!PromiseCtor) {\n        throw new Error('no Promise impl found');\n    }\n    return new PromiseCtor(function (resolve, reject) {\n        var value;\n        _this.subscribe(function (x) { return value = x; }, function (err) { return reject(err); }, function () { return resolve(value); });\n    });\n}\nexports.toPromise = toPromise;\n//# sourceMappingURL=toPromise.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/toPromise.js\n ** module id = 339\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/toPromise.js?");

/***/ },
/* 340 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar window_1 = __webpack_require__(341);\nObservable_1.Observable.prototype.window = window_1.window;\n//# sourceMappingURL=window.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/window.js\n ** module id = 340\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/window.js?");

/***/ },
/* 341 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = __webpack_require__(4);\nvar OuterSubscriber_1 = __webpack_require__(54);\nvar subscribeToResult_1 = __webpack_require__(55);\n/**\n * Branch out the source Observable values as a nested Observable whenever\n * `windowBoundaries` emits.\n *\n * <span class=\"informal\">It's like {@link buffer}, but emits a nested Observable\n * instead of an array.</span>\n *\n * <img src=\"./img/window.png\" width=\"100%\">\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits connected, non-overlapping\n * windows. It emits the current window and opens a new one whenever the\n * Observable `windowBoundaries` emits an item. Because each window is an\n * Observable, the output is a higher-order Observable.\n *\n * @example <caption>In every window of 1 second each, emit at most 2 click events</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var interval = Rx.Observable.interval(1000);\n * var result = clicks.window(interval)\n *   .map(win => win.take(2)) // each window has at most 2 emissions\n *   .mergeAll(); // flatten the Observable-of-Observables\n * result.subscribe(x => console.log(x));\n *\n * @see {@link windowCount}\n * @see {@link windowTime}\n * @see {@link windowToggle}\n * @see {@link windowWhen}\n * @see {@link buffer}\n *\n * @param {Observable<any>} windowBoundaries An Observable that completes the\n * previous window and starts a new window.\n * @return {Observable<Observable<T>>} An Observable of windows, which are\n * Observables emitting values of the source Observable.\n * @method window\n * @owner Observable\n */\nfunction window(windowBoundaries) {\n    return this.lift(new WindowOperator(windowBoundaries));\n}\nexports.window = window;\nvar WindowOperator = (function () {\n    function WindowOperator(windowBoundaries) {\n        this.windowBoundaries = windowBoundaries;\n    }\n    WindowOperator.prototype.call = function (subscriber, source) {\n        var windowSubscriber = new WindowSubscriber(subscriber);\n        var sourceSubscription = source._subscribe(windowSubscriber);\n        if (!sourceSubscription.closed) {\n            windowSubscriber.add(subscribeToResult_1.subscribeToResult(windowSubscriber, this.windowBoundaries));\n        }\n        return sourceSubscription;\n    };\n    return WindowOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar WindowSubscriber = (function (_super) {\n    __extends(WindowSubscriber, _super);\n    function WindowSubscriber(destination) {\n        _super.call(this, destination);\n        this.window = new Subject_1.Subject();\n        destination.next(this.window);\n    }\n    WindowSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.openWindow();\n    };\n    WindowSubscriber.prototype.notifyError = function (error, innerSub) {\n        this._error(error);\n    };\n    WindowSubscriber.prototype.notifyComplete = function (innerSub) {\n        this._complete();\n    };\n    WindowSubscriber.prototype._next = function (value) {\n        this.window.next(value);\n    };\n    WindowSubscriber.prototype._error = function (err) {\n        this.window.error(err);\n        this.destination.error(err);\n    };\n    WindowSubscriber.prototype._complete = function () {\n        this.window.complete();\n        this.destination.complete();\n    };\n    WindowSubscriber.prototype._unsubscribe = function () {\n        this.window = null;\n    };\n    WindowSubscriber.prototype.openWindow = function () {\n        var prevWindow = this.window;\n        if (prevWindow) {\n            prevWindow.complete();\n        }\n        var destination = this.destination;\n        var newWindow = this.window = new Subject_1.Subject();\n        destination.next(newWindow);\n    };\n    return WindowSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=window.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/window.js\n ** module id = 341\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/window.js?");

/***/ },
/* 342 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar windowCount_1 = __webpack_require__(343);\nObservable_1.Observable.prototype.windowCount = windowCount_1.windowCount;\n//# sourceMappingURL=windowCount.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/windowCount.js\n ** module id = 342\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/windowCount.js?");

/***/ },
/* 343 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(8);\nvar Subject_1 = __webpack_require__(4);\n/**\n * Branch out the source Observable values as a nested Observable with each\n * nested Observable emitting at most `windowSize` values.\n *\n * <span class=\"informal\">It's like {@link bufferCount}, but emits a nested\n * Observable instead of an array.</span>\n *\n * <img src=\"./img/windowCount.png\" width=\"100%\">\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits windows every `startWindowEvery`\n * items, each containing no more than `windowSize` items. When the source\n * Observable completes or encounters an error, the output Observable emits\n * the current window and propagates the notification from the source\n * Observable. If `startWindowEvery` is not provided, then new windows are\n * started immediately at the start of the source and when each window completes\n * with size `windowSize`.\n *\n * @example <caption>Ignore every 3rd click event, starting from the first one</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.windowCount(3)\n *   .map(win => win.skip(1)) // skip first of every 3 clicks\n *   .mergeAll(); // flatten the Observable-of-Observables\n * result.subscribe(x => console.log(x));\n *\n * @example <caption>Ignore every 3rd click event, starting from the third one</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.windowCount(2, 3)\n *   .mergeAll(); // flatten the Observable-of-Observables\n * result.subscribe(x => console.log(x));\n *\n * @see {@link window}\n * @see {@link windowTime}\n * @see {@link windowToggle}\n * @see {@link windowWhen}\n * @see {@link bufferCount}\n *\n * @param {number} windowSize The maximum number of values emitted by each\n * window.\n * @param {number} [startWindowEvery] Interval at which to start a new window.\n * For example if `startWindowEvery` is `2`, then a new window will be started\n * on every other value from the source. A new window is started at the\n * beginning of the source by default.\n * @return {Observable<Observable<T>>} An Observable of windows, which in turn\n * are Observable of values.\n * @method windowCount\n * @owner Observable\n */\nfunction windowCount(windowSize, startWindowEvery) {\n    if (startWindowEvery === void 0) { startWindowEvery = 0; }\n    return this.lift(new WindowCountOperator(windowSize, startWindowEvery));\n}\nexports.windowCount = windowCount;\nvar WindowCountOperator = (function () {\n    function WindowCountOperator(windowSize, startWindowEvery) {\n        this.windowSize = windowSize;\n        this.startWindowEvery = startWindowEvery;\n    }\n    WindowCountOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new WindowCountSubscriber(subscriber, this.windowSize, this.startWindowEvery));\n    };\n    return WindowCountOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar WindowCountSubscriber = (function (_super) {\n    __extends(WindowCountSubscriber, _super);\n    function WindowCountSubscriber(destination, windowSize, startWindowEvery) {\n        _super.call(this, destination);\n        this.destination = destination;\n        this.windowSize = windowSize;\n        this.startWindowEvery = startWindowEvery;\n        this.windows = [new Subject_1.Subject()];\n        this.count = 0;\n        destination.next(this.windows[0]);\n    }\n    WindowCountSubscriber.prototype._next = function (value) {\n        var startWindowEvery = (this.startWindowEvery > 0) ? this.startWindowEvery : this.windowSize;\n        var destination = this.destination;\n        var windowSize = this.windowSize;\n        var windows = this.windows;\n        var len = windows.length;\n        for (var i = 0; i < len && !this.closed; i++) {\n            windows[i].next(value);\n        }\n        var c = this.count - windowSize + 1;\n        if (c >= 0 && c % startWindowEvery === 0 && !this.closed) {\n            windows.shift().complete();\n        }\n        if (++this.count % startWindowEvery === 0 && !this.closed) {\n            var window_1 = new Subject_1.Subject();\n            windows.push(window_1);\n            destination.next(window_1);\n        }\n    };\n    WindowCountSubscriber.prototype._error = function (err) {\n        var windows = this.windows;\n        if (windows) {\n            while (windows.length > 0 && !this.closed) {\n                windows.shift().error(err);\n            }\n        }\n        this.destination.error(err);\n    };\n    WindowCountSubscriber.prototype._complete = function () {\n        var windows = this.windows;\n        if (windows) {\n            while (windows.length > 0 && !this.closed) {\n                windows.shift().complete();\n            }\n        }\n        this.destination.complete();\n    };\n    WindowCountSubscriber.prototype._unsubscribe = function () {\n        this.count = 0;\n        this.windows = null;\n    };\n    return WindowCountSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=windowCount.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/windowCount.js\n ** module id = 343\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/windowCount.js?");

/***/ },
/* 344 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar windowTime_1 = __webpack_require__(345);\nObservable_1.Observable.prototype.windowTime = windowTime_1.windowTime;\n//# sourceMappingURL=windowTime.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/windowTime.js\n ** module id = 344\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/windowTime.js?");

/***/ },
/* 345 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = __webpack_require__(4);\nvar async_1 = __webpack_require__(96);\nvar Subscriber_1 = __webpack_require__(8);\n/**\n * Branch out the source Observable values as a nested Observable periodically\n * in time.\n *\n * <span class=\"informal\">It's like {@link bufferTime}, but emits a nested\n * Observable instead of an array.</span>\n *\n * <img src=\"./img/windowTime.png\" width=\"100%\">\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable starts a new window periodically, as\n * determined by the `windowCreationInterval` argument. It emits each window\n * after a fixed timespan, specified by the `windowTimeSpan` argument. When the\n * source Observable completes or encounters an error, the output Observable\n * emits the current window and propagates the notification from the source\n * Observable. If `windowCreationInterval` is not provided, the output\n * Observable starts a new window when the previous window of duration\n * `windowTimeSpan` completes.\n *\n * @example <caption>In every window of 1 second each, emit at most 2 click events</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.windowTime(1000)\n *   .map(win => win.take(2)) // each window has at most 2 emissions\n *   .mergeAll(); // flatten the Observable-of-Observables\n * result.subscribe(x => console.log(x));\n *\n * @example <caption>Every 5 seconds start a window 1 second long, and emit at most 2 click events per window</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.windowTime(1000, 5000)\n *   .map(win => win.take(2)) // each window has at most 2 emissions\n *   .mergeAll(); // flatten the Observable-of-Observables\n * result.subscribe(x => console.log(x));\n *\n * @see {@link window}\n * @see {@link windowCount}\n * @see {@link windowToggle}\n * @see {@link windowWhen}\n * @see {@link bufferTime}\n *\n * @param {number} windowTimeSpan The amount of time to fill each window.\n * @param {number} [windowCreationInterval] The interval at which to start new\n * windows.\n * @param {Scheduler} [scheduler=async] The scheduler on which to schedule the\n * intervals that determine window boundaries.\n * @return {Observable<Observable<T>>} An observable of windows, which in turn\n * are Observables.\n * @method windowTime\n * @owner Observable\n */\nfunction windowTime(windowTimeSpan, windowCreationInterval, scheduler) {\n    if (windowCreationInterval === void 0) { windowCreationInterval = null; }\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    return this.lift(new WindowTimeOperator(windowTimeSpan, windowCreationInterval, scheduler));\n}\nexports.windowTime = windowTime;\nvar WindowTimeOperator = (function () {\n    function WindowTimeOperator(windowTimeSpan, windowCreationInterval, scheduler) {\n        this.windowTimeSpan = windowTimeSpan;\n        this.windowCreationInterval = windowCreationInterval;\n        this.scheduler = scheduler;\n    }\n    WindowTimeOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new WindowTimeSubscriber(subscriber, this.windowTimeSpan, this.windowCreationInterval, this.scheduler));\n    };\n    return WindowTimeOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar WindowTimeSubscriber = (function (_super) {\n    __extends(WindowTimeSubscriber, _super);\n    function WindowTimeSubscriber(destination, windowTimeSpan, windowCreationInterval, scheduler) {\n        _super.call(this, destination);\n        this.destination = destination;\n        this.windowTimeSpan = windowTimeSpan;\n        this.windowCreationInterval = windowCreationInterval;\n        this.scheduler = scheduler;\n        this.windows = [];\n        if (windowCreationInterval !== null && windowCreationInterval >= 0) {\n            var window_1 = this.openWindow();\n            var closeState = { subscriber: this, window: window_1, context: null };\n            var creationState = { windowTimeSpan: windowTimeSpan, windowCreationInterval: windowCreationInterval, subscriber: this, scheduler: scheduler };\n            this.add(scheduler.schedule(dispatchWindowClose, windowTimeSpan, closeState));\n            this.add(scheduler.schedule(dispatchWindowCreation, windowCreationInterval, creationState));\n        }\n        else {\n            var window_2 = this.openWindow();\n            var timeSpanOnlyState = { subscriber: this, window: window_2, windowTimeSpan: windowTimeSpan };\n            this.add(scheduler.schedule(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState));\n        }\n    }\n    WindowTimeSubscriber.prototype._next = function (value) {\n        var windows = this.windows;\n        var len = windows.length;\n        for (var i = 0; i < len; i++) {\n            var window_3 = windows[i];\n            if (!window_3.closed) {\n                window_3.next(value);\n            }\n        }\n    };\n    WindowTimeSubscriber.prototype._error = function (err) {\n        var windows = this.windows;\n        while (windows.length > 0) {\n            windows.shift().error(err);\n        }\n        this.destination.error(err);\n    };\n    WindowTimeSubscriber.prototype._complete = function () {\n        var windows = this.windows;\n        while (windows.length > 0) {\n            var window_4 = windows.shift();\n            if (!window_4.closed) {\n                window_4.complete();\n            }\n        }\n        this.destination.complete();\n    };\n    WindowTimeSubscriber.prototype.openWindow = function () {\n        var window = new Subject_1.Subject();\n        this.windows.push(window);\n        var destination = this.destination;\n        destination.next(window);\n        return window;\n    };\n    WindowTimeSubscriber.prototype.closeWindow = function (window) {\n        window.complete();\n        var windows = this.windows;\n        windows.splice(windows.indexOf(window), 1);\n    };\n    return WindowTimeSubscriber;\n}(Subscriber_1.Subscriber));\nfunction dispatchWindowTimeSpanOnly(state) {\n    var subscriber = state.subscriber, windowTimeSpan = state.windowTimeSpan, window = state.window;\n    if (window) {\n        window.complete();\n    }\n    state.window = subscriber.openWindow();\n    this.schedule(state, windowTimeSpan);\n}\nfunction dispatchWindowCreation(state) {\n    var windowTimeSpan = state.windowTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler, windowCreationInterval = state.windowCreationInterval;\n    var window = subscriber.openWindow();\n    var action = this;\n    var context = { action: action, subscription: null };\n    var timeSpanState = { subscriber: subscriber, window: window, context: context };\n    context.subscription = scheduler.schedule(dispatchWindowClose, windowTimeSpan, timeSpanState);\n    action.add(context.subscription);\n    action.schedule(state, windowCreationInterval);\n}\nfunction dispatchWindowClose(arg) {\n    var subscriber = arg.subscriber, window = arg.window, context = arg.context;\n    if (context && context.action && context.subscription) {\n        context.action.remove(context.subscription);\n    }\n    subscriber.closeWindow(window);\n}\n//# sourceMappingURL=windowTime.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/windowTime.js\n ** module id = 345\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/windowTime.js?");

/***/ },
/* 346 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar windowToggle_1 = __webpack_require__(347);\nObservable_1.Observable.prototype.windowToggle = windowToggle_1.windowToggle;\n//# sourceMappingURL=windowToggle.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/windowToggle.js\n ** module id = 346\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/windowToggle.js?");

/***/ },
/* 347 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = __webpack_require__(4);\nvar Subscription_1 = __webpack_require__(10);\nvar tryCatch_1 = __webpack_require__(13);\nvar errorObject_1 = __webpack_require__(14);\nvar OuterSubscriber_1 = __webpack_require__(54);\nvar subscribeToResult_1 = __webpack_require__(55);\n/**\n * Branch out the source Observable values as a nested Observable starting from\n * an emission from `openings` and ending when the output of `closingSelector`\n * emits.\n *\n * <span class=\"informal\">It's like {@link bufferToggle}, but emits a nested\n * Observable instead of an array.</span>\n *\n * <img src=\"./img/windowToggle.png\" width=\"100%\">\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits windows that contain those items\n * emitted by the source Observable between the time when the `openings`\n * Observable emits an item and when the Observable returned by\n * `closingSelector` emits an item.\n *\n * @example <caption>Every other second, emit the click events from the next 500ms</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var openings = Rx.Observable.interval(1000);\n * var result = clicks.windowToggle(openings, i =>\n *   i % 2 ? Rx.Observable.interval(500) : Rx.Observable.empty()\n * ).mergeAll();\n * result.subscribe(x => console.log(x));\n *\n * @see {@link window}\n * @see {@link windowCount}\n * @see {@link windowTime}\n * @see {@link windowWhen}\n * @see {@link bufferToggle}\n *\n * @param {Observable<O>} openings An observable of notifications to start new\n * windows.\n * @param {function(value: O): Observable} closingSelector A function that takes\n * the value emitted by the `openings` observable and returns an Observable,\n * which, when it emits (either `next` or `complete`), signals that the\n * associated window should complete.\n * @return {Observable<Observable<T>>} An observable of windows, which in turn\n * are Observables.\n * @method windowToggle\n * @owner Observable\n */\nfunction windowToggle(openings, closingSelector) {\n    return this.lift(new WindowToggleOperator(openings, closingSelector));\n}\nexports.windowToggle = windowToggle;\nvar WindowToggleOperator = (function () {\n    function WindowToggleOperator(openings, closingSelector) {\n        this.openings = openings;\n        this.closingSelector = closingSelector;\n    }\n    WindowToggleOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new WindowToggleSubscriber(subscriber, this.openings, this.closingSelector));\n    };\n    return WindowToggleOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar WindowToggleSubscriber = (function (_super) {\n    __extends(WindowToggleSubscriber, _super);\n    function WindowToggleSubscriber(destination, openings, closingSelector) {\n        _super.call(this, destination);\n        this.openings = openings;\n        this.closingSelector = closingSelector;\n        this.contexts = [];\n        this.add(this.openSubscription = subscribeToResult_1.subscribeToResult(this, openings, openings));\n    }\n    WindowToggleSubscriber.prototype._next = function (value) {\n        var contexts = this.contexts;\n        if (contexts) {\n            var len = contexts.length;\n            for (var i = 0; i < len; i++) {\n                contexts[i].window.next(value);\n            }\n        }\n    };\n    WindowToggleSubscriber.prototype._error = function (err) {\n        var contexts = this.contexts;\n        this.contexts = null;\n        if (contexts) {\n            var len = contexts.length;\n            var index = -1;\n            while (++index < len) {\n                var context = contexts[index];\n                context.window.error(err);\n                context.subscription.unsubscribe();\n            }\n        }\n        _super.prototype._error.call(this, err);\n    };\n    WindowToggleSubscriber.prototype._complete = function () {\n        var contexts = this.contexts;\n        this.contexts = null;\n        if (contexts) {\n            var len = contexts.length;\n            var index = -1;\n            while (++index < len) {\n                var context = contexts[index];\n                context.window.complete();\n                context.subscription.unsubscribe();\n            }\n        }\n        _super.prototype._complete.call(this);\n    };\n    WindowToggleSubscriber.prototype._unsubscribe = function () {\n        var contexts = this.contexts;\n        this.contexts = null;\n        if (contexts) {\n            var len = contexts.length;\n            var index = -1;\n            while (++index < len) {\n                var context = contexts[index];\n                context.window.unsubscribe();\n                context.subscription.unsubscribe();\n            }\n        }\n    };\n    WindowToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        if (outerValue === this.openings) {\n            var closingSelector = this.closingSelector;\n            var closingNotifier = tryCatch_1.tryCatch(closingSelector)(innerValue);\n            if (closingNotifier === errorObject_1.errorObject) {\n                return this.error(errorObject_1.errorObject.e);\n            }\n            else {\n                var window_1 = new Subject_1.Subject();\n                var subscription = new Subscription_1.Subscription();\n                var context = { window: window_1, subscription: subscription };\n                this.contexts.push(context);\n                var innerSubscription = subscribeToResult_1.subscribeToResult(this, closingNotifier, context);\n                if (innerSubscription.closed) {\n                    this.closeWindow(this.contexts.length - 1);\n                }\n                else {\n                    innerSubscription.context = context;\n                    subscription.add(innerSubscription);\n                }\n                this.destination.next(window_1);\n            }\n        }\n        else {\n            this.closeWindow(this.contexts.indexOf(outerValue));\n        }\n    };\n    WindowToggleSubscriber.prototype.notifyError = function (err) {\n        this.error(err);\n    };\n    WindowToggleSubscriber.prototype.notifyComplete = function (inner) {\n        if (inner !== this.openSubscription) {\n            this.closeWindow(this.contexts.indexOf(inner.context));\n        }\n    };\n    WindowToggleSubscriber.prototype.closeWindow = function (index) {\n        if (index === -1) {\n            return;\n        }\n        var contexts = this.contexts;\n        var context = contexts[index];\n        var window = context.window, subscription = context.subscription;\n        contexts.splice(index, 1);\n        window.complete();\n        subscription.unsubscribe();\n    };\n    return WindowToggleSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=windowToggle.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/windowToggle.js\n ** module id = 347\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/windowToggle.js?");

/***/ },
/* 348 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar windowWhen_1 = __webpack_require__(349);\nObservable_1.Observable.prototype.windowWhen = windowWhen_1.windowWhen;\n//# sourceMappingURL=windowWhen.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/windowWhen.js\n ** module id = 348\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/windowWhen.js?");

/***/ },
/* 349 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = __webpack_require__(4);\nvar tryCatch_1 = __webpack_require__(13);\nvar errorObject_1 = __webpack_require__(14);\nvar OuterSubscriber_1 = __webpack_require__(54);\nvar subscribeToResult_1 = __webpack_require__(55);\n/**\n * Branch out the source Observable values as a nested Observable using a\n * factory function of closing Observables to determine when to start a new\n * window.\n *\n * <span class=\"informal\">It's like {@link bufferWhen}, but emits a nested\n * Observable instead of an array.</span>\n *\n * <img src=\"./img/windowWhen.png\" width=\"100%\">\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits connected, non-overlapping windows.\n * It emits the current window and opens a new one whenever the Observable\n * produced by the specified `closingSelector` function emits an item. The first\n * window is opened immediately when subscribing to the output Observable.\n *\n * @example <caption>Emit only the first two clicks events in every window of [1-5] random seconds</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks\n *   .windowWhen(() => Rx.Observable.interval(1000 + Math.random() * 4000))\n *   .map(win => win.take(2)) // each window has at most 2 emissions\n *   .mergeAll(); // flatten the Observable-of-Observables\n * result.subscribe(x => console.log(x));\n *\n * @see {@link window}\n * @see {@link windowCount}\n * @see {@link windowTime}\n * @see {@link windowToggle}\n * @see {@link bufferWhen}\n *\n * @param {function(): Observable} closingSelector A function that takes no\n * arguments and returns an Observable that signals (on either `next` or\n * `complete`) when to close the previous window and start a new one.\n * @return {Observable<Observable<T>>} An observable of windows, which in turn\n * are Observables.\n * @method windowWhen\n * @owner Observable\n */\nfunction windowWhen(closingSelector) {\n    return this.lift(new WindowOperator(closingSelector));\n}\nexports.windowWhen = windowWhen;\nvar WindowOperator = (function () {\n    function WindowOperator(closingSelector) {\n        this.closingSelector = closingSelector;\n    }\n    WindowOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new WindowSubscriber(subscriber, this.closingSelector));\n    };\n    return WindowOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar WindowSubscriber = (function (_super) {\n    __extends(WindowSubscriber, _super);\n    function WindowSubscriber(destination, closingSelector) {\n        _super.call(this, destination);\n        this.destination = destination;\n        this.closingSelector = closingSelector;\n        this.openWindow();\n    }\n    WindowSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.openWindow(innerSub);\n    };\n    WindowSubscriber.prototype.notifyError = function (error, innerSub) {\n        this._error(error);\n    };\n    WindowSubscriber.prototype.notifyComplete = function (innerSub) {\n        this.openWindow(innerSub);\n    };\n    WindowSubscriber.prototype._next = function (value) {\n        this.window.next(value);\n    };\n    WindowSubscriber.prototype._error = function (err) {\n        this.window.error(err);\n        this.destination.error(err);\n        this.unsubscribeClosingNotification();\n    };\n    WindowSubscriber.prototype._complete = function () {\n        this.window.complete();\n        this.destination.complete();\n        this.unsubscribeClosingNotification();\n    };\n    WindowSubscriber.prototype.unsubscribeClosingNotification = function () {\n        if (this.closingNotification) {\n            this.closingNotification.unsubscribe();\n        }\n    };\n    WindowSubscriber.prototype.openWindow = function (innerSub) {\n        if (innerSub === void 0) { innerSub = null; }\n        if (innerSub) {\n            this.remove(innerSub);\n            innerSub.unsubscribe();\n        }\n        var prevWindow = this.window;\n        if (prevWindow) {\n            prevWindow.complete();\n        }\n        var window = this.window = new Subject_1.Subject();\n        this.destination.next(window);\n        var closingNotifier = tryCatch_1.tryCatch(this.closingSelector)();\n        if (closingNotifier === errorObject_1.errorObject) {\n            var err = errorObject_1.errorObject.e;\n            this.destination.error(err);\n            this.window.error(err);\n        }\n        else {\n            this.add(this.closingNotification = subscribeToResult_1.subscribeToResult(this, closingNotifier));\n        }\n    };\n    return WindowSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=windowWhen.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/windowWhen.js\n ** module id = 349\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/windowWhen.js?");

/***/ },
/* 350 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar withLatestFrom_1 = __webpack_require__(351);\nObservable_1.Observable.prototype.withLatestFrom = withLatestFrom_1.withLatestFrom;\n//# sourceMappingURL=withLatestFrom.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/withLatestFrom.js\n ** module id = 350\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/withLatestFrom.js?");

/***/ },
/* 351 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = __webpack_require__(54);\nvar subscribeToResult_1 = __webpack_require__(55);\n/**\n * Combines the source Observable with other Observables to create an Observable\n * whose values are calculated from the latest values of each, only when the\n * source emits.\n *\n * <span class=\"informal\">Whenever the source Observable emits a value, it\n * computes a formula using that value plus the latest values from other input\n * Observables, then emits the output of that formula.</span>\n *\n * <img src=\"./img/withLatestFrom.png\" width=\"100%\">\n *\n * `withLatestFrom` combines each value from the source Observable (the\n * instance) with the latest values from the other input Observables only when\n * the source emits a value, optionally using a `project` function to determine\n * the value to be emitted on the output Observable. All input Observables must\n * emit at least one value before the output Observable will emit a value.\n *\n * @example <caption>On every click event, emit an array with the latest timer event plus the click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var timer = Rx.Observable.interval(1000);\n * var result = clicks.withLatestFrom(timer);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link combineLatest}\n *\n * @param {Observable} other An input Observable to combine with the source\n * Observable. More than one input Observables may be given as argument.\n * @param {Function} [project] Projection function for combining values\n * together. Receives all values in order of the Observables passed, where the\n * first parameter is a value from the source Observable. (e.g.\n * `a.withLatestFrom(b, c, (a1, b1, c1) => a1 + b1 + c1)`). If this is not\n * passed, arrays will be emitted on the output Observable.\n * @return {Observable} An Observable of projected values from the most recent\n * values from each input Observable, or an array of the most recent values from\n * each input Observable.\n * @method withLatestFrom\n * @owner Observable\n */\nfunction withLatestFrom() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i - 0] = arguments[_i];\n    }\n    var project;\n    if (typeof args[args.length - 1] === 'function') {\n        project = args.pop();\n    }\n    var observables = args;\n    return this.lift(new WithLatestFromOperator(observables, project));\n}\nexports.withLatestFrom = withLatestFrom;\n/* tslint:enable:max-line-length */\nvar WithLatestFromOperator = (function () {\n    function WithLatestFromOperator(observables, project) {\n        this.observables = observables;\n        this.project = project;\n    }\n    WithLatestFromOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new WithLatestFromSubscriber(subscriber, this.observables, this.project));\n    };\n    return WithLatestFromOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar WithLatestFromSubscriber = (function (_super) {\n    __extends(WithLatestFromSubscriber, _super);\n    function WithLatestFromSubscriber(destination, observables, project) {\n        _super.call(this, destination);\n        this.observables = observables;\n        this.project = project;\n        this.toRespond = [];\n        var len = observables.length;\n        this.values = new Array(len);\n        for (var i = 0; i < len; i++) {\n            this.toRespond.push(i);\n        }\n        for (var i = 0; i < len; i++) {\n            var observable = observables[i];\n            this.add(subscribeToResult_1.subscribeToResult(this, observable, observable, i));\n        }\n    }\n    WithLatestFromSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.values[outerIndex] = innerValue;\n        var toRespond = this.toRespond;\n        if (toRespond.length > 0) {\n            var found = toRespond.indexOf(outerIndex);\n            if (found !== -1) {\n                toRespond.splice(found, 1);\n            }\n        }\n    };\n    WithLatestFromSubscriber.prototype.notifyComplete = function () {\n        // noop\n    };\n    WithLatestFromSubscriber.prototype._next = function (value) {\n        if (this.toRespond.length === 0) {\n            var args = [value].concat(this.values);\n            if (this.project) {\n                this._tryProject(args);\n            }\n            else {\n                this.destination.next(args);\n            }\n        }\n    };\n    WithLatestFromSubscriber.prototype._tryProject = function (args) {\n        var result;\n        try {\n            result = this.project.apply(this, args);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.destination.next(result);\n    };\n    return WithLatestFromSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=withLatestFrom.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/withLatestFrom.js\n ** module id = 351\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/withLatestFrom.js?");

/***/ },
/* 352 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar zip_1 = __webpack_require__(132);\nObservable_1.Observable.prototype.zip = zip_1.zipProto;\n//# sourceMappingURL=zip.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/zip.js\n ** module id = 352\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/zip.js?");

/***/ },
/* 353 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Observable_1 = __webpack_require__(5);\nvar zipAll_1 = __webpack_require__(354);\nObservable_1.Observable.prototype.zipAll = zipAll_1.zipAll;\n//# sourceMappingURL=zipAll.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/zipAll.js\n ** module id = 353\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/add/operator/zipAll.js?");

/***/ },
/* 354 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar zip_1 = __webpack_require__(132);\n/**\n * @param project\n * @return {Observable<R>|WebSocketSubject<T>|Observable<T>}\n * @method zipAll\n * @owner Observable\n */\nfunction zipAll(project) {\n    return this.lift(new zip_1.ZipOperator(project));\n}\nexports.zipAll = zipAll;\n//# sourceMappingURL=zipAll.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/zipAll.js\n ** module id = 354\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/operator/zipAll.js?");

/***/ },
/* 355 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = __webpack_require__(5);\nvar Notification_1 = __webpack_require__(78);\nvar ColdObservable_1 = __webpack_require__(356);\nvar HotObservable_1 = __webpack_require__(360);\nvar SubscriptionLog_1 = __webpack_require__(358);\nvar VirtualTimeScheduler_1 = __webpack_require__(361);\nvar defaultMaxFrame = 750;\nvar TestScheduler = (function (_super) {\n    __extends(TestScheduler, _super);\n    function TestScheduler(assertDeepEqual) {\n        _super.call(this, VirtualTimeScheduler_1.VirtualAction, defaultMaxFrame);\n        this.assertDeepEqual = assertDeepEqual;\n        this.hotObservables = [];\n        this.coldObservables = [];\n        this.flushTests = [];\n    }\n    TestScheduler.prototype.createTime = function (marbles) {\n        var indexOf = marbles.indexOf('|');\n        if (indexOf === -1) {\n            throw new Error('marble diagram for time should have a completion marker \"|\"');\n        }\n        return indexOf * TestScheduler.frameTimeFactor;\n    };\n    TestScheduler.prototype.createColdObservable = function (marbles, values, error) {\n        if (marbles.indexOf('^') !== -1) {\n            throw new Error('cold observable cannot have subscription offset \"^\"');\n        }\n        if (marbles.indexOf('!') !== -1) {\n            throw new Error('cold observable cannot have unsubscription marker \"!\"');\n        }\n        var messages = TestScheduler.parseMarbles(marbles, values, error);\n        var cold = new ColdObservable_1.ColdObservable(messages, this);\n        this.coldObservables.push(cold);\n        return cold;\n    };\n    TestScheduler.prototype.createHotObservable = function (marbles, values, error) {\n        if (marbles.indexOf('!') !== -1) {\n            throw new Error('hot observable cannot have unsubscription marker \"!\"');\n        }\n        var messages = TestScheduler.parseMarbles(marbles, values, error);\n        var subject = new HotObservable_1.HotObservable(messages, this);\n        this.hotObservables.push(subject);\n        return subject;\n    };\n    TestScheduler.prototype.materializeInnerObservable = function (observable, outerFrame) {\n        var _this = this;\n        var messages = [];\n        observable.subscribe(function (value) {\n            messages.push({ frame: _this.frame - outerFrame, notification: Notification_1.Notification.createNext(value) });\n        }, function (err) {\n            messages.push({ frame: _this.frame - outerFrame, notification: Notification_1.Notification.createError(err) });\n        }, function () {\n            messages.push({ frame: _this.frame - outerFrame, notification: Notification_1.Notification.createComplete() });\n        });\n        return messages;\n    };\n    TestScheduler.prototype.expectObservable = function (observable, unsubscriptionMarbles) {\n        var _this = this;\n        if (unsubscriptionMarbles === void 0) { unsubscriptionMarbles = null; }\n        var actual = [];\n        var flushTest = { actual: actual, ready: false };\n        var unsubscriptionFrame = TestScheduler\n            .parseMarblesAsSubscriptions(unsubscriptionMarbles).unsubscribedFrame;\n        var subscription;\n        this.schedule(function () {\n            subscription = observable.subscribe(function (x) {\n                var value = x;\n                // Support Observable-of-Observables\n                if (x instanceof Observable_1.Observable) {\n                    value = _this.materializeInnerObservable(value, _this.frame);\n                }\n                actual.push({ frame: _this.frame, notification: Notification_1.Notification.createNext(value) });\n            }, function (err) {\n                actual.push({ frame: _this.frame, notification: Notification_1.Notification.createError(err) });\n            }, function () {\n                actual.push({ frame: _this.frame, notification: Notification_1.Notification.createComplete() });\n            });\n        }, 0);\n        if (unsubscriptionFrame !== Number.POSITIVE_INFINITY) {\n            this.schedule(function () { return subscription.unsubscribe(); }, unsubscriptionFrame);\n        }\n        this.flushTests.push(flushTest);\n        return {\n            toBe: function (marbles, values, errorValue) {\n                flushTest.ready = true;\n                flushTest.expected = TestScheduler.parseMarbles(marbles, values, errorValue, true);\n            }\n        };\n    };\n    TestScheduler.prototype.expectSubscriptions = function (actualSubscriptionLogs) {\n        var flushTest = { actual: actualSubscriptionLogs, ready: false };\n        this.flushTests.push(flushTest);\n        return {\n            toBe: function (marbles) {\n                var marblesArray = (typeof marbles === 'string') ? [marbles] : marbles;\n                flushTest.ready = true;\n                flushTest.expected = marblesArray.map(function (marbles) {\n                    return TestScheduler.parseMarblesAsSubscriptions(marbles);\n                });\n            }\n        };\n    };\n    TestScheduler.prototype.flush = function () {\n        var hotObservables = this.hotObservables;\n        while (hotObservables.length > 0) {\n            hotObservables.shift().setup();\n        }\n        _super.prototype.flush.call(this);\n        var readyFlushTests = this.flushTests.filter(function (test) { return test.ready; });\n        while (readyFlushTests.length > 0) {\n            var test = readyFlushTests.shift();\n            this.assertDeepEqual(test.actual, test.expected);\n        }\n    };\n    TestScheduler.parseMarblesAsSubscriptions = function (marbles) {\n        if (typeof marbles !== 'string') {\n            return new SubscriptionLog_1.SubscriptionLog(Number.POSITIVE_INFINITY);\n        }\n        var len = marbles.length;\n        var groupStart = -1;\n        var subscriptionFrame = Number.POSITIVE_INFINITY;\n        var unsubscriptionFrame = Number.POSITIVE_INFINITY;\n        for (var i = 0; i < len; i++) {\n            var frame = i * this.frameTimeFactor;\n            var c = marbles[i];\n            switch (c) {\n                case '-':\n                case ' ':\n                    break;\n                case '(':\n                    groupStart = frame;\n                    break;\n                case ')':\n                    groupStart = -1;\n                    break;\n                case '^':\n                    if (subscriptionFrame !== Number.POSITIVE_INFINITY) {\n                        throw new Error('found a second subscription point \\'^\\' in a ' +\n                            'subscription marble diagram. There can only be one.');\n                    }\n                    subscriptionFrame = groupStart > -1 ? groupStart : frame;\n                    break;\n                case '!':\n                    if (unsubscriptionFrame !== Number.POSITIVE_INFINITY) {\n                        throw new Error('found a second subscription point \\'^\\' in a ' +\n                            'subscription marble diagram. There can only be one.');\n                    }\n                    unsubscriptionFrame = groupStart > -1 ? groupStart : frame;\n                    break;\n                default:\n                    throw new Error('there can only be \\'^\\' and \\'!\\' markers in a ' +\n                        'subscription marble diagram. Found instead \\'' + c + '\\'.');\n            }\n        }\n        if (unsubscriptionFrame < 0) {\n            return new SubscriptionLog_1.SubscriptionLog(subscriptionFrame);\n        }\n        else {\n            return new SubscriptionLog_1.SubscriptionLog(subscriptionFrame, unsubscriptionFrame);\n        }\n    };\n    TestScheduler.parseMarbles = function (marbles, values, errorValue, materializeInnerObservables) {\n        if (materializeInnerObservables === void 0) { materializeInnerObservables = false; }\n        if (marbles.indexOf('!') !== -1) {\n            throw new Error('conventional marble diagrams cannot have the ' +\n                'unsubscription marker \"!\"');\n        }\n        var len = marbles.length;\n        var testMessages = [];\n        var subIndex = marbles.indexOf('^');\n        var frameOffset = subIndex === -1 ? 0 : (subIndex * -this.frameTimeFactor);\n        var getValue = typeof values !== 'object' ?\n            function (x) { return x; } :\n            function (x) {\n                // Support Observable-of-Observables\n                if (materializeInnerObservables && values[x] instanceof ColdObservable_1.ColdObservable) {\n                    return values[x].messages;\n                }\n                return values[x];\n            };\n        var groupStart = -1;\n        for (var i = 0; i < len; i++) {\n            var frame = i * this.frameTimeFactor + frameOffset;\n            var notification = void 0;\n            var c = marbles[i];\n            switch (c) {\n                case '-':\n                case ' ':\n                    break;\n                case '(':\n                    groupStart = frame;\n                    break;\n                case ')':\n                    groupStart = -1;\n                    break;\n                case '|':\n                    notification = Notification_1.Notification.createComplete();\n                    break;\n                case '^':\n                    break;\n                case '#':\n                    notification = Notification_1.Notification.createError(errorValue || 'error');\n                    break;\n                default:\n                    notification = Notification_1.Notification.createNext(getValue(c));\n                    break;\n            }\n            if (notification) {\n                testMessages.push({ frame: groupStart > -1 ? groupStart : frame, notification: notification });\n            }\n        }\n        return testMessages;\n    };\n    return TestScheduler;\n}(VirtualTimeScheduler_1.VirtualTimeScheduler));\nexports.TestScheduler = TestScheduler;\n//# sourceMappingURL=TestScheduler.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/testing/TestScheduler.js\n ** module id = 355\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/testing/TestScheduler.js?");

/***/ },
/* 356 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = __webpack_require__(5);\nvar Subscription_1 = __webpack_require__(10);\nvar SubscriptionLoggable_1 = __webpack_require__(357);\nvar applyMixins_1 = __webpack_require__(359);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar ColdObservable = (function (_super) {\n    __extends(ColdObservable, _super);\n    function ColdObservable(messages, scheduler) {\n        _super.call(this, function (subscriber) {\n            var observable = this;\n            var index = observable.logSubscribedFrame();\n            subscriber.add(new Subscription_1.Subscription(function () {\n                observable.logUnsubscribedFrame(index);\n            }));\n            observable.scheduleMessages(subscriber);\n            return subscriber;\n        });\n        this.messages = messages;\n        this.subscriptions = [];\n        this.scheduler = scheduler;\n    }\n    ColdObservable.prototype.scheduleMessages = function (subscriber) {\n        var messagesLength = this.messages.length;\n        for (var i = 0; i < messagesLength; i++) {\n            var message = this.messages[i];\n            subscriber.add(this.scheduler.schedule(function (_a) {\n                var message = _a.message, subscriber = _a.subscriber;\n                message.notification.observe(subscriber);\n            }, message.frame, { message: message, subscriber: subscriber }));\n        }\n    };\n    return ColdObservable;\n}(Observable_1.Observable));\nexports.ColdObservable = ColdObservable;\napplyMixins_1.applyMixins(ColdObservable, [SubscriptionLoggable_1.SubscriptionLoggable]);\n//# sourceMappingURL=ColdObservable.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/testing/ColdObservable.js\n ** module id = 356\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/testing/ColdObservable.js?");

/***/ },
/* 357 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar SubscriptionLog_1 = __webpack_require__(358);\nvar SubscriptionLoggable = (function () {\n    function SubscriptionLoggable() {\n        this.subscriptions = [];\n    }\n    SubscriptionLoggable.prototype.logSubscribedFrame = function () {\n        this.subscriptions.push(new SubscriptionLog_1.SubscriptionLog(this.scheduler.now()));\n        return this.subscriptions.length - 1;\n    };\n    SubscriptionLoggable.prototype.logUnsubscribedFrame = function (index) {\n        var subscriptionLogs = this.subscriptions;\n        var oldSubscriptionLog = subscriptionLogs[index];\n        subscriptionLogs[index] = new SubscriptionLog_1.SubscriptionLog(oldSubscriptionLog.subscribedFrame, this.scheduler.now());\n    };\n    return SubscriptionLoggable;\n}());\nexports.SubscriptionLoggable = SubscriptionLoggable;\n//# sourceMappingURL=SubscriptionLoggable.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/testing/SubscriptionLoggable.js\n ** module id = 357\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/testing/SubscriptionLoggable.js?");

/***/ },
/* 358 */
/***/ function(module, exports) {

	eval("\"use strict\";\nvar SubscriptionLog = (function () {\n    function SubscriptionLog(subscribedFrame, unsubscribedFrame) {\n        if (unsubscribedFrame === void 0) { unsubscribedFrame = Number.POSITIVE_INFINITY; }\n        this.subscribedFrame = subscribedFrame;\n        this.unsubscribedFrame = unsubscribedFrame;\n    }\n    return SubscriptionLog;\n}());\nexports.SubscriptionLog = SubscriptionLog;\n//# sourceMappingURL=SubscriptionLog.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/testing/SubscriptionLog.js\n ** module id = 358\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/testing/SubscriptionLog.js?");

/***/ },
/* 359 */
/***/ function(module, exports) {

	eval("\"use strict\";\nfunction applyMixins(derivedCtor, baseCtors) {\n    for (var i = 0, len = baseCtors.length; i < len; i++) {\n        var baseCtor = baseCtors[i];\n        var propertyKeys = Object.getOwnPropertyNames(baseCtor.prototype);\n        for (var j = 0, len2 = propertyKeys.length; j < len2; j++) {\n            var name_1 = propertyKeys[j];\n            derivedCtor.prototype[name_1] = baseCtor.prototype[name_1];\n        }\n    }\n}\nexports.applyMixins = applyMixins;\n//# sourceMappingURL=applyMixins.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/util/applyMixins.js\n ** module id = 359\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/util/applyMixins.js?");

/***/ },
/* 360 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = __webpack_require__(4);\nvar Subscription_1 = __webpack_require__(10);\nvar SubscriptionLoggable_1 = __webpack_require__(357);\nvar applyMixins_1 = __webpack_require__(359);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar HotObservable = (function (_super) {\n    __extends(HotObservable, _super);\n    function HotObservable(messages, scheduler) {\n        _super.call(this);\n        this.messages = messages;\n        this.subscriptions = [];\n        this.scheduler = scheduler;\n    }\n    HotObservable.prototype._subscribe = function (subscriber) {\n        var subject = this;\n        var index = subject.logSubscribedFrame();\n        subscriber.add(new Subscription_1.Subscription(function () {\n            subject.logUnsubscribedFrame(index);\n        }));\n        return _super.prototype._subscribe.call(this, subscriber);\n    };\n    HotObservable.prototype.setup = function () {\n        var subject = this;\n        var messagesLength = subject.messages.length;\n        /* tslint:disable:no-var-keyword */\n        for (var i = 0; i < messagesLength; i++) {\n            (function () {\n                var message = subject.messages[i];\n                /* tslint:enable */\n                subject.scheduler.schedule(function () { message.notification.observe(subject); }, message.frame);\n            })();\n        }\n    };\n    return HotObservable;\n}(Subject_1.Subject));\nexports.HotObservable = HotObservable;\napplyMixins_1.applyMixins(HotObservable, [SubscriptionLoggable_1.SubscriptionLoggable]);\n//# sourceMappingURL=HotObservable.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/testing/HotObservable.js\n ** module id = 360\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/testing/HotObservable.js?");

/***/ },
/* 361 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar AsyncAction_1 = __webpack_require__(97);\nvar AsyncScheduler_1 = __webpack_require__(99);\nvar VirtualTimeScheduler = (function (_super) {\n    __extends(VirtualTimeScheduler, _super);\n    function VirtualTimeScheduler(SchedulerAction, maxFrames) {\n        var _this = this;\n        if (SchedulerAction === void 0) { SchedulerAction = VirtualAction; }\n        if (maxFrames === void 0) { maxFrames = Number.POSITIVE_INFINITY; }\n        _super.call(this, SchedulerAction, function () { return _this.frame; });\n        this.maxFrames = maxFrames;\n        this.frame = 0;\n        this.index = -1;\n    }\n    /**\n     * Prompt the Scheduler to execute all of its queued actions, therefore\n     * clearing its queue.\n     * @return {void}\n     */\n    VirtualTimeScheduler.prototype.flush = function () {\n        var _a = this, actions = _a.actions, maxFrames = _a.maxFrames;\n        var error, action;\n        while ((action = actions.shift()) && (this.frame = action.delay) <= maxFrames) {\n            if (error = action.execute(action.state, action.delay)) {\n                break;\n            }\n        }\n        if (error) {\n            while (action = actions.shift()) {\n                action.unsubscribe();\n            }\n            throw error;\n        }\n    };\n    VirtualTimeScheduler.frameTimeFactor = 10;\n    return VirtualTimeScheduler;\n}(AsyncScheduler_1.AsyncScheduler));\nexports.VirtualTimeScheduler = VirtualTimeScheduler;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar VirtualAction = (function (_super) {\n    __extends(VirtualAction, _super);\n    function VirtualAction(scheduler, work, index) {\n        if (index === void 0) { index = scheduler.index += 1; }\n        _super.call(this, scheduler, work);\n        this.scheduler = scheduler;\n        this.work = work;\n        this.index = index;\n        this.index = scheduler.index = index;\n    }\n    VirtualAction.prototype.schedule = function (state, delay) {\n        if (delay === void 0) { delay = 0; }\n        return !this.id ?\n            _super.prototype.schedule.call(this, state, delay) : this.add(new VirtualAction(this.scheduler, this.work)).schedule(state, delay);\n    };\n    VirtualAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) { delay = 0; }\n        this.delay = scheduler.frame + delay;\n        var actions = scheduler.actions;\n        actions.push(this);\n        actions.sort(VirtualAction.sortActions);\n        return true;\n    };\n    VirtualAction.prototype.recycleAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) { delay = 0; }\n        return undefined;\n    };\n    VirtualAction.sortActions = function (a, b) {\n        if (a.delay === b.delay) {\n            if (a.index === b.index) {\n                return 0;\n            }\n            else if (a.index > b.index) {\n                return 1;\n            }\n            else {\n                return -1;\n            }\n        }\n        else if (a.delay > b.delay) {\n            return 1;\n        }\n        else {\n            return -1;\n        }\n    };\n    return VirtualAction;\n}(AsyncAction_1.AsyncAction));\nexports.VirtualAction = VirtualAction;\n//# sourceMappingURL=VirtualTimeScheduler.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/scheduler/VirtualTimeScheduler.js\n ** module id = 361\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/scheduler/VirtualTimeScheduler.js?");

/***/ },
/* 362 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar AnimationFrameAction_1 = __webpack_require__(363);\nvar AnimationFrameScheduler_1 = __webpack_require__(365);\nexports.animationFrame = new AnimationFrameScheduler_1.AnimationFrameScheduler(AnimationFrameAction_1.AnimationFrameAction);\n//# sourceMappingURL=animationFrame.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/scheduler/animationFrame.js\n ** module id = 362\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/scheduler/animationFrame.js?");

/***/ },
/* 363 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar AsyncAction_1 = __webpack_require__(97);\nvar AnimationFrame_1 = __webpack_require__(364);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar AnimationFrameAction = (function (_super) {\n    __extends(AnimationFrameAction, _super);\n    function AnimationFrameAction(scheduler, work) {\n        _super.call(this, scheduler, work);\n        this.scheduler = scheduler;\n        this.work = work;\n    }\n    AnimationFrameAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) { delay = 0; }\n        // If delay is greater than 0, request as an async action.\n        if (delay !== null && delay > 0) {\n            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);\n        }\n        // Push the action to the end of the scheduler queue.\n        scheduler.actions.push(this);\n        // If an animation frame has already been requested, don't request another\n        // one. If an animation frame hasn't been requested yet, request one. Return\n        // the current animation frame request id.\n        return scheduler.scheduled || (scheduler.scheduled = AnimationFrame_1.AnimationFrame.requestAnimationFrame(scheduler.flush.bind(scheduler, null)));\n    };\n    AnimationFrameAction.prototype.recycleAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) { delay = 0; }\n        // If delay exists and is greater than 0, recycle as an async action.\n        if (delay !== null && delay > 0) {\n            return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);\n        }\n        // If the scheduler queue is empty, cancel the requested animation frame and\n        // set the scheduled flag to undefined so the next AnimationFrameAction will\n        // request its own.\n        if (scheduler.actions.length === 0) {\n            AnimationFrame_1.AnimationFrame.cancelAnimationFrame(id);\n            scheduler.scheduled = undefined;\n        }\n        // Return undefined so the action knows to request a new async id if it's rescheduled.\n        return undefined;\n    };\n    return AnimationFrameAction;\n}(AsyncAction_1.AsyncAction));\nexports.AnimationFrameAction = AnimationFrameAction;\n//# sourceMappingURL=AnimationFrameAction.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/scheduler/AnimationFrameAction.js\n ** module id = 363\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/scheduler/AnimationFrameAction.js?");

/***/ },
/* 364 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar root_1 = __webpack_require__(6);\nvar RequestAnimationFrameDefinition = (function () {\n    function RequestAnimationFrameDefinition(root) {\n        if (root.requestAnimationFrame) {\n            this.cancelAnimationFrame = root.cancelAnimationFrame.bind(root);\n            this.requestAnimationFrame = root.requestAnimationFrame.bind(root);\n        }\n        else if (root.mozRequestAnimationFrame) {\n            this.cancelAnimationFrame = root.mozCancelAnimationFrame.bind(root);\n            this.requestAnimationFrame = root.mozRequestAnimationFrame.bind(root);\n        }\n        else if (root.webkitRequestAnimationFrame) {\n            this.cancelAnimationFrame = root.webkitCancelAnimationFrame.bind(root);\n            this.requestAnimationFrame = root.webkitRequestAnimationFrame.bind(root);\n        }\n        else if (root.msRequestAnimationFrame) {\n            this.cancelAnimationFrame = root.msCancelAnimationFrame.bind(root);\n            this.requestAnimationFrame = root.msRequestAnimationFrame.bind(root);\n        }\n        else if (root.oRequestAnimationFrame) {\n            this.cancelAnimationFrame = root.oCancelAnimationFrame.bind(root);\n            this.requestAnimationFrame = root.oRequestAnimationFrame.bind(root);\n        }\n        else {\n            this.cancelAnimationFrame = root.clearTimeout.bind(root);\n            this.requestAnimationFrame = function (cb) { return root.setTimeout(cb, 1000 / 60); };\n        }\n    }\n    return RequestAnimationFrameDefinition;\n}());\nexports.RequestAnimationFrameDefinition = RequestAnimationFrameDefinition;\nexports.AnimationFrame = new RequestAnimationFrameDefinition(root_1.root);\n//# sourceMappingURL=AnimationFrame.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/util/AnimationFrame.js\n ** module id = 364\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/util/AnimationFrame.js?");

/***/ },
/* 365 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar AsyncScheduler_1 = __webpack_require__(99);\nvar AnimationFrameScheduler = (function (_super) {\n    __extends(AnimationFrameScheduler, _super);\n    function AnimationFrameScheduler() {\n        _super.apply(this, arguments);\n    }\n    AnimationFrameScheduler.prototype.flush = function () {\n        this.active = true;\n        this.scheduled = undefined;\n        var actions = this.actions;\n        var error;\n        var index = -1;\n        var count = actions.length;\n        var action = actions.shift();\n        do {\n            if (error = action.execute(action.state, action.delay)) {\n                break;\n            }\n        } while (++index < count && (action = actions.shift()));\n        this.active = false;\n        if (error) {\n            while (++index < count && (action = actions.shift())) {\n                action.unsubscribe();\n            }\n            throw error;\n        }\n    };\n    return AnimationFrameScheduler;\n}(AsyncScheduler_1.AsyncScheduler));\nexports.AnimationFrameScheduler = AnimationFrameScheduler;\n//# sourceMappingURL=AnimationFrameScheduler.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/scheduler/AnimationFrameScheduler.js\n ** module id = 365\n ** module chunks = 2\n **/\n//# sourceURL=webpack:///./~/rxjs/scheduler/AnimationFrameScheduler.js?");

/***/ }
]);